<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Good Vibes Only - AI-Powered Website Builder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: #fafafa;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #ffffff;
            padding: 20px;
            text-align: center;
            color: #09090b;
            border-bottom: 1px solid #e4e4e7;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-weight: 600;
        }

        .header p {
            color: #71717a;
            font-size: 14px;
        }

        .main-container {
            flex: 1;
            display: flex;
            gap: 20px;
            padding: 20px;
            max-width: 1600px;
            width: 100%;
            margin: 0 auto;
        }

        .chat-panel {
            width: 30%; /* 30% of screen */
            min-width: 350px;
            max-width: 500px;
            background: white;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border: 1px solid #e4e4e7;
            overflow: hidden;
            position: relative;
        }

        .chat-header {
            padding: 15px;
            background: #ffffff;
            color: #09090b;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #e4e4e7;
            font-weight: 500;
        }

        .settings-toggle {
            background: #f4f4f5;
            border: 1px solid #e4e4e7;
            color: #71717a;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-toggle:hover {
            background: #e4e4e7;
            color: #09090b;
        }

        .api-config {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #fafafa;
            z-index: 100;
            overflow-y: auto;
        }

        .api-config input {
            flex: 1;
            min-width: 200px;
            padding: 8px 12px;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            font-size: 14px;
        }

        .api-config select {
            padding: 8px 12px;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #fafbfc;
        }

        .message {
            margin-bottom: 15px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            text-align: right;
        }

        .message.assistant {
            text-align: left;
        }

        .message-content {
            display: inline-block;
            padding: 10px 15px;
            border-radius: 8px;
            max-width: 80%;
            word-wrap: break-word;
        }

        .message.user .message-content {
            background: #09090b;
            color: white;
        }

        .message.assistant .message-content {
            background: #f4f4f5;
            color: #09090b;
            border: 1px solid #e4e4e7;
        }

        .message-label {
            font-size: 12px;
            color: #71717a;
            margin-bottom: 5px;
        }

        .chat-input {
            padding: 20px;
            background: white;
            border-top: 1px solid #e4e4e7;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .input-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .mode-toggle {
            display: flex;
            background: #f4f4f5;
            border-radius: 6px;
            padding: 3px;
            gap: 2px;
        }
        
        .mode-toggle button {
            padding: 6px 12px;
            border: none;
            background: transparent;
            border-radius: 6px; background: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #71717a;
            transition: all 0.2s;
        }
        
        .mode-toggle button.active {
            background: white;
            color: #09090b;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        
        .element-picker-btn {
            padding: 6px 12px;
            background: white;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            color: #71717a;
            transition: all 0.2s;
        }
        
        .element-picker-btn:hover {
            border-color: #a1a1aa;
            background: #fafafa;
            color: #09090b;
        }
        
        .element-picker-btn.active {
            background: #09090b;
            color: white;
            border-color: #09090b;
        }
        
        .selected-element-tag {
            padding: 4px 8px;
            background: #f4f4f5;
            color: #09090b;
            border-radius: 6px; background: white;
            font-size: 12px;
            font-family: monospace;
            border: 1px solid #e4e4e7;
        }
        
        .reference-input {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .reference-input input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }
        
        .reference-input input:focus {
            outline: none;
            border-color: #a1a1aa;
            box-shadow: 0 0 0 3px rgba(161, 161, 170, 0.1);
        }
        
        .fetch-button {
            padding: 8px 16px;
            background: #09090b;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .fetch-button:hover {
            background: #27272a;
            transform: translateY(-1px);
        }
        
        .fetch-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .chat-input-row {
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: relative;
        }
        
        .button-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .attach-image-button {
            background: white;
            border: 1px solid #e4e4e7;
            color: #71717a;
            width: 40px;
            height: 40px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .attach-image-button:hover {
            background: #f4f4f5;
            border-color: #a1a1aa;
            color: #09090b;
        }
        
        .clear-chat-button {
            background: transparent;
            border: 1px solid #e4e4e7;
            color: #a1a1aa;
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            align-self: flex-start;
            margin-top: -5px;
        }
        
        .clear-chat-button:hover {
            background: #fafafa;
            border-color: #a1a1aa;
            color: #71717a;
        }

        .chat-input textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            font-size: 14px;
            resize: vertical;
            font-family: inherit;
            min-height: 80px;
            max-height: 200px;
            background: white;
        }

        .send-button {
            width: 100%;
            padding: 10px 20px;
            background: #09090b;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .send-button:hover {
            background: #27272a;
            transform: translateY(-1px);
        }
        
        .send-button:active {
            transform: translateY(0);
        }

        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            background: #e4e4e7;
        }

        .preview-panel {
            flex: 1;
            background: white;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border: 1px solid #e4e4e7;
            overflow: hidden;
        }

        .preview-tabs {
            display: flex;
            padding-top:7px;
            padding-bottom:7px;
            background: #fafafa;
            border-bottom: 1px solid #e4e4e7;
        }

        .preview-tab {
            padding: 10px 16px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 14px;
            font-weight: 500;
            color: #71717a;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .preview-tab.active {
            color: #09090b;
            border-bottom-color: #09090b;
        }
        
        .device-toggles {
            margin-left: auto;
            display: flex;
            gap: 8px;
            padding-right: 15px;
        }
        
        .device-toggle {
            padding: 8px;
            background: transparent;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            cursor: pointer;
            color: #71717a;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .device-toggle:hover {
            background: #fafafa;
            border-color: #a1a1aa;
            color: #09090b;
        }
        
        .device-toggle.active {
            background: #09090b;
            border-color: #09090b;
            color: white;
        }
        
        .device-toggle svg {
            width: 20px;
            height: 20px;
        }

        .preview-content {
            flex: 1;
            overflow: auto;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: #fafafa;
        }

        .code-editor {
            width: 100%;
            height: 100%;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            line-height: 1.6;
            background: #1e1e1e;
            color: #d4d4d4;
            border: none;
            outline: none;
            resize: none;
        }

        .preview-frame {
            width: 100%;
            height: 100%;
            border: 1px solid #e4e4e7;
            background: white;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border-radius: 6px;
        }
        
        /* Device-specific preview sizes */
        .preview-frame.desktop {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
        }
        
        .preview-frame.tablet {
            width: 768px;
            max-width: 90%;
            height: 1024px;
            max-height: 90%;
        }
        
        .preview-frame.mobile {
            width: 375px;
            max-width: 90%;
            height: 667px;
            max-height: 90%;
        }

        .json-output {
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            word-wrap: break-word;
            height: 100%;
            overflow: auto;
        }

        .controls {
            padding: 15px;
            background: #fafafa;
            border-top: 1px solid #e4e4e7;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .control-button {
            padding: 8px 16px;
            background: white;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .control-button:hover {
            background: #fafafa;
            border-color: #a1a1aa;
            color: #09090b;
        }

        .control-button.primary {
            background: #09090b;
            color: white;
            border-color: #09090b;
        }

        .control-button.primary:hover {
            background: #27272a;
        }
        .control-button.active {
            background: #09090b !important;
            color: white !important;
            border-color: #09090b !important;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .prompt-suggestions {
            background: #fafafa;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            margin-bottom: 10px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .prompt-suggestions.collapsed .suggestions-grid {
            display: none;
        }

        .suggestions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #f4f4f5;
            cursor: pointer;
            user-select: none;
        }

        .suggestions-label {
            font-size: 12px;
            color: #71717a;
            font-weight: 500;
        }

        .suggestions-toggle {
            background: none;
            border: none;
            color: #71717a;
            cursor: pointer;
            padding: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s;
        }

        .prompt-suggestions.collapsed .suggestions-toggle {
            transform: rotate(-90deg);
        }

        .suggestions-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            padding: 8px;
        }

        .suggestion-chip {
            display: flex;
            align-items: center;
            padding: 5px 8px;
            background: white;
            border: 1px solid #e4e4e7;
            border-radius: 6px; background: white;
            font-size: 11px;
            color: #52525b;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .suggestion-chip:hover {
            background: #09090b;
            color: white;
            border-color: #09090b;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .suggestion-chip.custom {
            position: relative;
            padding-right: 12px;
        }
        
        .suggestion-chip .delete-btn {
            position: absolute;
            right: -25px;
            top: 50%;
            transform: translateY(-50%);
            background: #ef4444;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
            pointer-events: none;
            font-size: 14px;
        }
        
        .suggestion-chip.custom:hover .delete-btn {
            opacity: 1;
            right: 4px;
            pointer-events: auto;
        }
        
        .suggestion-chip .delete-btn:hover {
            background: #dc2626;
            transform: translateY(-50%) scale(1.1);
        }

        .loading-indicator {
            display: none;
            padding: 10px;
            text-align: center;
            color: #71717a;
        }

        .loading-indicator.active {
            display: block;
        }

        .loading-dots {
            display: inline-block;
        }

        .loading-dots::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .element-picker-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }
        
        .element-picker-overlay.active {
            pointer-events: auto;
        }
        
        .element-highlight {
            position: absolute;
            border: 2px dashed #a1a1aa;
            background: rgba(161, 161, 170, 0.1);
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .element-highlight:hover {
            background: rgba(161, 161, 170, 0.2);
            border-color: #71717a;
        }
        
        .element-highlight.selected {
            border: 2px solid #09090b;
            background: rgba(9, 9, 11, 0.05);
            box-shadow: 0 0 0 4px rgba(9, 9, 11, 0.1);
        }
        
        .element-label {
            position: absolute;
            top: -24px;
            left: -2px;
            background: #09090b;
            color: white;
            padding: 2px 8px;
            border-radius: 4px 4px 0 0;
            font-size: 11px;
            font-family: monospace;
            white-space: nowrap;
        }
        
        .context-menu-item:hover {
            background: #f4f4f5;
        }
        
        .property-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            font-size: 14px;
            margin: 5px 0;
            background: white;
        }
        
        .property-input:focus {
            outline: none;
            border-color: #a1a1aa;
            box-shadow: 0 0 0 3px rgba(161, 161, 170, 0.1);
        }
        
        .property-group {
            margin: 15px 0;
        }
        
        .property-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #09090b;
            font-size: 14px;
        }
        
        .element-highlight {
            outline: 2px dashed #a1a1aa !important;
            outline-offset: 2px;
        }
        
        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
            }
            
            .preview-panel {
                min-height: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 style="display: flex; align-items: center;">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#09090b" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
            </svg>
            Good Vibes Only<span style="font-size: 14px; opacity: 0.8;">for Oxygen Builder</span>
        </h1>
        <p>Chat with AI to create beautiful websites - Export directly to Oxygen Builder</p>
    </div>

    <div class="main-container">
        <div class="chat-panel">
            <div class="chat-header">
                <h3 style="margin: 0; flex: 1;">Vibe here</h3>
                <button class="media-toggle" onclick="toggleMedia()" title="Generated Images" style="background: none; border: none; color: #71717a; cursor: pointer; padding: 8px; display: flex; align-items: center; justify-content: center; border-radius: 6px; transition: all 0.2s;" onmouseover="this.style.background='#f4f4f5'" onmouseout="this.style.background='none'">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                        <circle cx="8.5" cy="8.5" r="1.5"></circle>
                        <polyline points="21 15 16 10 5 21"></polyline>
                    </svg>
                </button>
                <button class="settings-toggle" onclick="toggleSettings()" title="Settings">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </button>
            </div>

            <div class="api-config" id="mediaPanel" style="display: none;">
                <div style="padding: 20px; background: #ffffff; height: 100%; display: flex; flex-direction: column;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #e4e4e7;">
                        <h4 style="margin: 0; color: #09090b; font-weight: 600; display: flex; align-items: center;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#09090b" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                <polyline points="21 15 16 10 5 21"></polyline>
                            </svg>
                            Generated Images
                        </h4>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <button onclick="showImageGenerationDialog()" style="padding: 6px 12px; background: #09090b; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 6px; transition: all 0.2s;" onmouseover="this.style.background='#27272a'" onmouseout="this.style.background='#09090b'">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <line x1="12" y1="5" x2="12" y2="19"></line>
                                    <line x1="5" y1="12" x2="19" y2="12"></line>
                                </svg>
                                Generate New
                            </button>
                            <button onclick="toggleMedia()" style="background: none; border: none; cursor: pointer; padding: 5px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f4f4f5'" onmouseout="this.style.background='none'">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2">
                                    <line x1="18" y1="6" x2="6" y2="18"></line>
                                    <line x1="6" y1="6" x2="18" y2="18"></line>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div style="flex: 1; overflow-y: auto; padding: 10px;">
                        <div id="mediaGallery" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px;">
                            <!-- Generated images will appear here -->
                        </div>
                        <div id="noMediaMessage" style="text-align: center; color: #71717a; padding: 40px 20px; font-size: 14px;">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin: 0 auto 10px; opacity: 0.3;">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                <polyline points="21 15 16 10 5 21"></polyline>
                            </svg>
                            <p style="margin: 0;">No images generated yet</p>
                            <p style="margin: 5px 0 0 0; font-size: 12px; color: #a1a1aa;">Generated images will appear here</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="api-config" id="settingsPanel" style="display: none;">
                <div style="padding: 20px; background: #ffffff; height: 100%; display: flex; flex-direction: column;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #e4e4e7;">
                        <h4 style="margin: 0; color: #09090b; font-weight: 600;">⚙️ Settings</h4>
                        <button onclick="toggleSettings()" style="background: none; border: none; cursor: pointer; padding: 5px; border-radius: 4px; transition: background 0.2s;" onmouseover="this.style.background='#f4f4f5'" onmouseout="this.style.background='none'">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                    <div style="flex: 1; overflow-y: auto; padding-right: 10px;">
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 12px; color: #71717a; margin-bottom: 5px;">OpenRouter API Key:</label>
                        <input type="password" id="apiKey" placeholder="Enter your API key" style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px; background: white;" />
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 12px; color: #71717a; margin-bottom: 5px;">AI Model for Coding:</label>
                        <select id="modelSelect" style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px; background: white;">
                            <option value="x-ai/grok-code-fast-1">Grok Code Fast (128K)</option>
                            <option value="openai/gpt-5">GPT-5 (200K)</option>
                            <option value="x-ai/grok-4">Grok 4 (128K)</option>
                            <option value="google/gemini-2.5-flash">Gemini 2.5 Flash (1M)</option>
                            <option value="google/gemini-2.5-pro">Gemini 2.5 Pro (2M)</option>
                            <option value="anthropic/claude-sonnet-4">Claude Sonnet 4 (200K)</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 12px; color: #71717a; margin-bottom: 5px;">AI Vision Model (for screenshot analysis):</label>
                        <select id="visionModelSelect" style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px; background: white;">
                            <option value="google/gemini-2.5-flash-image-preview">Gemini 2.5 Flash Image Preview (1M)</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 12px; color: #71717a; margin-bottom: 5px;">AI Image Generation Model:</label>
                        <select id="imageGenModelSelect" style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px; background: white;">
                            <option value="google/gemini-2.5-flash-image-preview">Gemini 2.5 Flash Image Preview (1M)</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 12px; color: #71717a; margin-bottom: 5px;">System Prompt (customize AI behavior):</label>
                        <textarea id="systemPrompt" placeholder="You are an expert web developer..." style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px; background: white; min-height: 100px; font-family: monospace; font-size: 12px; resize: vertical;">You are an expert web developer specializing in creating beautiful, modern web components. You focus on clean, semantic HTML, modern CSS with smooth animations, and efficient JavaScript when needed.

IMPORTANT IMAGE HANDLING:
- Always use placeholder images from https://via.placeholder.com/
- Format: https://via.placeholder.com/WIDTHxHEIGHT/BGCOLOR/TEXTCOLOR?text=DESCRIPTION
- Include descriptive text that clearly explains what the final image should be
- Examples:
  - https://via.placeholder.com/1920x600/667eea/ffffff?text=Hero+Banner:+Team+Collaboration+in+Modern+Office
  - https://via.placeholder.com/400x300/f0f0f0/333333?text=Product+Image:+Laptop+on+Desk
- Add data-image-prompt attribute with detailed prompt for AI generation later
- Example: &lt;img src="placeholder.jpg" data-image-prompt="Professional team meeting in bright modern office, diverse group collaborating around table with laptops, natural lighting"&gt;</textarea>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 12px; color: #71717a; margin-bottom: 5px;">Brand Guidelines (colors, fonts, style preferences):</label>
                        <textarea id="brandGuidelines" placeholder="Primary color: #667eea&#10;Font: Inter, sans-serif&#10;Style: Modern, minimalist..." style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px; background: white; min-height: 80px; font-family: monospace; font-size: 12px; resize: vertical;"></textarea>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 12px; color: #71717a; margin-bottom: 5px;">Image Generation Prompt Template:</label>
                        <textarea id="imagePromptTemplate" placeholder="Professional photography, high quality, 8k resolution, {description}, modern aesthetic, clean composition..." style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px; background: white; min-height: 80px; font-family: monospace; font-size: 12px; resize: vertical;">Professional photography, high quality, 8k resolution, {description}, modern aesthetic, clean composition, natural lighting, sharp focus, visually appealing</textarea>
                        <small style="color: #a1a1aa; font-size: 11px;">Use {description} as placeholder for the image description from placeholders</small>
                    </div>
                    
                    <button class="control-button" onclick="saveConfig()" style="width: 100%;">💾 Save Settings</button>
                    </div>
                </div>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div class="prompt-suggestions" id="promptSuggestions">
                    <div class="suggestions-header" onclick="toggleSuggestions()" style="cursor: pointer;">
                        <span class="suggestions-label">💡 Quick starts</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <button class="add-suggestion-btn" onclick="event.stopPropagation(); showAddSuggestionDialog()" title="Add custom quick start" style="background: none; border: none; color: #71717a; cursor: pointer; padding: 4px; display: flex; align-items: center; font-size: 16px;">+</button>
                            <svg class="suggestions-toggle" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </div>
                    </div>
                    <div class="suggestions-grid" id="suggestionsGrid">
                        <!-- Default suggestions will be loaded here -->
                    </div>
                </div>
            </div>

            <div class="loading-indicator" id="loadingIndicator">
                <span>AI is thinking</span><span class="loading-dots"></span>
            </div>

            <div class="chat-input">
                <div class="input-controls">
                    <div class="mode-toggle">
                        <button id="addModeBtn" class="active" onclick="setMode('add')">➕ Add</button>
                        <button id="editModeBtn" onclick="setMode('edit')">✏️ Edit</button>
                        <button id="referenceModeBtn" onclick="setMode('reference')" style="display: flex; align-items: center; justify-content: center;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 4px;">
                                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                            </svg>
                            Reference
                        </button>
                        <button id="planModeBtn" onclick="setMode('plan')" style="display: flex; align-items: center; justify-content: center;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 4px;">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                <polyline points="14 2 14 8 20 8"></polyline>
                                <line x1="16" y1="13" x2="8" y2="13"></line>
                                <line x1="16" y1="17" x2="8" y2="17"></line>
                                <polyline points="10 9 9 9 8 9"></polyline>
                            </svg>
                            Plan
                        </button>
                    </div>
                    <button class="element-picker-btn" id="elementPickerBtn" onclick="toggleElementPicker()" style="display: none;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 4px;">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M12 1v6m0 6v6m11-11h-6m-6 0H1"></path>
                        </svg>
                        Select Element
                    </button>
                </div>
                <div class="reference-input" id="referenceInput" style="display: none;">
                    <input type="url" id="referenceUrl" placeholder="Enter website URL to reference (e.g., https://example.com)" />
                    <button class="fetch-button" onclick="fetchReference()">🌐 Fetch & Analyze</button>
                </div>
                <div class="chat-input-row">
                    <textarea id="userInput" placeholder="Describe what you want to build... (e.g., 'Create a modern hero section with a gradient background and call-to-action button')" 
                        onkeydown="handleKeyPress(event)"></textarea>
                    <div class="button-row">
                        <button class="send-button" onclick="sendMessage()" id="sendButton" style="display: flex; align-items: center; justify-content: center;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                                <line x1="22" y1="2" x2="11" y2="13"></line>
                                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                            </svg>
                            Send Message
                        </button>
                        <button class="attach-image-button" onclick="attachImage()" title="Attach an image">
                            📎
                        </button>
                        <button class="screenshot-button" onclick="screenshotWithPrompt()" title="Take a screenshot" style="background: white; color: #71717a; border: 1px solid #e4e4e7; padding: 10px; border-radius: 8px; cursor: pointer; width: 44px; height: 44px; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" onmouseover="this.style.background='#fafafa'" onmouseout="this.style.background='white'">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                                <circle cx="12" cy="13" r="4"></circle>
                            </svg>
                        </button>
                    </div>
                    <button class="clear-chat-button" onclick="clearAll()" title="Clear conversation history">Clear chat</button>
                    <div style="display: flex; align-items: center; gap: 8px; margin-top: 10px;">
                        <input type="checkbox" id="autoGenerateImages" style="width: 16px; height: 16px; cursor: pointer;">
                        <label for="autoGenerateImages" style="font-size: 13px; color: #71717a; cursor: pointer; user-select: none;">
                            Auto-generate images for all placeholders
                        </label>
                    </div>
                </div>
                <input type="file" id="imageInput" accept="image/*" style="display: none;" onchange="handleImageSelect(event)">
            </div>
        </div>

        <div class="preview-panel">
            <div class="preview-tabs">
                <button class="preview-tab active" onclick="switchTab('preview')">Preview</button>
                <button class="preview-tab" onclick="switchTab('html')">HTML</button>
                <button class="preview-tab" onclick="switchTab('css')">CSS</button>
                <button class="preview-tab" onclick="switchTab('js')">JavaScript</button>
                <button class="preview-tab" onclick="switchTab('json')">Oxygen JSON</button>
                
                <div class="device-toggles">
                    <button class="device-toggle active" onclick="setDevice('desktop')" title="Desktop View">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="2" y="3" width="20" height="14" rx="2" />
                            <line x1="8" y1="21" x2="16" y2="21" />
                            <line x1="12" y1="17" x2="12" y2="21" />
                        </svg>
                    </button>
                    <button class="device-toggle" onclick="setDevice('tablet')" title="Tablet View">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="4" y="2" width="16" height="20" rx="2" />
                            <line x1="12" y1="18" x2="12.01" y2="18" />
                        </svg>
                    </button>
                    <button class="device-toggle" onclick="setDevice('mobile')" title="Mobile View">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="5" y="2" width="14" height="20" rx="2" />
                            <line x1="12" y1="18" x2="12.01" y2="18" />
                        </svg>
                    </button>
                    <button class="device-toggle" onclick="toggleFullscreen()" id="fullscreenBtn" title="Fullscreen View">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" />
                        </svg>
                    </button>
                </div>
            </div>

            <div class="preview-content">
                <iframe class="preview-frame" id="previewFrame" style="display: block;"></iframe>
                <textarea class="code-editor" id="htmlEditor" style="display: none;"></textarea>
                <textarea class="code-editor" id="cssEditor" style="display: none;"></textarea>
                <textarea class="code-editor" id="jsEditor" style="display: none;"></textarea>
                <div class="json-output" id="jsonOutput" style="display: none;"></div>
            </div>

            <div class="controls">
                <button class="control-button" onclick="showMemoryDialog()">📜 History</button>
                <button class="control-button" onclick="toggleEditMode()" id="manualEditModeBtn">✏️ Manual Edit Mode</button>
                <button class="control-button primary" onclick="exportToOxygen()">📤 Export to Oxygen</button>
            </div>
        </div>
    </div>
    
    <!-- Image Generation Dialog -->
    <div id="imageGenDialog" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;" onclick="if(event.target === this) closeImageGenDialog()">
        <div style="background: white; border-radius: 12px; padding: 30px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;" onclick="event.stopPropagation()">
            <h2 style="margin: 0 0 20px 0; color: #333; display: flex; align-items: center;">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <circle cx="12" cy="12" r="10"></circle>
                    <path d="M12 2v20"></path>
                    <path d="M12 2a10 10 0 0 1 0 20"></path>
                </svg>
                Generate Image with AI
            </h2>
            
            <!-- Gallery Section for Previously Generated Images -->
            <div style="margin-bottom: 20px; border: 1px solid #e4e4e7; border-radius: 8px; padding: 15px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Choose from Gallery:</label>
                <div id="dialogMediaGallery" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; max-height: 150px; overflow-y: auto; padding: 10px 0;">
                    <!-- Gallery images will be loaded here -->
                </div>
                <p id="noGalleryImages" style="text-align: center; color: #999; font-size: 13px; margin: 10px 0; display: none;">No images in gallery yet</p>
            </div>
            
            <div style="text-align: center; margin: 15px 0;">
                <span style="color: #999; font-size: 13px;">— OR —</span>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Upload from computer:</label>
                <input type="file" id="imageInputFiles" multiple accept="image/*" onchange="handleImageSelection(this)" 
                    style="display: none;">
                <button onclick="document.getElementById('imageInputFiles').click()" 
                    style="padding: 10px 20px; background: #f0f0f0; border: 1px solid #e4e4e7; border-radius: 6px; cursor: pointer; margin-bottom: 10px;">
                    📁 Choose Images
                </button>
                <div id="selectedImagesPreview" style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px;"></div>
            </div>
            
            <div style="text-align: center; margin: 15px 0;">
                <span style="color: #999; font-size: 13px;">— OR —</span>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Describe the image you want:</label>
                <textarea id="imagePrompt" placeholder="E.g., A modern hero section background with abstract geometric shapes in purple and blue gradients" 
                    style="width: 100%; min-height: 100px; padding: 12px; border: 1px solid #e4e4e7; border-radius: 6px; font-size: 14px; resize: vertical;"></textarea>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Image Size:</label>
                <select id="imageSize" style="width: 100%; padding: 10px; border: 1px solid #e4e4e7; border-radius: 6px;">
                    <option value="1024x1024">Square (1024x1024)</option>
                    <option value="1792x1024">Landscape (1792x1024)</option>
                    <option value="1024x1792">Portrait (1024x1792)</option>
                </select>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Insert as:</label>
                <select id="imageInsertType" style="width: 100%; padding: 10px; border: 1px solid #e4e4e7; border-radius: 6px;">
                    <option value="img">Image Element (&lt;img&gt;)</option>
                    <option value="background">CSS Background</option>
                    <option value="hero">Hero Section with Image</option>
                </select>
            </div>
            
            <div id="imageGenLoading" style="display: none; text-align: center; padding: 20px;">
                <div style="display: inline-block; width: 40px; height: 40px; border: 3px solid #e4e4e7; border-top-color: #09090b; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                <p style="margin-top: 16px; color: #71717a; font-size: 14px;">Generating your image...</p>
            </div>
            
            <div id="imageGenResult" style="display: none; margin: 20px 0;">
                <img id="generatedImagePreview" style="max-width: 100%; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);" />
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                <button onclick="closeImageGenDialog()" style="padding: 10px 20px; background: #f0f0f0; border: none; border-radius: 6px; cursor: pointer;">Cancel</button>
                <button onclick="generateImage()" id="generateImageButton" style="padding: 10px 20px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">Generate Image</button>
                <button onclick="insertGeneratedImage()" id="insertImageButton" style="display: none; padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">Insert Image</button>
            </div>
        </div>
    </div>
    
    <!-- Context Menu for Preview Elements -->
    <div id="contextMenu" style="display: none; position: absolute; background: white; border: 1px solid #e4e4e7; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 9999; min-width: 220px;">
        <div style="padding: 6px 0;">
            <!-- Quick Actions -->
            <div class="context-menu-item" id="editTextBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                </svg>
                Edit Text
            </div>
            <div class="context-menu-item" id="editStylesBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
                </svg>
                Quick Styles
            </div>
            <div class="context-menu-item" id="editPaddingBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                    <line x1="9" y1="3" x2="9" y2="21"></line>
                    <line x1="15" y1="3" x2="15" y2="21"></line>
                </svg>
                Adjust Spacing
            </div>
            <div class="context-menu-item" id="editSizeBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
                    <polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline>
                    <polyline points="7.5 19.79 7.5 14.6 3 12"></polyline>
                    <polyline points="21 12 16.5 14.6 16.5 19.79"></polyline>
                    <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
                    <line x1="12" y1="22.08" x2="12" y2="12"></line>
                </svg>
                Edit Size
            </div>
            
            <!-- Divider -->
            <div style="border-top: 1px solid #e4e4e7; margin: 4px 0;"></div>
            
            <!-- Layout Adjustments -->
            <div class="context-menu-item" id="alignLeftBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <line x1="17" y1="10" x2="3" y2="10"></line>
                    <line x1="21" y1="6" x2="3" y2="6"></line>
                    <line x1="21" y1="14" x2="3" y2="14"></line>
                    <line x1="17" y1="18" x2="3" y2="18"></line>
                </svg>
                Align Left
            </div>
            <div class="context-menu-item" id="alignCenterBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <line x1="18" y1="10" x2="6" y2="10"></line>
                    <line x1="21" y1="6" x2="3" y2="6"></line>
                    <line x1="21" y1="14" x2="3" y2="14"></line>
                    <line x1="18" y1="18" x2="6" y2="18"></line>
                </svg>
                Center
            </div>
            <div class="context-menu-item" id="alignRightBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <line x1="21" y1="10" x2="7" y2="10"></line>
                    <line x1="21" y1="6" x2="3" y2="6"></line>
                    <line x1="21" y1="14" x2="3" y2="14"></line>
                    <line x1="21" y1="18" x2="7" y2="18"></line>
                </svg>
                Align Right
            </div>
            
            <!-- Divider -->
            <div style="border-top: 1px solid #e4e4e7; margin: 4px 0;"></div>
            
            <!-- Reorder -->
            <div class="context-menu-item" id="moveUpBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <line x1="12" y1="19" x2="12" y2="5"></line>
                    <polyline points="5 12 12 5 19 12"></polyline>
                </svg>
                Move Up
            </div>
            <div class="context-menu-item" id="moveDownBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <polyline points="19 12 12 19 5 12"></polyline>
                </svg>
                Move Down
            </div>
            
            <!-- Divider -->
            <div style="border-top: 1px solid #e4e4e7; margin: 4px 0;"></div>
            
            <!-- Responsive -->
            <div class="context-menu-item" id="hideMobileBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect>
                    <line x1="12" y1="18" x2="12.01" y2="18"></line>
                </svg>
                Hide on Mobile
            </div>
            <div class="context-menu-item" id="hideDesktopBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
                    <line x1="8" y1="21" x2="16" y2="21"></line>
                    <line x1="12" y1="17" x2="12" y2="21"></line>
                </svg>
                Hide on Desktop
            </div>
            
            <!-- Divider -->
            <div style="border-top: 1px solid #e4e4e7; margin: 4px 0;"></div>
            
            <!-- Content Actions -->
            <div class="context-menu-item" id="editLinkOption" style="padding: 8px 16px; cursor: pointer; font-size: 13px; display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                </svg>
                Make Clickable
            </div>
            <div class="context-menu-item" id="replaceImageBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                    <circle cx="8.5" cy="8.5" r="1.5"></circle>
                    <polyline points="21 15 16 10 5 21"></polyline>
                </svg>
                Replace Image
            </div>
            <div class="context-menu-item" id="duplicateBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
                Duplicate
            </div>
            
            <!-- Divider -->
            <div style="border-top: 1px solid #e4e4e7; margin: 4px 0;"></div>
            
            <!-- AI Refinement -->
            <div class="context-menu-item" id="aiRefineBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; background: linear-gradient(90deg, #f0f0f0, #fafafa); display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                </svg>
                AI Refine This
            </div>
            <div class="context-menu-item" id="aiAlternativeBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; background: linear-gradient(90deg, #f0f0f0, #fafafa); display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <polyline points="23 4 23 10 17 10"></polyline>
                    <polyline points="1 20 1 14 7 14"></polyline>
                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                </svg>
                Generate Alternative
            </div>
            
            <!-- Divider -->
            <div style="border-top: 1px solid #e4e4e7; margin: 4px 0;"></div>
            
            <!-- Delete -->
            <div class="context-menu-item" id="deleteBtn" style="padding: 8px 16px; cursor: pointer; font-size: 13px; color: #dc3545; display: flex; align-items: center;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#dc3545" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                    <polyline points="3 6 5 6 21 6"></polyline>
                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                </svg>
                Delete
            </div>
        </div>
    </div>
    
    <!-- Property Editor Modal -->
    <div id="propertyEditor" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10001;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 12px; padding: 25px; width: 90%; max-width: 500px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
            <h3 id="editorTitle" style="margin-top: 0; color: #333; border-bottom: 2px solid #667eea; padding-bottom: 10px;">Edit Property</h3>
            <div id="editorContent" style="margin: 20px 0;">
                <!-- Dynamic content will be inserted here -->
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="cancelPropertyEdit()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer;">Cancel</button>
                <button onclick="applyPropertyEdit()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;">Apply</button>
            </div>
        </div>
    </div>
    
    <!-- Memory Dialog Modal -->
    <div id="memoryDialog" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.4); z-index: 10000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 8px; padding: 24px; width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.15); border: 1px solid #e4e4e7;">
            <h2 style="margin-top: 0; color: #09090b; border-bottom: 1px solid #e4e4e7; padding-bottom: 12px; font-size: 20px; font-weight: 600;">📜 Conversation History</h2>
            
            <div id="memoryStats" style="background: #fafafa; padding: 16px; border-radius: 6px; margin: 16px 0; border: 1px solid #e4e4e7;">
                <!-- Stats will be populated here -->
            </div>
            
            <div id="memoryList" style="max-height: 300px; overflow-y: auto; margin: 20px 0;">
                <!-- Memory items will be populated here -->
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                <button onclick="clearMemory()" style="padding: 8px 16px; background: white; color: #ef4444; border: 1px solid #e4e4e7; border-radius: 6px; cursor: pointer; font-size: 14px; transition: all 0.2s;" onmouseover="this.style.background='#fef2f2'; this.style.borderColor='#ef4444'" onmouseout="this.style.background='white'; this.style.borderColor='#e4e4e7'">Clear All Memory</button>
                <button onclick="closeMemoryDialog()" style="padding: 8px 16px; background: #09090b; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; transition: all 0.2s;" onmouseover="this.style.background='#27272a'" onmouseout="this.style.background='#09090b'">Close</button>
            </div>
        </div>
    </div>

    <script>
        let currentHTML = '';
        let currentCSS = '';
        let currentJS = '';
        let lastKnownGoodCSS = ''; // Backup for CSS recovery
        let lastKnownGoodJS = ''; // Backup for JS recovery
        let currentJSON = {};
        let conversationHistory = [];
        let conversationMemory = []; // Long-term memory storage
        let postId = 1;
        let currentMode = 'add'; // 'add', 'edit', 'reference', or 'plan'
        let selectedElement = null;
        let elementPickerActive = false;
        let referenceData = null; // Store fetched reference data
        let contextMenuTarget = null; // Store the element being edited via context menu
        let originalElementState = null; // Store original state for undo
        let isPlanMode = false; // Track if we're in planning phase
        let isEditMode = false; // Track if edit mode is active
        let plannedTasks = []; // Store planned tasks
        let currentTaskIndex = 0; // Track current task being worked on
        
        // Composable chat window management
        let chatWindowElement = null;
        let chatWindowOriginalParent = null;
        let chatWindowIsFloating = false;
        
        function createChatWindow() {
            // Return existing chat window if already created
            if (chatWindowElement) {
                return chatWindowElement;
            }
            
            // Get the existing chat panel from DOM
            chatWindowElement = document.querySelector('.chat-panel');
            if (chatWindowElement) {
                chatWindowOriginalParent = chatWindowElement.parentElement;
                return chatWindowElement;
            }
            
            // If somehow it doesn't exist, return null (shouldn't happen)
            console.log('Chat panel not found!');
            return null;
        }
        
        function attachChatToFullscreen(fullscreenContainer) {
            const chatWindow = createChatWindow();
            if (!chatWindow) {
                console.log('No chat window found to attach');
                return;
            }
            
            console.log('Attaching chat to fullscreen, chat window:', chatWindow);
            
            // Store original parent if not already stored
            if (!chatWindowOriginalParent) {
                chatWindowOriginalParent = chatWindow.parentElement;
            }
            
            // Create floating wrapper (minimal, just for positioning)
            const floatingWrapper = document.createElement('div');
            floatingWrapper.id = 'floatingChatWrapper';
            floatingWrapper.style.cssText = `
                position: fixed;
                left: 20px;
                top: 80px;
                bottom: 20px;
                width: 400px;
                z-index: 100000;
                display: none;
                resize: horizontal;
                min-width: 300px;
                max-width: 600px;
            `;
            
            // Move chat window directly to floating wrapper
            floatingWrapper.appendChild(chatWindow);
            fullscreenContainer.appendChild(floatingWrapper);
            
            // Apply floating styles to chat window
            chatWindow.style.height = '100%';
            chatWindow.style.display = 'flex';
            chatWindow.style.flexDirection = 'column';
            chatWindow.style.background = 'white';
            chatWindow.style.borderRadius = '12px';
            chatWindow.style.boxShadow = '0 10px 40px rgba(0,0,0,0.2)';
            chatWindow.style.overflow = 'hidden';
            
            // Add close button to existing chat header
            const chatHeader = chatWindow.querySelector('.chat-header');
            if (chatHeader && !chatHeader.querySelector('.fullscreen-close-btn')) {
                const closeBtn = document.createElement('button');
                closeBtn.className = 'fullscreen-close-btn settings-toggle';
                closeBtn.onclick = toggleFullscreenChat;
                closeBtn.style.cssText = `
                    margin-left: 8px;
                `;
                closeBtn.title = 'Close Chat';
                closeBtn.innerHTML = `
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                `;
                chatHeader.appendChild(closeBtn);
                
                // Make the header draggable
                chatHeader.style.cursor = 'move';
                makeDraggable(floatingWrapper, chatHeader);
            }
            
            // Mark as floating
            chatWindowIsFloating = true;
            chatWindow.dataset.floating = 'true';
            
            console.log('Floating wrapper created and attached:', document.getElementById('floatingChatWrapper'));
        }
        
        function restoreChatToOriginal() {
            const chatWindow = chatWindowElement;
            if (!chatWindow || !chatWindowOriginalParent) return;
            
            // Remove from floating wrapper
            const floatingWrapper = document.getElementById('floatingChatWrapper');
            if (floatingWrapper) {
                floatingWrapper.remove();
            }
            
            // Restore original styles
            chatWindow.style.height = '';
            chatWindow.style.display = '';
            chatWindow.style.flexDirection = '';
            chatWindow.style.background = '';
            chatWindow.style.borderRadius = '';
            chatWindow.style.boxShadow = '';
            chatWindow.style.overflow = '';
            
            // Remove the close button we added
            const closeBtn = chatWindow.querySelector('.fullscreen-close-btn');
            if (closeBtn) {
                closeBtn.remove();
            }
            
            // Restore header cursor
            const chatHeader = chatWindow.querySelector('.chat-header');
            if (chatHeader) {
                chatHeader.style.cursor = '';
            }
            
            // Move back to original parent at the beginning (left side)
            // Use prepend to ensure it goes to the beginning, maintaining left position
            chatWindowOriginalParent.prepend(chatWindow);
            
            // Mark as not floating
            chatWindowIsFloating = false;
            delete chatWindow.dataset.floating;
        }
        
        function makeDraggable(element, handle) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
            handle.onmousedown = dragMouseDown;
            
            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }
            
            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }
        
        // Memory management constants
        const MAX_MEMORY_ITEMS = 50; // Maximum number of memory items to store
        const MEMORY_STORAGE_KEY = 'vibecoder_memory';
        const CONVERSATION_STORAGE_KEY = 'vibecoder_conversation';
        
        // Multimodal models that support image input
        const multimodalModels = [
            'anthropic/claude-3.5-sonnet',
            'anthropic/claude-sonnet-4', 
            'anthropic/claude-3-opus',
            'anthropic/claude-3-sonnet',
            'anthropic/claude-3-haiku',
            'google/gemini-2.5-pro',
            'google/gemini-2.5-flash',
            'google/gemini-pro-1.5',
            'google/gemini-pro',
            'openai/gpt-4o',
            'openai/gpt-4-turbo',
            'openai/gpt-5'
        ];

        // Hide context menu when clicking outside
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('contextMenu');
            if (!menu.contains(e.target)) {
                hideContextMenu();
            }
        });
        
        // Hardcoded model context lengths for performance
        const modelContextLengths = {
            'x-ai/grok-code-fast-1': 128000,
            'openai/gpt-5': 200000,
            'x-ai/grok-4': 128000,
            'google/gemini-2.5-flash': 1000000,
            'google/gemini-2.5-pro': 2000000,
            'anthropic/claude-sonnet-4': 200000,
            'google/gemini-2.5-flash-image-preview': 1000000
        };
        
        
        function getModelContextLength(modelId) {
            return modelContextLengths[modelId] || 128000; // Default to 128K if not found
        }
        
        // Load saved API key and memory on startup
        window.onload = function() {
            // Clean up any existing edit mode indicators on page load
            const previewFrame = document.getElementById('previewFrame');
            if (previewFrame && previewFrame.contentDocument) {
                const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
                const existingIndicator = iframeDoc.getElementById('editModeIndicator');
                if (existingIndicator) {
                    existingIndicator.remove();
                    console.log('Removed existing edit mode indicator on page load');
                }
            }
            
            // Ensure edit mode is off on page load
            isEditMode = false;
            
            const savedKey = localStorage.getItem('openrouter_api_key');
            const savedModel = localStorage.getItem('openrouter_model');
            const savedVisionModel = localStorage.getItem('openrouter_vision_model');
            const savedImageGenModel = localStorage.getItem('openrouter_image_gen_model');
            const savedSystemPrompt = localStorage.getItem('vibe_system_prompt');
            const savedBrandGuidelines = localStorage.getItem('vibe_brand_guidelines');
            const savedImagePromptTemplate = localStorage.getItem('vibe_image_prompt_template');
            const savedAutoGenerate = localStorage.getItem('vibe_auto_generate_images');
            
            if (savedKey) {
                document.getElementById('apiKey').value = savedKey;
            }
            if (savedModel) {
                document.getElementById('modelSelect').value = savedModel;
                checkMultimodalSupport(savedModel);
            }
            if (savedVisionModel) {
                document.getElementById('visionModelSelect').value = savedVisionModel;
            }
            // Screenshot button is always visible in the chat input area
            
            // Image generation button is now in the media panel
            if (savedSystemPrompt) {
                document.getElementById('systemPrompt').value = savedSystemPrompt;
            }
            if (savedBrandGuidelines) {
                document.getElementById('brandGuidelines').value = savedBrandGuidelines;
            }
            if (savedImagePromptTemplate) {
                document.getElementById('imagePromptTemplate').value = savedImagePromptTemplate;
            }
            
            // Load auto-generate images checkbox state
            if (savedAutoGenerate !== null) {
                const autoGenCheckbox = document.getElementById('autoGenerateImages');
                if (autoGenCheckbox) {
                    autoGenCheckbox.checked = savedAutoGenerate === 'true';
                }
            }
            
            // Add event listener to save checkbox state when changed
            const autoGenCheckbox = document.getElementById('autoGenerateImages');
            if (autoGenCheckbox) {
                autoGenCheckbox.addEventListener('change', function() {
                    localStorage.setItem('vibe_auto_generate_images', this.checked.toString());
                });
            }
            
            // Load conversation memory
            loadMemory();
            
            // Load last conversation if exists
            loadLastConversation();
            
            // Load suggestions
            loadSuggestions();
            
            // Load generated images
            loadGeneratedImages();
            
            // Initialize context menu event listeners
            initializeContextMenuListeners();
            
            // Apply collapsed state for suggestions
            const isCollapsed = localStorage.getItem('vibe_suggestions_collapsed') === 'true';
            if (isCollapsed) {
                const container = document.getElementById('promptSuggestions');
                if (container) {
                    container.classList.add('collapsed');
                    const toggleBtn = container.querySelector('.suggestions-toggle svg');
                    if (toggleBtn) {
                        toggleBtn.style.transform = 'rotate(-90deg)';
                    }
                }
            }
            
            updatePreview();
        };

        // Memory Management Functions
        function loadMemory() {
            try {
                const saved = localStorage.getItem(MEMORY_STORAGE_KEY);
                if (saved) {
                    conversationMemory = JSON.parse(saved);
                    console.log(`Loaded ${conversationMemory.length} memory items`);
                }
            } catch (e) {
                console.error('Error loading memory:', e);
                conversationMemory = [];
            }
        }
        
        function saveMemory() {
            try {
                // Keep only the most recent items
                if (conversationMemory.length > MAX_MEMORY_ITEMS) {
                    conversationMemory = conversationMemory.slice(-MAX_MEMORY_ITEMS);
                }
                localStorage.setItem(MEMORY_STORAGE_KEY, JSON.stringify(conversationMemory));
                console.log(`Saved ${conversationMemory.length} memory items`);
            } catch (e) {
                console.error('Error saving memory:', e);
            }
        }
        
        function addToMemory(input, response, context = {}) {
            const memoryItem = {
                timestamp: new Date().toISOString(),
                input: input,
                response: response.substring(0, 500), // Store truncated response
                mode: currentMode,
                context: {
                    hasHTML: !!currentHTML,
                    hasCSS: !!currentCSS,
                    hasJS: !!currentJS,
                    url: context.url || null
                },
                // Store code snapshot for version history
                codeSnapshot: {
                    html: currentHTML,
                    css: currentCSS,
                    js: currentJS
                }
            };
            
            conversationMemory.push(memoryItem);
            
            // Limit memory to last 50 items to prevent excessive storage
            if (conversationMemory.length > 50) {
                conversationMemory = conversationMemory.slice(-50);
            }
            
            saveMemory();
        }
        
        function loadLastConversation() {
            try {
                const saved = localStorage.getItem(CONVERSATION_STORAGE_KEY);
                if (saved) {
                    const data = JSON.parse(saved);
                    currentHTML = data.html || '';
                    currentCSS = data.css || '';
                    conversationHistory = data.history || [];
                    
                    // Update editors
                    if (currentHTML || currentCSS) {
                        document.getElementById('htmlEditor').value = currentHTML;
                        document.getElementById('cssEditor').value = currentCSS;
                        updatePreview();
                        generateOxygenJSON();
                        
                        showToast('💾 Restored your last session. Continue where you left off!', 3000);
                    }
                }
            } catch (e) {
                console.error('Error loading last conversation:', e);
            }
        }
        
        function saveCurrentConversation() {
            try {
                const data = {
                    html: currentHTML,
                    css: currentCSS,
                    history: conversationHistory.slice(-10), // Keep last 10 messages
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem(CONVERSATION_STORAGE_KEY, JSON.stringify(data));
            } catch (e) {
                console.error('Error saving conversation:', e);
            }
        }
        
        function getMemoryContext() {
            // Get relevant memory for context
            if (conversationMemory.length === 0) return '';
            
            // Get recent relevant memories
            const recentMemories = conversationMemory.slice(-5);
            let context = '\n\n[MEMORY CONTEXT]\n';
            context += 'Recent work in this session:\n';
            
            recentMemories.forEach((mem, idx) => {
                const date = new Date(mem.timestamp);
                const timeAgo = getTimeAgo(date);
                context += `${idx + 1}. ${timeAgo}: User asked about "${mem.input.substring(0, 50)}..." in ${mem.mode} mode\n`;
            });
            
            return context;
        }
        
        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            let interval = seconds / 31536000;
            if (interval > 1) return Math.floor(interval) + " years ago";
            
            interval = seconds / 2592000;
            if (interval > 1) return Math.floor(interval) + " months ago";
            
            interval = seconds / 86400;
            if (interval > 1) return Math.floor(interval) + " days ago";
            
            interval = seconds / 3600;
            if (interval > 1) return Math.floor(interval) + " hours ago";
            
            interval = seconds / 60;
            if (interval > 1) return Math.floor(interval) + " minutes ago";
            
            return "Just now";
        }
        
        function clearMemory() {
            if (confirm('Are you sure you want to clear all conversation memory? This cannot be undone.')) {
                conversationMemory = [];
                conversationHistory = [];
                localStorage.removeItem(MEMORY_STORAGE_KEY);
                localStorage.removeItem(CONVERSATION_STORAGE_KEY);
                showMessage('assistant', '🧹 Memory cleared. Starting fresh!');
                closeMemoryDialog();
            }
        }
        
        function showMemoryDialog() {
            const dialog = document.getElementById('memoryDialog');
            const statDiv = document.getElementById('memoryStats');
            const listDiv = document.getElementById('memoryList');
            
            // Show stats
            const totalMemory = conversationMemory.length;
            const todayMemory = conversationMemory.filter(m => {
                const date = new Date(m.timestamp);
                const today = new Date();
                return date.toDateString() === today.toDateString();
            }).length;
            
            statDiv.innerHTML = `
                <div style="display: flex; justify-content: space-around;">
                    <div style="text-align: center;">
                        <div style="font-size: 24px; font-weight: 600; color: #09090b;">${totalMemory}</div>
                        <div style="font-size: 12px; color: #71717a;">Total Memories</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 24px; font-weight: 600; color: #09090b;">${todayMemory}</div>
                        <div style="font-size: 12px; color: #71717a;">Today's Sessions</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 24px; font-weight: 600; color: #09090b;">${conversationHistory.length}</div>
                        <div style="font-size: 12px; color: #71717a;">Current Chat</div>
                    </div>
                </div>
            `;
            
            // Show memory list
            if (conversationMemory.length === 0) {
                listDiv.innerHTML = '<p style="text-align: center; color: #999;">No memories yet. Start creating!</p>';
            } else {
                const memories = conversationMemory.slice().reverse(); // Show newest first
                listDiv.innerHTML = memories.slice(0, 20).map((mem, index) => {
                    const date = new Date(mem.timestamp);
                    const timeAgo = getTimeAgo(date);
                    const modeIcon = mem.mode === 'add' ? 
                        '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>' : 
                        (mem.mode === 'edit' ? 
                        '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>' : 
                        '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>');
                    const memIndex = conversationMemory.length - 1 - index; // Get actual index in array
                    
                    // Check if this version has code
                    const hasCode = mem.codeSnapshot && (mem.codeSnapshot.html || mem.codeSnapshot.css || mem.codeSnapshot.js);
                    
                    return `
                        <div style="background: #fafafa; padding: 12px; margin: 8px 0; border-radius: 6px; border: 1px solid #e4e4e7;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span style="font-weight: 500; color: #09090b;">${modeIcon} ${mem.mode.toUpperCase()} Mode</span>
                                <span style="font-size: 12px; color: #a1a1aa;">${timeAgo}</span>
                            </div>
                            <div style="font-size: 14px; color: #71717a; margin-bottom: 5px;">
                                <strong>Q:</strong> ${mem.input.substring(0, 100)}${mem.input.length > 100 ? '...' : ''}
                            </div>
                            <div style="font-size: 13px; color: #71717a; margin-bottom: 8px;">
                                <strong>A:</strong> ${mem.response.substring(0, 150)}${mem.response.length > 150 ? '...' : ''}
                            </div>
                            ${hasCode ? `
                                <div style="display: flex; gap: 8px; margin-top: 8px;">
                                    <button onclick="restoreCodeVersion(${memIndex})" style="background: #09090b; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#27272a'" onmouseout="this.style.background='#09090b'">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 4px; display: inline-block; vertical-align: middle;">
                                            <polyline points="23 4 23 10 17 10"></polyline>
                                            <polyline points="1 20 1 14 7 14"></polyline>
                                            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                                        </svg>
                                        Restore
                                    </button>
                                    <button onclick="previewVersion(${memIndex})" style="background: white; color: #09090b; border: 1px solid #e4e4e7; padding: 6px 12px; border-radius: 4px; font-size: 12px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#f4f4f5'" onmouseout="this.style.background='white'">
                                        👁️ Preview
                                    </button>
                                </div>
                            ` : '<div style="font-size: 11px; color: #a1a1aa; font-style: italic;">No code snapshot available</div>'}
                        </div>
                    `;
                }).join('');
            }
            
            dialog.style.display = 'block';
        }
        
        function closeMemoryDialog() {
            document.getElementById('memoryDialog').style.display = 'none';
        }
        
        function restoreCodeVersion(index) {
            const memory = conversationMemory[index];
            if (!memory || !memory.codeSnapshot) {
                alert('No code snapshot available for this version');
                return;
            }
            
            if (confirm(`Restore code from "${memory.input.substring(0, 50)}..."?\n\nThis will replace your current code.`)) {
                // Restore the code
                currentHTML = memory.codeSnapshot.html || '';
                currentCSS = memory.codeSnapshot.css || '';
                currentJS = memory.codeSnapshot.js || '';
                
                // Update editors
                document.getElementById('htmlEditor').value = currentHTML;
                document.getElementById('cssEditor').value = currentCSS;
                document.getElementById('jsEditor').value = currentJS;
                
                // Update preview
                updatePreview();
                generateOxygenJSON();
                
                // Close dialog and show success message
                closeMemoryDialog();
                showToast(`✅ Restored code version from ${getTimeAgo(new Date(memory.timestamp))}`, 3000);
            }
        }
        
        function previewVersion(index) {
            const memory = conversationMemory[index];
            if (!memory || !memory.codeSnapshot) {
                alert('No code snapshot available for this version');
                return;
            }
            
            // Create a modal to show the rendered preview
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.4);
                z-index: 10002;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                border-radius: 8px;
                max-width: 1200px;
                max-height: 90vh;
                width: 90%;
                overflow: hidden;
                border: 1px solid #e4e4e7;
                box-shadow: 0 10px 40px rgba(0,0,0,0.15);
                display: flex;
                flex-direction: column;
            `;
            
            content.innerHTML = `
                <div style="padding: 16px 20px; border-bottom: 1px solid #e4e4e7; background: #fafafa;">
                    <h3 style="margin: 0; color: #09090b; font-size: 18px; font-weight: 600;">Preview - ${getTimeAgo(new Date(memory.timestamp))}</h3>
                    <p style="margin: 4px 0 0 0; color: #71717a; font-size: 14px;">${memory.input.substring(0, 100)}...</p>
                </div>
                <div style="flex: 1; background: #fafafa; padding: 20px; display: flex; align-items: center; justify-content: center;">
                    <iframe id="memoryPreviewFrame" style="width: 100%; height: 500px; max-width: 1024px; border: 1px solid #e4e4e7; border-radius: 6px; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"></iframe>
                </div>
                <div style="padding: 16px 20px; border-top: 1px solid #e4e4e7; display: flex; gap: 8px; justify-content: flex-end; background: white;">
                    <button id="previewCloseBtn" style="padding: 8px 16px; background: white; color: #09090b; border: 1px solid #e4e4e7; border-radius: 6px; cursor: pointer; font-size: 14px; transition: all 0.2s;">Close</button>
                    <button id="previewRestoreBtn" style="padding: 8px 16px; background: #09090b; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; transition: all 0.2s;">Restore This Version</button>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Add event listeners for buttons
            const closeBtn = document.getElementById('previewCloseBtn');
            const restoreBtn = document.getElementById('previewRestoreBtn');
            
            if (closeBtn) {
                closeBtn.addEventListener('click', () => modal.remove());
                closeBtn.addEventListener('mouseover', () => closeBtn.style.background = '#fafafa');
                closeBtn.addEventListener('mouseout', () => closeBtn.style.background = 'white');
            }
            
            if (restoreBtn) {
                restoreBtn.addEventListener('click', () => {
                    restoreCodeVersion(index);
                    modal.remove();
                });
                restoreBtn.addEventListener('mouseover', () => restoreBtn.style.background = '#27272a');
                restoreBtn.addEventListener('mouseout', () => restoreBtn.style.background = '#09090b');
            }
            
            // Load the preview content into the iframe
            setTimeout(() => {
                const iframe = document.getElementById('memoryPreviewFrame');
                if (iframe) {
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    const fullHTML = `
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <meta charset="UTF-8">
                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
                            <style>${memory.codeSnapshot.css || ''}</style>
                        </head>
                        <body>
                            ${memory.codeSnapshot.html || ''}
                            <script>${memory.codeSnapshot.js || ''}<\/script>
                        </body>
                        </html>
                    `;
                    iframeDoc.open();
                    iframeDoc.write(fullHTML);
                    iframeDoc.close();
                }
            }, 100);
            
            // Close on backdrop click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function toggleSettings() {
            const settingsPanel = document.getElementById('settingsPanel');
            const mediaPanel = document.getElementById('mediaPanel');
            const isVisible = settingsPanel.style.display !== 'none';
            
            // Hide media panel if open
            mediaPanel.style.display = 'none';
            
            if (isVisible) {
                settingsPanel.style.display = 'none';
            } else {
                settingsPanel.style.display = 'block';
                // Focus on API key input if empty
                const apiKeyInput = document.getElementById('apiKey');
                if (!apiKeyInput.value) {
                    apiKeyInput.focus();
                }
            }
        }
        
        function toggleMedia() {
            const mediaPanel = document.getElementById('mediaPanel');
            const settingsPanel = document.getElementById('settingsPanel');
            const isVisible = mediaPanel.style.display !== 'none';
            
            // Hide settings panel if open
            settingsPanel.style.display = 'none';
            
            if (isVisible) {
                mediaPanel.style.display = 'none';
            } else {
                mediaPanel.style.display = 'block';
                updateMediaGallery();
            }
        }
        
        let generatedImages = [];
        
        function updateMediaGallery() {
            const gallery = document.getElementById('mediaGallery');
            const noMediaMessage = document.getElementById('noMediaMessage');
            
            if (generatedImages.length === 0) {
                gallery.style.display = 'none';
                noMediaMessage.style.display = 'block';
            } else {
                gallery.style.display = 'grid';
                noMediaMessage.style.display = 'none';
                
                gallery.innerHTML = generatedImages.map((img, index) => `
                    <div style="position: relative; border: 1px solid #e4e4e7; border-radius: 6px; overflow: hidden; background: white;">
                        <img src="${img.url}" alt="${img.prompt}" style="width: 100%; height: 150px; object-fit: cover; cursor: pointer;" onclick="viewGeneratedImage(${index})" title="Click to view">
                        <div style="padding: 8px;">
                            <p style="margin: 0; font-size: 11px; color: #71717a; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${img.prompt}">${img.prompt}</p>
                            <div style="display: flex; gap: 4px; margin-top: 8px;">
                                <button onclick="insertGeneratedImage(${index})" style="flex: 1; padding: 4px; font-size: 11px; background: #09090b; color: white; border: none; border-radius: 4px; cursor: pointer;" title="Insert into design">Insert</button>
                                <button onclick="deleteGeneratedImage(${index})" style="padding: 4px 8px; font-size: 11px; background: white; color: #ef4444; border: 1px solid #ef4444; border-radius: 4px; cursor: pointer;" title="Delete">🗑</button>
                            </div>
                        </div>
                    </div>
                `).join('');
            }
        }
        
        async function saveGeneratedImage(url, prompt) {
            try {
                // Compress image before storing if it's base64
                let compressedUrl = url;
                if (url.startsWith('data:image')) {
                    // Compress to smaller size for storage
                    compressedUrl = await compressAndResizeImage(url, 512, 512, 0.7);
                }
                
                generatedImages.push({
                    url: compressedUrl,
                    prompt: prompt,
                    timestamp: new Date().toISOString()
                });
                
                // Limit to last 20 images to prevent quota issues
                if (generatedImages.length > 20) {
                    generatedImages = generatedImages.slice(-20);
                    console.log('Limited gallery to last 20 images to prevent storage quota issues');
                }
                
                try {
                    localStorage.setItem('vibe_generated_images', JSON.stringify(generatedImages));
                } catch (e) {
                    if (e.name === 'QuotaExceededError') {
                        // If still exceeding quota, keep only last 10 images
                        console.warn('Storage quota exceeded, reducing to last 10 images');
                        generatedImages = generatedImages.slice(-10);
                        
                        // Try again with fewer images
                        try {
                            localStorage.setItem('vibe_generated_images', JSON.stringify(generatedImages));
                        } catch (e2) {
                            // If still failing, store only URLs without base64 data
                            console.error('Storage quota still exceeded, clearing image gallery');
                            generatedImages = [];
                            localStorage.removeItem('vibe_generated_images');
                            showToast('⚠️ Storage full - Image gallery cleared', 3000);
                        }
                    }
                }
            } catch (error) {
                console.error('Error saving image:', error);
                // Don't block image generation if storage fails
            }
        }
        
        function loadGeneratedImages() {
            try {
                const saved = localStorage.getItem('vibe_generated_images');
                if (saved) {
                    generatedImages = JSON.parse(saved);
                    
                    // Clean up any corrupted entries
                    generatedImages = generatedImages.filter(img => img && img.url);
                }
            } catch (e) {
                console.error('Error loading generated images:', e);
                generatedImages = [];
                localStorage.removeItem('vibe_generated_images');
            }
        }
        
        function deleteGeneratedImage(index) {
            if (confirm('Delete this image from the gallery?')) {
                generatedImages.splice(index, 1);
                try {
                    localStorage.setItem('vibe_generated_images', JSON.stringify(generatedImages));
                } catch (e) {
                    console.error('Error updating storage after delete:', e);
                }
                updateMediaGallery();
            }
        }
        
        function viewGeneratedImage(index) {
            const img = generatedImages[index];
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                z-index: 10002;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 8px; max-width: 90%; max-height: 90%; overflow: hidden; border: 1px solid #e4e4e7;">
                    <div style="padding: 16px; border-bottom: 1px solid #e4e4e7;">
                        <p style="margin: 0; color: #09090b; font-size: 14px;">${img.prompt}</p>
                    </div>
                    <img src="${img.url}" style="max-width: 100%; max-height: calc(90vh - 100px); object-fit: contain; display: block;">
                    <div style="padding: 16px; border-top: 1px solid #e4e4e7; display: flex; gap: 8px; justify-content: flex-end;">
                        <button onclick="this.closest('div[style*=\\"position: fixed\\"]').remove()" style="padding: 8px 16px; background: white; color: #09090b; border: 1px solid #e4e4e7; border-radius: 6px; cursor: pointer;">Close</button>
                        <button onclick="insertGeneratedImage(${index}); this.closest('div[style*=\\"position: fixed\\"]').remove()" style="padding: 8px 16px; background: #09090b; color: white; border: none; border-radius: 6px; cursor: pointer;">Insert into Design</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        function insertGeneratedImage(index) {
            const img = generatedImages[index];
            const selectedEl = selectedElement || document.querySelector('#preview-content');
            
            if (selectedEl) {
                const imgElement = document.createElement('img');
                imgElement.src = img.url;
                imgElement.alt = img.prompt;
                imgElement.style.width = '100%';
                imgElement.style.height = 'auto';
                imgElement.style.borderRadius = '8px';
                
                if (selectedEl.id === 'preview-content') {
                    selectedEl.appendChild(imgElement);
                } else {
                    selectedEl.innerHTML = '';
                    selectedEl.appendChild(imgElement);
                }
                
                updatePreview();
                generateOxygenJSON();
                showToast('✅ Image inserted successfully!', 2000);
            } else {
                showToast('⚠️ Please select an element first', 2000);
            }
        }

        function saveConfig() {
            const apiKey = document.getElementById('apiKey').value;
            const model = document.getElementById('modelSelect').value;
            const visionModel = document.getElementById('visionModelSelect').value;
            const imageGenModel = document.getElementById('imageGenModelSelect').value;
            const systemPrompt = document.getElementById('systemPrompt').value;
            const brandGuidelines = document.getElementById('brandGuidelines').value;
            const imagePromptTemplate = document.getElementById('imagePromptTemplate').value;
            
            if (!apiKey) {
                alert('Please enter your OpenRouter API key');
                return;
            }
            
            localStorage.setItem('openrouter_api_key', apiKey);
            localStorage.setItem('openrouter_model', model);
            localStorage.setItem('openrouter_vision_model', visionModel);
            localStorage.setItem('openrouter_image_gen_model', imageGenModel);
            localStorage.setItem('vibe_system_prompt', systemPrompt);
            localStorage.setItem('vibe_brand_guidelines', brandGuidelines);
            localStorage.setItem('vibe_image_prompt_template', imagePromptTemplate);
            
            checkMultimodalSupport(model);
            
            // Screenshot feature available when vision model is selected
            
            // Image generation button is now in the media panel
            
            // Hide settings panel after saving
            document.getElementById('settingsPanel').style.display = 'none';
            
            showToast('✅ Settings saved! Your system prompt and brand guidelines will be applied to all conversations.', 3000);
        }
        
        function getSystemPromptWithBrandGuidelines() {
            const customSystemPrompt = document.getElementById('systemPrompt')?.value || 
                'You are an expert web developer specializing in creating beautiful, modern web components.';
            const brandGuidelines = document.getElementById('brandGuidelines')?.value;
            
            let prompt = customSystemPrompt;
            
            if (brandGuidelines && brandGuidelines.trim()) {
                prompt += `\n\nBRAND GUIDELINES:\n${brandGuidelines}\n\nIMPORTANT: Apply these brand guidelines to all designs and components you create.`;
            }
            
            return prompt;
        }
        
        function checkMultimodalSupport(model) {
            if (multimodalModels.includes(model)) {
                console.log('Multimodal model detected - screenshot feature enabled');
            } else {
                console.log('Text-only model - screenshot feature disabled');
            }
        }
        
        // Add event listener for model selection changes
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('modelSelect').addEventListener('change', function() {
                checkMultimodalSupport(this.value);
            });
        });

        function showMessage(role, content) {
            const messagesDiv = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'message-label';
            labelDiv.textContent = role === 'user' ? 'You' : 'AI Assistant';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = content;
            
            messageDiv.appendChild(labelDiv);
            messageDiv.appendChild(contentDiv);
            messagesDiv.appendChild(messageDiv);
            
            // Scroll to bottom
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function extractCSSContext(css) {
            if (!css) return { classes: [], variables: [], summary: '' };
            
            // Extract class names
            const classNames = [...css.matchAll(/\.([a-zA-Z0-9_-]+)/g)].map(m => m[1]);
            const uniqueClasses = [...new Set(classNames)];
            
            // Extract CSS variables
            const cssVars = [...css.matchAll(/--([a-zA-Z0-9_-]+)/g)].map(m => `--${m[1]}`);
            const uniqueVars = [...new Set(cssVars)];
            
            // Analyze common patterns
            const hasGrid = css.includes('display: grid') || css.includes('display:grid');
            const hasFlex = css.includes('display: flex') || css.includes('display:flex');
            const hasAnimations = css.includes('@keyframes');
            const hasMediaQueries = css.includes('@media');
            
            let summary = 'Design system includes: ';
            const features = [];
            if (hasGrid) features.push('Grid layouts');
            if (hasFlex) features.push('Flexbox layouts');
            if (hasAnimations) features.push('Animations');
            if (hasMediaQueries) features.push('Responsive design');
            if (uniqueVars.length > 0) features.push('CSS variables');
            
            summary += features.join(', ') || 'Basic styles';
            
            return {
                classes: uniqueClasses,
                variables: uniqueVars,
                summary: summary
            };
        }
        
        function extractPlanTasks(response) {
            // Extract numbered tasks from the AI response
            // Try multiple patterns to catch different formatting styles
            plannedTasks = [];
            
            // Pattern 1: Look for "Task Breakdown" or similar section
            const taskSectionRegex = /(?:task\s+breakdown|tasks?|step-by-step|implementation\s+steps?)[\s\S]*?(\d+\.[\s\S]+?)(?=\n\n|\n#|$)/gi;
            const taskSection = response.match(taskSectionRegex);
            
            let textToSearch = response;
            if (taskSection && taskSection[0]) {
                textToSearch = taskSection[0];
                console.log('Found task section:', textToSearch);
            }
            
            // Pattern 2: Extract numbered items (handles markdown and plain text)
            // This regex captures numbered lists with various formatting
            const patterns = [
                /^\d+\.\s+\*\*(.+?)\*\*:?\s*(.+?)(?=\n\d+\.|\n\n|$)/gm,  // **Bold** format
                /^\d+\.\s+(.+?)(?:\n|$)/gm,  // Simple numbered format
                /^[\*\-]\s+\*\*(.+?)\*\*:?\s*(.+?)(?=\n[\*\-]|\n\n|$)/gm,  // Bullet with bold
                /^[\*\-]\s+(.+?)(?:\n|$)/gm  // Simple bullet format
            ];
            
            for (const pattern of patterns) {
                const matches = [...textToSearch.matchAll(pattern)];
                
                for (const match of matches) {
                    let taskDescription = '';
                    
                    // Combine captured groups based on what was matched
                    if (match[2]) {
                        // Format with title and description
                        taskDescription = match[1] + ': ' + match[2];
                    } else {
                        // Simple format
                        taskDescription = match[1];
                    }
                    
                    // Clean up the task description
                    taskDescription = taskDescription
                        .replace(/\*\*/g, '')  // Remove markdown bold
                        .replace(/^[\*\-]\s+/, '')  // Remove bullet points
                        .replace(/^\d+\.\s+/, '')  // Remove numbers
                        .trim();
                    
                    // Filter out section headers and non-actionable items
                    if (taskDescription.length > 10 && 
                        !taskDescription.toLowerCase().includes('understanding') &&
                        !taskDescription.toLowerCase().includes('overview') &&
                        !taskDescription.toLowerCase().includes('summary') &&
                        !taskDescription.endsWith(':') &&
                        taskDescription.split(' ').length > 2) {  // At least 3 words
                        
                        // Check if this task is already in the list (avoid duplicates)
                        const isDuplicate = plannedTasks.some(t => 
                            t.description.toLowerCase().includes(taskDescription.toLowerCase()) ||
                            taskDescription.toLowerCase().includes(t.description.toLowerCase())
                        );
                        
                        if (!isDuplicate) {
                            plannedTasks.push({
                                description: taskDescription,
                                completed: false
                            });
                        }
                    }
                }
                
                // If we found tasks, stop trying other patterns
                if (plannedTasks.length > 0) {
                    break;
                }
            }
            
            // If still no tasks found, try to extract any line that starts with an action verb
            if (plannedTasks.length === 0) {
                const actionVerbs = ['create', 'build', 'add', 'implement', 'design', 'develop', 'set up', 'configure', 'integrate', 'update', 'modify', 'enhance', 'optimize'];
                const lines = response.split('\n');
                
                for (const line of lines) {
                    const cleanLine = line.trim().replace(/^[\*\-\d\.]\s+/, '').replace(/\*\*/g, '');
                    const lowerLine = cleanLine.toLowerCase();
                    
                    if (actionVerbs.some(verb => lowerLine.startsWith(verb)) && cleanLine.length > 15) {
                        plannedTasks.push({
                            description: cleanLine,
                            completed: false
                        });
                    }
                }
            }
            
            console.log('Extracted tasks:', plannedTasks);
            console.log('Total tasks found:', plannedTasks.length);
        }
        
        function showPlanExitPrompt() {
            const messagesDiv = document.getElementById('chatMessages');
            const exitPrompt = document.createElement('div');
            exitPrompt.className = 'plan-exit-prompt';
            exitPrompt.innerHTML = `
                <div style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <h4 style="margin: 0 0 10px 0; display: flex; align-items: center;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                            <polyline points="22 4 12 14.01 9 11.01"></polyline>
                        </svg>
                        Planning Complete!
                    </h4>
                    <p style="margin: 10px 0;">I've created a plan with ${plannedTasks.length} tasks. Ready to start building?</p>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button onclick="exitPlanMode()" style="background: white; color: #667eea; padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">
                            ✅ Start Building
                        </button>
                        <button onclick="continuePlanning()" style="background: rgba(255,255,255,0.2); color: white; padding: 8px 16px; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; cursor: pointer;">
                            💭 Continue Planning
                        </button>
                    </div>
                </div>
            `;
            messagesDiv.appendChild(exitPrompt);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        function exitPlanMode() {
            if (plannedTasks.length === 0) {
                alert('No tasks have been planned yet. Please continue planning or switch to another mode.');
                return;
            }
            
            // Exit plan mode and switch to Edit mode
            isPlanMode = false;
            currentTaskIndex = 0;
            setMode('edit');
            
            // Show task tracker
            showTaskTracker();
            
            // Start working on first task
            startNextTask();
        }
        
        function continuePlanning() {
            // Just remove the prompt and continue in plan mode
            const prompt = document.querySelector('.plan-exit-prompt');
            if (prompt) prompt.remove();
        }
        
        function showTaskTracker() {
            const messagesDiv = document.getElementById('chatMessages');
            const tracker = document.createElement('div');
            tracker.id = 'taskTracker';
            tracker.className = 'task-tracker';
            tracker.innerHTML = `
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #667eea;">
                    <h4 style="margin: 0 0 10px 0; color: #333;">🚀 Task Progress</h4>
                    <div id="taskList" style="margin: 10px 0;">
                        ${plannedTasks.map((task, index) => `
                            <div class="task-item" style="padding: 8px; margin: 5px 0; background: white; border-radius: 6px; background: white; display: flex; align-items: center;">
                                <span style="margin-right: 10px; display: inline-flex; align-items: center;">${
                        task.completed ? 
                        '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>' : 
                        index === currentTaskIndex ? 
                        '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#3b82f6" stroke-width="2"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>' : 
                        '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#a3a3a3" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>'
                    }</span>
                                <span style="flex: 1; ${index === currentTaskIndex ? 'font-weight: bold;' : ''}">${task.description}</span>
                            </div>
                        `).join('')}
                    </div>
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #dee2e6;">
                        <strong>Current Task (${currentTaskIndex + 1}/${plannedTasks.length}):</strong>
                        <p style="margin: 5px 0;">${plannedTasks[currentTaskIndex].description}</p>
                    </div>
                </div>
            `;
            messagesDiv.appendChild(tracker);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        function startNextTask() {
            if (currentTaskIndex >= plannedTasks.length) {
                showMessage('assistant', '🎉 All tasks completed! Your website is ready.');
                return;
            }
            
            const currentTask = plannedTasks[currentTaskIndex];
            const taskMessage = `Task ${currentTaskIndex + 1} of ${plannedTasks.length}: ${currentTask.description}`;
            
            // Show what task we're working on
            showMessage('user', `Please implement: ${currentTask.description}`);
            
            // Build context for the AI with emphasis on reusing classes
            let cssContext = '';
            if (currentCSS) {
                const cssInfo = extractCSSContext(currentCSS);
                cssContext = `\n\n## CSS REUSE GUIDELINES:\n`;
                cssContext += `${cssInfo.summary}\n\n`;
                
                if (cssInfo.classes.length > 0) {
                    cssContext += `MUST REUSE these existing CSS classes where appropriate:\n`;
                    cssContext += `${cssInfo.classes.join(', ')}\n\n`;
                }
                
                if (cssInfo.variables.length > 0) {
                    cssContext += `Available CSS variables to use:\n`;
                    cssContext += `${cssInfo.variables.join(', ')}\n\n`;
                }
                
                cssContext += `Guidelines:\n`;
                cssContext += `- Reuse existing classes before creating new ones\n`;
                cssContext += `- Extend existing styles rather than duplicating\n`;
                cssContext += `- Maintain consistent naming conventions\n`;
                cssContext += `- Use CSS variables for colors and spacing when available`;
            }
            
            const contextMessage = `[TASK EXECUTION MODE]\nCurrent task (${currentTaskIndex + 1}/${plannedTasks.length}): ${currentTask.description}\n\nPlease implement this specific task. Provide the HTML and CSS code needed.${cssContext}\n\nCurrent HTML:\n${currentHTML || 'None yet'}\n\nCurrent CSS:\n${currentCSS || 'None yet'}`;
            
            // Send the task to AI automatically
            setTimeout(() => {
                // Set the mode to add or edit based on whether we have content
                if (!currentHTML || currentHTML.trim() === '') {
                    setMode('edit'); // First task, start fresh
                } else {
                    setMode('add'); // Subsequent tasks, add to existing
                }
                
                // Send the implementation request
                document.getElementById('userInput').value = `Implement: ${currentTask.description}`;
                sendMessage();
            }, 500);
        }
        
        function updateTaskTracker() {
            const tracker = document.getElementById('taskTracker');
            if (!tracker) return;
            
            const taskList = document.getElementById('taskList');
            taskList.innerHTML = plannedTasks.map((task, index) => `
                <div class="task-item" style="padding: 8px; margin: 5px 0; background: white; border-radius: 6px; background: white; display: flex; align-items: center;">
                    <span style="margin-right: 10px; display: inline-flex; align-items: center;">${
                        task.completed ? 
                        '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>' : 
                        index === currentTaskIndex ? 
                        '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#3b82f6" stroke-width="2"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>' : 
                        '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#a3a3a3" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>'
                    }</span>
                    <span style="flex: 1; ${index === currentTaskIndex ? 'font-weight: bold;' : ''}">${task.description}</span>
                </div>
            `).join('');
        }
        
        async function sendMessage() {
            const apiKey = document.getElementById('apiKey').value;
            const model = document.getElementById('modelSelect').value;
            const input = document.getElementById('userInput').value.trim();
            
            if (!apiKey) {
                alert('Please enter your OpenRouter API key first');
                return;
            }
            
            if (!input) return;
            
            // Store current content BEFORE AI modifies it (for ADD mode merging)
            const previousHTML = currentHTML;
            const previousCSS = currentCSS;
            
            // Check if there's an attached image
            if (attachedImageData) {
                // Send message with attached image
                showMessage('user', input + ' [📎 Image attached]');
                
                // Clear input and disable button
                document.getElementById('userInput').value = '';
                document.getElementById('sendButton').disabled = true;
                document.getElementById('loadingIndicator').classList.add('active');
                
                // Send with image
                await sendMessageWithImage(attachedImageData, input);
                
                // Reset attachment
                attachedImageData = null;
                const attachBtn = document.querySelector('.attach-image-button');
                attachBtn.style.background = 'white';
                attachBtn.style.color = '#667eea';
                attachBtn.innerHTML = '📎';
                document.getElementById('imageInput').value = '';
                
                return;
            }
            
            // Show user message
            showMessage('user', input);
            
            // Clear input and disable button
            document.getElementById('userInput').value = '';
            document.getElementById('sendButton').disabled = true;
            document.getElementById('loadingIndicator').classList.add('active');
            
            // Build context message based on mode
            let contextMessage = input;
            
            // Add memory context for better continuity
            const memoryContext = getMemoryContext();
            
            if (currentMode === 'plan') {
                if (isPlanMode) {
                    // We're already in planning phase, continue the discussion
                    contextMessage = `[PLAN MODE - Continue Planning]\n${input}\n\nWe are currently planning the website project. Please continue helping with the planning phase.${memoryContext}`;
                } else {
                    // First message in plan mode - start planning
                    isPlanMode = true;
                    
                    // Include existing CSS context if available
                    let existingContext = '';
                    if (currentHTML || currentCSS) {
                        existingContext = '\n\n## Existing Code Context\n';
                        if (currentCSS) {
                            const cssInfo = extractCSSContext(currentCSS);
                            existingContext += `${cssInfo.summary}\n`;
                            if (cssInfo.classes.length > 0) {
                                existingContext += `Existing CSS classes to reuse: ${cssInfo.classes.join(', ')}\n`;
                            }
                            if (cssInfo.variables.length > 0) {
                                existingContext += `CSS variables available: ${cssInfo.variables.join(', ')}\n`;
                            }
                            existingContext += 'IMPORTANT: Plan tasks that reuse these existing styles for consistency.\n';
                        }
                        if (currentHTML) {
                            existingContext += 'Note: There is already existing HTML content that new features should integrate with.\n';
                        }
                    }
                    
                    contextMessage = `[PLAN MODE - Initial Planning]\n${input}${existingContext}\n\nPlease help me plan this website project. First, understand the requirements, then create a detailed plan with clear tasks. 

Format your response as:

## 1. Project Understanding
[Brief description of what the user wants]

## 2. Key Features
[List the main features needed]

## 3. Technical Approach
[Describe the technical strategy]
${currentCSS ? '- Reuse existing CSS classes where appropriate for consistency' : ''}

## 4. Task Breakdown
Please provide a numbered list of specific, actionable tasks:
1. Create the header section with navigation menu
2. Build the hero section with call-to-action
3. Implement the features section
[etc...]

Each task should be specific and actionable. Do not generate any code yet. Focus only on planning.${memoryContext}`;
                }
            } else if (currentMode === 'edit' && selectedElement) {
                // Extract CSS classes for context
                let cssClassContext = '';
                if (currentCSS) {
                    const classNames = [...currentCSS.matchAll(/\.([a-zA-Z0-9_-]+)/g)].map(m => m[1]);
                    const uniqueClasses = [...new Set(classNames)];
                    if (uniqueClasses.length > 0) {
                        cssClassContext = `\n\nExisting CSS classes (reuse these for consistency): ${uniqueClasses.slice(0, 20).join(', ')}${uniqueClasses.length > 20 ? '...' : ''}`;
                    }
                }
                contextMessage = `[EDIT MODE - Selected Element: ${selectedElement.selector}]\n${input}\n\nCurrent element HTML:\n${selectedElement.html}${cssClassContext}${memoryContext}`;
            } else if (currentMode === 'add') {
                // Extract CSS classes for context
                let cssClassContext = '';
                if (currentCSS) {
                    const classNames = [...currentCSS.matchAll(/\.([a-zA-Z0-9_-]+)/g)].map(m => m[1]);
                    const uniqueClasses = [...new Set(classNames)];
                    if (uniqueClasses.length > 0) {
                        cssClassContext = `\n\nIMPORTANT: Reuse these existing CSS classes where appropriate:\n${uniqueClasses.join(', ')}\n`;
                    }
                }
                contextMessage = `[ADD MODE - Create NEW content only]\n${input}${cssClassContext}\n\nIMPORTANT: Return ONLY the new HTML and CSS to be added. Do NOT include existing content.\n\nExisting HTML structure for context:\n${currentHTML ? currentHTML.substring(0, 500) + '...' : 'None'}\n\nExisting CSS classes you can reuse:\n${cssClassContext}${memoryContext}`;
            } else if (currentMode === 'reference' && referenceData) {
                contextMessage = `[REFERENCE MODE - Recreate similar design]\n${input}\n\nReference URL: ${referenceData.url}\n\n`;
                if (referenceData.html) {
                    // Include a snippet of the reference HTML structure
                    const snippet = referenceData.html.substring(0, 2000);
                    contextMessage += `Reference HTML structure (truncated):\n${snippet}...\n\n`;
                    if (referenceData.css) {
                        const cssSnippet = referenceData.css.substring(0, 1000);
                        contextMessage += `Reference CSS (truncated):\n${cssSnippet}...\n\n`;
                    }
                } else {
                    contextMessage += `User wants to recreate elements from: ${referenceData.url}\n`;
                }
                contextMessage += `\nIMPORTANT: Create a similar design inspired by the reference, but make it modern and unique. Don't copy exactly.${memoryContext}`;
            }
            
            // Add to conversation history
            conversationHistory.push({ role: 'user', content: contextMessage });
            
            try {
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Vibe Coder for Oxygen'
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [
                            {
                                role: 'system',
                                content: getSystemPromptWithBrandGuidelines() + `

CRITICAL MODE HANDLING:
- [ADD MODE]: When you see "[ADD MODE]", return ONLY the NEW content to be added. Do NOT include any existing HTML/CSS - just the new elements you're creating.
- [EDIT MODE]: When you see "[EDIT MODE]", MODIFY only the specified element while preserving everything else. Include the COMPLETE HTML/CSS with your edits applied.
- [REFERENCE MODE]: When you see "[REFERENCE MODE]", CREATE a similar design inspired by the reference website. Analyze the structure and style, but create your own modern interpretation. Don't copy exactly - improve upon it with modern design patterns.

IMPORTANT: You MUST follow this EXACT format for ALL responses:

[EXPLANATION]
Brief description of what you created or modified

[HTML]
\`\`\`html
(In ADD MODE: ONLY new HTML to be added, no existing content)
(In EDIT MODE: complete HTML with modifications)
\`\`\`

[CSS]
\`\`\`css
(In ADD MODE: ONLY new CSS for the new elements, no existing styles)
(In EDIT MODE: complete CSS with modifications)
\`\`\`

CRITICAL RULES:
1. In ADD MODE: Return ONLY new content - system will append it automatically
2. In EDIT MODE: Return complete HTML/CSS with targeted edits
3. ALWAYS include both [HTML] and [CSS] sections
4. ALWAYS use triple backticks with language identifier
5. NEVER delete existing content unless explicitly asked
6. Create beautiful, production-ready components with:
   - Modern design patterns
   - Gradients, shadows, and smooth transitions
   - Responsive design (mobile-first)
   - Proper spacing and typography
   - Hover effects and micro-interactions

Example ADD MODE:
User: [ADD MODE] Add a footer
Response: ONLY the new footer HTML and ONLY the new footer CSS

Example EDIT MODE:
User: [EDIT MODE - Selected: h1] Make the heading larger
Response: Include all HTML with h1 modified, all CSS with h1 styles updated

Remember: In ADD MODE return ONLY new content, in EDIT MODE return COMPLETE code!`
                            },
                            ...conversationHistory
                        ],
                        temperature: 0.7,
                        max_tokens: getModelContextLength(model)
                    })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error.message || 'API request failed');
                }
                
                const aiResponse = data.choices[0].message.content;
                
                // Add to conversation history
                conversationHistory.push({ role: 'assistant', content: aiResponse });
                
                // Handle Plan mode differently
                let displayMessage = aiResponse;
                
                if (currentMode === 'plan' && isPlanMode) {
                    // In plan mode, just show the response without parsing code
                    showMessage('assistant', aiResponse);
                    
                    // Check if AI has provided a task list (more flexible detection)
                    const hasTaskIndicators = 
                        aiResponse.toLowerCase().includes('task') ||
                        aiResponse.toLowerCase().includes('step') ||
                        aiResponse.toLowerCase().includes('implementation') ||
                        aiResponse.includes('1.') ||
                        aiResponse.includes('- ') ||
                        aiResponse.includes('* ');
                    
                    if (hasTaskIndicators) {
                        // Extract tasks from the response
                        extractPlanTasks(aiResponse);
                        
                        // Only show exit prompt if we actually found tasks
                        if (plannedTasks.length > 0) {
                            setTimeout(() => {
                                showPlanExitPrompt();
                            }, 500);
                        } else {
                            // If no tasks were extracted, show a hint to the user
                            setTimeout(() => {
                                showMessage('assistant', 'I\'m ready to help plan your project. Please describe what you want to build, and I\'ll create a detailed task list for implementation.');
                            }, 1000);
                        }
                    }
                } else {
                    // Normal mode - parse and extract code from response
                    parseAIResponse(aiResponse, previousHTML, previousCSS, currentJS);
                    
                    // Show AI message
                    displayMessage = aiResponse.split('[HTML]')[0].replace('[EXPLANATION]', '').trim();
                    showMessage('assistant', displayMessage);
                    
                    // Check if we're working on tasks
                    if (plannedTasks.length > 0 && currentTaskIndex < plannedTasks.length) {
                        // Mark current task as complete and move to next
                        plannedTasks[currentTaskIndex].completed = true;
                        currentTaskIndex++;
                        updateTaskTracker();
                        
                        // Start next task after a delay
                        if (currentTaskIndex < plannedTasks.length) {
                            setTimeout(() => {
                                startNextTask();
                            }, 2000);
                        } else {
                            showMessage('assistant', '🎉 All planned tasks have been completed! Your website is ready.');
                        }
                    }
                }
                
                // Add to memory
                addToMemory(input, displayMessage, { url: referenceData?.url });
                
                // Save current conversation state
                saveCurrentConversation();
                
            } catch (error) {
                showMessage('assistant', `Error: ${error.message}`);
            } finally {
                document.getElementById('sendButton').disabled = false;
                document.getElementById('loadingIndicator').classList.remove('active');
            }
        }

        function extractHTML(response) {
            console.log('Attempting to extract HTML from response');
            
            // Check if response is truncated (cutoff in middle of content)
            const isTruncated = response.length > 7500 || 
                              (response.includes('```') && !response.match(/```[\s\S]*?```/g));
            
            if (isTruncated) {
                console.warn('Response appears to be truncated, attempting partial extraction');
            }
            
            // Pattern 1: Standard markdown code block with html language
            let match = response.match(/```html\s*\n([\s\S]*?)```/i);
            if (match) {
                console.log('Found HTML using pattern 1: ```html');
                return match[1].trim();
            }
            
            // Pattern 2: Code block without newline
            match = response.match(/```html([\s\S]*?)```/i);
            if (match) {
                console.log('Found HTML using pattern 2: ```html (no newline)');
                return match[1].trim();
            }
            
            // Pattern 3: [HTML] section with any code block (handle incomplete blocks)
            match = response.match(/\[HTML\][\s\S]*?```(?:html)?\s*\n?([\s\S]*?)(?:```|$)/i);
            if (match) {
                console.log('Found HTML using pattern 3: [HTML] section');
                return match[1].trim();
            }
            
            // Pattern 4: Look for HTML section header then next code block
            const htmlMarkerIndex = response.search(/\[HTML\]/i);
            if (htmlMarkerIndex !== -1) {
                const afterMarker = response.substring(htmlMarkerIndex);
                match = afterMarker.match(/```\s*\n?([\s\S]*?)```/);
                if (match) {
                    console.log('Found HTML using pattern 4: [HTML] then code block');
                    return match[1].trim();
                }
            }
            
            // Pattern 5: Plain HTML section without code blocks (between [HTML] and next section)
            match = response.match(/\[HTML\]\s*\n([\s\S]*?)(?:\[|$)/i);
            if (match && match[1].trim()) {
                const content = match[1].trim();
                // Check if it looks like HTML
                if (content.includes('<') && content.includes('>')) {
                    console.log('Found HTML using pattern 5: Plain HTML after [HTML]');
                    return content;
                }
            }
            
            // Pattern 6: Generic code block after "HTML" keyword
            match = response.match(/\bHTML\b[\s\S]{0,50}```\s*\n?([\s\S]*?)```/i);
            if (match) {
                console.log('Found HTML using pattern 6: HTML keyword then code block');
                return match[1].trim();
            }
            
            // Pattern 7: Check if there's a code block that looks like HTML
            const allCodeBlocks = response.matchAll(/```(?:\w*\s*)?\n?([\s\S]*?)```/g);
            for (const block of allCodeBlocks) {
                const content = block[1].trim();
                // Check if it looks like HTML
                if (content.includes('<') && content.includes('>') &&
                    (content.includes('</') || content.match(/<[a-zA-Z]+[^>]*>/))) {
                    // Skip if it's clearly CSS
                    if (!content.includes('{') || content.includes('<')) {
                        console.log('Found HTML using pattern 7: Code block with HTML-like content');
                        return content;
                    }
                }
            }
            
            // Pattern 8: Last resort - find anything between [HTML] and [CSS] or end
            const htmlStart = response.search(/\[HTML\]/i);
            if (htmlStart !== -1) {
                const cssStart = response.search(/\[CSS\]/i);
                const jsStart = response.search(/\[(?:JS|JAVASCRIPT)\]/i);
                const explainStart = response.search(/\[EXPLANATION\]/i);
                
                let endIndex = response.length;
                if (cssStart > htmlStart) endIndex = Math.min(endIndex, cssStart);
                if (jsStart > htmlStart) endIndex = Math.min(endIndex, jsStart);
                if (explainStart > htmlStart) endIndex = Math.min(endIndex, explainStart);
                
                const htmlContent = response.substring(htmlStart + 6, endIndex).trim();
                // Remove any remaining backticks
                const cleaned = htmlContent.replace(/^```(?:html)?\s*|\s*```$/gi, '').trim();
                
                if (cleaned && cleaned.includes('<')) {
                    console.log('Found HTML using pattern 8: Content between [HTML] and next section');
                    return cleaned;
                }
            }
            
            console.log('No HTML found after trying all patterns');
            return null; // Return null to indicate no HTML was found
        }
        
        function extractCSS(response) {
            console.log('Attempting to extract CSS from response');
            
            // Pattern 1: Standard markdown code block with css language
            let match = response.match(/```css\s*\n([\s\S]*?)```/i);
            if (match) {
                console.log('Found CSS using pattern 1: ```css');
                return match[1].trim();
            }
            
            // Pattern 2: Code block without newline
            match = response.match(/```css([\s\S]*?)```/i);
            if (match) {
                console.log('Found CSS using pattern 2: ```css (no newline)');
                return match[1].trim();
            }
            
            // Pattern 3: [CSS] section with any code block
            match = response.match(/\[CSS\][\s\S]*?```(?:css)?\s*\n?([\s\S]*?)```/i);
            if (match) {
                console.log('Found CSS using pattern 3: [CSS] section');
                return match[1].trim();
            }
            
            // Pattern 4: Look for CSS section header then next code block
            const cssMarkerIndex = response.search(/\[CSS\]/i);
            if (cssMarkerIndex !== -1) {
                const afterMarker = response.substring(cssMarkerIndex);
                match = afterMarker.match(/```\s*\n?([\s\S]*?)```/);
                if (match) {
                    console.log('Found CSS using pattern 4: [CSS] then code block');
                    return match[1].trim();
                }
            }
            
            // Pattern 5: Plain CSS section without code blocks (between [CSS] and next section)
            match = response.match(/\[CSS\]\s*\n([\s\S]*?)(?:\[|$)/i);
            if (match && match[1].trim()) {
                // Check if it looks like CSS (has curly braces or common CSS properties)
                const content = match[1].trim();
                if (content.includes('{') || content.includes('}') || 
                    content.includes(':') || content.includes(';')) {
                    console.log('Found CSS using pattern 5: Plain CSS after [CSS]');
                    return content;
                }
            }
            
            // Pattern 6: Look for style tags
            match = response.match(/<style[^>]*>([\s\S]*?)<\/style>/i);
            if (match) {
                console.log('Found CSS using pattern 6: <style> tags');
                return match[1].trim();
            }
            
            // Pattern 7: Generic code block after "CSS" keyword
            match = response.match(/\bCSS\b[\s\S]{0,50}```\s*\n?([\s\S]*?)```/i);
            if (match) {
                console.log('Found CSS using pattern 7: CSS keyword then code block');
                return match[1].trim();
            }
            
            // Pattern 8: Check if there's a code block that looks like CSS
            const allCodeBlocks = response.matchAll(/```(?:\w*\s*)?\n?([\s\S]*?)```/g);
            for (const block of allCodeBlocks) {
                const content = block[1].trim();
                // Check if it looks like CSS (common CSS patterns)
                if ((content.includes('{') && content.includes('}') && 
                     (content.includes('color:') || content.includes('background:') || 
                      content.includes('margin:') || content.includes('padding:') ||
                      content.includes('display:') || content.includes('position:') ||
                      content.includes('width:') || content.includes('height:') ||
                      content.match(/\.[a-zA-Z][\w-]*\s*{/) || // class selector
                      content.match(/#[a-zA-Z][\w-]*\s*{/) || // id selector
                      content.match(/^[a-zA-Z]+\s*{/m)))) { // element selector
                    
                    // Skip if it's clearly HTML
                    if (!content.includes('<') && !content.includes('>')) {
                        console.log('Found CSS using pattern 8: Code block with CSS-like content');
                        return content;
                    }
                }
            }
            
            // Pattern 9: Last resort - find anything between [CSS] and [HTML] or end
            const cssStart = response.search(/\[CSS\]/i);
            if (cssStart !== -1) {
                const htmlStart = response.search(/\[HTML\]/i);
                const jsStart = response.search(/\[(?:JS|JAVASCRIPT)\]/i);
                const explainStart = response.search(/\[EXPLANATION\]/i);
                
                let endIndex = response.length;
                if (htmlStart > cssStart) endIndex = Math.min(endIndex, htmlStart);
                if (jsStart > cssStart) endIndex = Math.min(endIndex, jsStart);
                if (explainStart > cssStart) endIndex = Math.min(endIndex, explainStart);
                
                const cssContent = response.substring(cssStart + 5, endIndex).trim();
                // Remove any remaining backticks
                const cleaned = cssContent.replace(/^```(?:css)?\s*|\s*```$/gi, '').trim();
                
                if (cleaned && (cleaned.includes('{') || cleaned.includes(':'))) {
                    console.log('Found CSS using pattern 9: Content between [CSS] and next section');
                    return cleaned;
                }
            }
            
            // Enhanced error logging for CSS extraction failure
            console.warn('%c⚠️ CSS Extraction Failed', 'color: orange; font-weight: bold');
            console.warn('Tried all 9 patterns but no CSS found in response');
            console.warn('Response snippet:', response.substring(0, 500) + '...');
            return null; // Return null to indicate no CSS was found (different from empty CSS)
        }
        
        function extractJS(response) {
            console.log('Attempting to extract JavaScript from response');
            
            // Pattern 1: Standard markdown code block with js/javascript language
            let match = response.match(/```(?:js|javascript)\s*\n([\s\S]*?)```/i);
            if (match) {
                console.log('Found JS using pattern 1: ```js/javascript');
                return match[1].trim();
            }
            
            // Pattern 2: Code block without newline
            match = response.match(/```(?:js|javascript)([\s\S]*?)```/i);
            if (match) {
                console.log('Found JS using pattern 2: ```js/javascript (no newline)');
                return match[1].trim();
            }
            
            // Pattern 3: [JS] or [JAVASCRIPT] section with any code block
            match = response.match(/\[(?:JS|JAVASCRIPT)\][\s\S]*?```(?:js|javascript)?\s*\n?([\s\S]*?)```/i);
            if (match) {
                console.log('Found JS using pattern 3: [JS/JAVASCRIPT] section');
                return match[1].trim();
            }
            
            // Pattern 4: Look for JS section header then next code block
            const jsMarkerIndex = response.search(/\[(?:JS|JAVASCRIPT)\]/i);
            if (jsMarkerIndex !== -1) {
                const afterMarker = response.substring(jsMarkerIndex);
                match = afterMarker.match(/```\s*\n?([\s\S]*?)```/);
                if (match) {
                    console.log('Found JS using pattern 4: [JS/JAVASCRIPT] then code block');
                    return match[1].trim();
                }
            }
            
            // Pattern 5: Plain JS section without code blocks
            match = response.match(/\[(?:JS|JAVASCRIPT)\]\s*\n([\s\S]*?)(?:\[|$)/i);
            if (match && match[1].trim()) {
                const content = match[1].trim();
                // Check if it looks like JavaScript
                if (content.includes('function') || content.includes('const') || 
                    content.includes('let') || content.includes('var') ||
                    content.includes('=>') || content.includes('document.')) {
                    console.log('Found JS using pattern 5: Plain JS after [JS/JAVASCRIPT]');
                    return content;
                }
            }
            
            // Pattern 6: Look for script tags
            match = response.match(/<script[^>]*>([\s\S]*?)<\/script>/i);
            if (match) {
                console.log('Found JS using pattern 6: <script> tags');
                return match[1].trim();
            }
            
            // Pattern 7: Generic code block after "JavaScript" keyword
            match = response.match(/\b(?:JavaScript|JS)\b[\s\S]{0,50}```\s*\n?([\s\S]*?)```/i);
            if (match) {
                console.log('Found JS using pattern 7: JavaScript/JS keyword then code block');
                return match[1].trim();
            }
            
            // Pattern 8: Check if there's a code block that looks like JavaScript
            const allCodeBlocks = response.matchAll(/```(?:\w*\s*)?\n?([\s\S]*?)```/g);
            for (const block of allCodeBlocks) {
                const content = block[1].trim();
                // Check if it looks like JavaScript (common JS patterns)
                if ((content.includes('function') || content.includes('const') || 
                     content.includes('let') || content.includes('var') ||
                     content.includes('=>') || content.includes('addEventListener') ||
                     content.includes('document.') || content.includes('window.') ||
                     content.includes('console.') || content.includes('return ') ||
                     content.match(/\bif\s*\(/) || content.match(/\bfor\s*\(/))) {
                    
                    // Skip if it's clearly HTML or CSS
                    if (!content.includes('<') && !content.includes('{') && !content.includes('color:')) {
                        console.log('Found JS using pattern 8: Code block with JS-like content');
                        return content;
                    }
                }
            }
            
            // Pattern 9: Last resort - find anything between [JS] and next section
            const jsStart = response.search(/\[(?:JS|JAVASCRIPT)\]/i);
            if (jsStart !== -1) {
                const htmlStart = response.search(/\[HTML\]/i);
                const cssStart = response.search(/\[CSS\]/i);
                const explainStart = response.search(/\[EXPLANATION\]/i);
                
                let endIndex = response.length;
                if (htmlStart > jsStart) endIndex = Math.min(endIndex, htmlStart);
                if (cssStart > jsStart) endIndex = Math.min(endIndex, cssStart);
                if (explainStart > jsStart) endIndex = Math.min(endIndex, explainStart);
                
                const jsContent = response.substring(jsStart + 4, endIndex).trim();
                // Remove any remaining backticks
                const cleaned = jsContent.replace(/^```(?:js|javascript)?\s*|\s*```$/gi, '').trim();
                
                if (cleaned && (cleaned.includes('function') || cleaned.includes('=') || cleaned.includes(';'))) {
                    console.log('Found JS using pattern 9: Content between [JS] and next section');
                    return cleaned;
                }
            }
            
            // Enhanced error logging for JS extraction failure
            console.warn('%c⚠️ JavaScript Extraction Failed', 'color: orange; font-weight: bold');
            console.warn('Tried all 9 patterns but no JavaScript found in response');
            console.warn('Response snippet:', response.substring(0, 500) + '...');
            return null; // Return null to indicate no JS was found
        }
        
        function parseAIResponse(response, previousHTML = '', previousCSS = '', previousJS = '') {
            console.log('Parsing AI Response:', response); // Debug log
            console.log('Current Mode:', currentMode); // Debug log
            console.log('Previous HTML length:', previousHTML.length);
            console.log('Previous CSS length:', previousCSS.length);
            console.log('Previous JS length:', previousJS.length);
            
            // Backup current CSS and JS before any changes
            if (currentCSS) {
                lastKnownGoodCSS = currentCSS;
                console.log('Backed up current CSS (length: ' + lastKnownGoodCSS.length + ')');
            }
            if (currentJS) {
                lastKnownGoodJS = currentJS;
                console.log('Backed up current JS (length: ' + lastKnownGoodJS.length + ')');
            }
            
            // Extract HTML with comprehensive fallback patterns
            let newHTML = extractHTML(response);
            
            if (newHTML !== null) {
                console.log('HTML extracted successfully:', newHTML.substring(0, 100) + '...');
            } else {
                console.log('No HTML found in response - preserving existing HTML');
            }
            
            // Extract CSS with comprehensive fallback patterns
            let newCSS = extractCSS(response);
            
            if (newCSS !== null) {
                console.log('CSS extracted successfully:', newCSS.substring(0, 100) + '...');
            } else {
                console.log('No CSS found in response - will preserve existing CSS');
            }
            
            // Extract JavaScript with comprehensive fallback patterns
            let newJS = extractJS(response);
            
            if (newJS !== null) {
                console.log('JavaScript extracted successfully:', newJS.substring(0, 100) + '...');
            } else {
                console.log('No JavaScript found in response - will preserve existing JS');
            }
            
            // Handle ADD mode - merge with existing content
            if (currentMode === 'add') {
                console.log('ADD mode: Merging content');
                
                // HTML handling for ADD mode
                if (newHTML !== null) {
                    currentHTML = previousHTML ? mergeHTML(previousHTML, newHTML) : newHTML;
                    console.log('Merged HTML result length:', currentHTML.length);
                } else {
                    // No new HTML provided, keep existing
                    currentHTML = previousHTML || '';
                    console.log('No HTML in response, keeping existing HTML');
                }
                
                // CSS handling for ADD mode
                if (newCSS !== null) {
                    currentCSS = previousCSS ? mergeCSS(previousCSS, newCSS) : newCSS;
                    console.log('Merged CSS result length:', currentCSS.length);
                } else {
                    // No new CSS provided, keep existing
                    currentCSS = previousCSS || '';
                    console.log('No CSS in response, keeping existing CSS');
                }
                
                // JavaScript handling for ADD mode
                if (newJS !== null) {
                    currentJS = previousJS ? mergeJS(previousJS, newJS) : newJS;
                    console.log('Merged JS result length:', currentJS.length);
                } else {
                    // No new JS provided, keep existing
                    currentJS = previousJS || '';
                    console.log('No JS in response, keeping existing JS');
                }
            } else {
                // EDIT mode - only replace what was provided
                console.log('EDIT mode: Selective replacement');
                
                // HTML handling for EDIT mode
                if (newHTML !== null) {
                    currentHTML = newHTML;
                    console.log('Replaced HTML with new content');
                } else {
                    // No HTML provided, keep existing
                    currentHTML = previousHTML || '';
                    console.log('No HTML in response, keeping existing HTML');
                }
                
                // CSS handling for EDIT mode - CRITICAL FIX
                if (newCSS !== null) {
                    currentCSS = newCSS;
                    console.log('Replaced CSS with new content');
                } else {
                    // No CSS provided, keep existing CSS - THIS IS THE KEY FIX
                    currentCSS = previousCSS || lastKnownGoodCSS || '';
                    console.log('No CSS in response, preserving existing CSS (length: ' + currentCSS.length + ')');
                }
                
                // JavaScript handling for EDIT mode
                if (newJS !== null) {
                    currentJS = newJS;
                    console.log('Replaced JS with new content');
                } else {
                    // No JS provided, keep existing JS
                    currentJS = previousJS || lastKnownGoodJS || '';
                    console.log('No JS in response, preserving existing JS (length: ' + currentJS.length + ')');
                }
            }
            
            // Update editors
            document.getElementById('htmlEditor').value = currentHTML;
            document.getElementById('cssEditor').value = currentCSS;
            document.getElementById('jsEditor').value = currentJS;
            
            // Clear selection effects after processing
            clearSelectionEffects();
            
            // Update preview and generate JSON
            updatePreview();
            generateOxygenJSON();
            
            // Check if auto-generate images is enabled
            const autoGenCheckbox = document.getElementById('autoGenerateImages');
            if (autoGenCheckbox && autoGenCheckbox.checked) {
                // Wait a moment for preview to render, then auto-generate images
                setTimeout(() => {
                    autoGeneratePlaceholderImages(true); // Pass true to skip confirmation
                }, 1000);
            }
        }
        
        function mergeHTML(existingHTML, newHTML) {
            console.log('mergeHTML called');
            console.log('Existing HTML:', existingHTML);
            console.log('New HTML:', newHTML);
            
            // If no new HTML, return existing
            if (!newHTML || newHTML.trim() === '') {
                console.log('No new HTML to merge');
                return existingHTML;
            }
            
            // If no existing HTML, return new
            if (!existingHTML || existingHTML.trim() === '') {
                console.log('No existing HTML, using new HTML');
                return newHTML;
            }
            
            // In ADD mode, AI should now return ONLY new content, so always append
            // No need to check if existing content is included
            // Try to insert before closing body tag if present
            if (existingHTML.includes('</body>')) {
                console.log('Inserting before </body>');
                return existingHTML.replace('</body>', '\n' + newHTML + '\n</body>');
            } else if (existingHTML.includes('</div>')) {
                // Find the last closing div
                const lastDivIndex = existingHTML.lastIndexOf('</div>');
                console.log('Inserting before last </div>');
                return existingHTML.slice(0, lastDivIndex) + '\n' + newHTML + '\n' + existingHTML.slice(lastDivIndex);
            } else {
                // Otherwise just append
                console.log('Appending to end');
                return existingHTML + '\n' + newHTML;
            }
        }
        
        function mergeCSS(existingCSS, newCSS) {
            console.log('mergeCSS called');
            console.log('Existing CSS length:', existingCSS ? existingCSS.length : 0);
            console.log('New CSS length:', newCSS ? newCSS.length : 0);
            
            // If no new CSS, return existing
            if (!newCSS || newCSS.trim() === '') {
                console.log('No new CSS to merge');
                return existingCSS || '';
            }
            
            // If no existing CSS, return new
            if (!existingCSS || existingCSS.trim() === '') {
                console.log('No existing CSS, using new CSS');
                return newCSS;
            }
            
            // In ADD mode, AI should now return ONLY new styles, so always append
            // Simple append without complex checks
            console.log('Appending new CSS to existing');
            return existingCSS + '\n\n/* New styles */\n' + newCSS;
        }
        
        // Helper function to calculate string overlap
        function calculateOverlap(str1, str2) {
            if (!str1 || !str2) return 0;
            const shorter = str1.length < str2.length ? str1 : str2;
            const longer = str1.length >= str2.length ? str1 : str2;
            
            let matchCount = 0;
            const chunkSize = 20; // Check chunks of 20 characters
            for (let i = 0; i < shorter.length - chunkSize; i += chunkSize) {
                const chunk = shorter.substring(i, i + chunkSize);
                if (longer.includes(chunk)) {
                    matchCount++;
                }
            }
            
            const totalChunks = Math.floor(shorter.length / chunkSize);
            return totalChunks > 0 ? matchCount / totalChunks : 0;
        }
        
        // Helper function to extract CSS selectors
        function extractSelectors(css) {
            if (!css) return [];
            const selectorRegex = /([.#]?[a-zA-Z0-9_-]+(?:\s*[>+~]\s*)?)+(?:\s*,\s*[.#]?[a-zA-Z0-9_-]+)*\s*{/g;
            const matches = css.match(selectorRegex) || [];
            return matches.map(m => m.replace('{', '').trim());
        }
        
        function mergeJS(existingJS, newJS) {
            console.log('mergeJS called');
            console.log('Existing JS length:', existingJS ? existingJS.length : 0);
            console.log('New JS length:', newJS ? newJS.length : 0);
            
            // If no new JS, return existing
            if (!newJS || newJS.trim() === '') {
                console.log('No new JS to merge');
                return existingJS || '';
            }
            
            // If no existing JS, return new
            if (!existingJS || existingJS.trim() === '') {
                console.log('No existing JS, using new JS');
                return newJS;
            }
            
            // Check if AI returned complete JS (includes existing)
            if (newJS.includes(existingJS.trim())) {
                console.log('AI included existing JS, using complete version');
                return newJS;
            }
            
            // Append new JS with a separator comment
            console.log('Appending new JS to existing');
            return existingJS + '\n\n// Added JavaScript\n' + newJS;
        }

        function updatePreview() {
            const preview = document.getElementById('previewFrame');
            const doc = preview.contentDocument || preview.contentWindow.document;
            
            // Clean up any existing edit mode indicator before updating
            const existingIndicator = doc.getElementById('editModeIndicator');
            if (existingIndicator) {
                existingIndicator.remove();
                console.log('Cleaned up existing indicator in updatePreview');
            }
            
            const fullHTML = `
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <style>
                        * { margin: 0; padding: 0; box-sizing: border-box; }
                        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
                        ${currentCSS}
                    </style>
                </head>
                <body>
                    ${currentHTML}
                </body>
                </html>
            `;
            
            doc.open();
            doc.write(fullHTML);
            doc.close();
            
            // Clean up any indicator that might have been in the HTML content
            setTimeout(() => {
                const indicator = doc.getElementById('editModeIndicator');
                if (indicator && !isEditMode) {
                    indicator.remove();
                    console.log('Removed indicator after document write');
                }
            }, 0);
            
            // Add JavaScript after the document is written to avoid escaping issues
            if (currentJS && currentJS.trim()) {
                const script = doc.createElement('script');
                script.textContent = currentJS;
                doc.body.appendChild(script);
            }
            
            // Add right-click context menu to preview elements
            setupContextMenu(doc);
        }
        
        function setupContextMenu(doc) {
            // Remove any existing listeners
            doc.removeEventListener('contextmenu', handleContextMenu);
            doc.removeEventListener('click', hideContextMenuOnly);
            doc.removeEventListener('mouseover', handleElementHoverEdit);
            doc.removeEventListener('mouseout', handleElementHoverOutEdit);
            
            // Clean up any stray indicators if edit mode is off
            if (!isEditMode) {
                const indicator = doc.getElementById('editModeIndicator');
                if (indicator) {
                    indicator.remove();
                    console.log('Cleaned up indicator in setupContextMenu');
                }
            }
            
            // Only add listeners if edit mode is active
            if (isEditMode) {
                doc.addEventListener('contextmenu', handleContextMenu);
                doc.addEventListener('click', hideContextMenuOnly);
                doc.addEventListener('mouseover', handleElementHoverEdit);
                doc.addEventListener('mouseout', handleElementHoverOutEdit);
            }
        }
        
        function hideContextMenuOnly(e) {
            // Only hide context menu, don't select elements
            const contextMenu = document.getElementById('contextMenu');
            if (contextMenu && contextMenu.style.display === 'block') {
                hideContextMenu();
            }
        }
        
        function toggleEditMode() {
            isEditMode = !isEditMode;
            const editBtn = document.getElementById('manualEditModeBtn');
            const previewFrame = document.getElementById('previewFrame');
            const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
            
            if (isEditMode) {
                // Enable edit mode
                editBtn.classList.add('active');
                editBtn.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                editBtn.style.color = 'white';
                editBtn.textContent = '🚫 Exit Manual Edit';
                
                // Edit mode indicator removed - no longer showing the indicator overlay
                // const indicator = iframeDoc.createElement('div');
                // indicator.id = 'editModeIndicator';
                // indicator.innerHTML = '✏️ MANUAL EDIT MODE ACTIVE';
                // indicator.style.cssText = `
                //     position: fixed;
                //     top: 10px;
                //     right: 10px;
                //     background: linear-gradient(135deg, #667eea, #764ba2);
                //     color: white;
                //     padding: 8px 16px;
                //     border-radius: 20px;
                //     font-size: 12px;
                //     font-weight: bold;
                //     z-index: 10000;
                //     box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                // `;
                // iframeDoc.body.appendChild(indicator);
                
                // Add edit mode styles
                const style = iframeDoc.createElement('style');
                style.id = 'editModeStyles';
                style.textContent = `
                    .edit-hover {
                        outline: 2px dashed #667eea !important;
                        outline-offset: 2px;
                        cursor: pointer !important;
                        position: relative !important;
                    }
                    
                    .edit-hover::before {
                        content: attr(data-element-type);
                        position: absolute;
                        top: -25px;
                        left: 0;
                        background: #667eea;
                        color: black;
                        padding: 2px 8px;
                        border-radius: 6px; background: white;
                        font-size: 11px;
                        font-weight: 400;
                        z-index: 10001;
                        white-space: nowrap;
                    }
                    
                    .element-highlight {
                        outline: 3px solid #764ba2 !important;
                        outline-offset: 2px;
                    }
                `;
                iframeDoc.head.appendChild(style);
                
                showToast('✏️ Manual Edit Mode activated! Right-click elements to edit.', 3000);
            } else {
                // Disable edit mode
                editBtn.classList.remove('active');
                editBtn.style.background = '';
                editBtn.style.color = '';
                editBtn.textContent = '✏️ Manual Edit Mode';
                
                // Remove edit mode indicator - commented out since indicator is no longer created
                // const indicator = iframeDoc.getElementById('editModeIndicator');
                // if (indicator) indicator.remove();
                
                // Remove edit mode styles
                const style = iframeDoc.getElementById('editModeStyles');
                if (style) style.remove();
                
                // Remove any hover effects
                iframeDoc.querySelectorAll('.edit-hover').forEach(el => {
                    el.classList.remove('edit-hover');
                    el.removeAttribute('data-element-type');
                });
                
                // Remove any highlights
                iframeDoc.querySelectorAll('.element-highlight').forEach(el => {
                    el.classList.remove('element-highlight');
                });
                
                hideContextMenu();
                showToast('✏️ Manual Edit Mode deactivated.', 2000);
            }
            
            // Re-setup context menu with new mode
            setupContextMenu(iframeDoc);
        }
        
        function handleElementHoverEdit(e) {
            if (!isEditMode) return;
            
            // Stop propagation to prevent parent elements from also getting highlighted
            e.stopPropagation();
            
            const target = e.target;
            if (!target || target.tagName === 'BODY' || target.tagName === 'HTML' || target.id === 'editModeIndicator') {
                return;
            }
            
            // Get the iframe document
            const iframeDoc = target.ownerDocument || document.getElementById('previewFrame').contentDocument;
            
            // Remove all existing hover effects first (except from the context menu target)
            iframeDoc.querySelectorAll('.edit-hover').forEach(el => {
                if (el !== target && el !== contextMenuTarget) {
                    el.classList.remove('edit-hover');
                    el.removeAttribute('data-element-type');
                }
            });
            
            // Check if element is too large (likely a container spanning the whole page)
            const rect = target.getBoundingClientRect();
            const viewportHeight = iframeDoc.defaultView.innerHeight;
            const viewportWidth = iframeDoc.defaultView.innerWidth;
            
            // Skip if element covers more than 80% of viewport (likely a main container)
            if (rect.width > viewportWidth * 0.8 && rect.height > viewportHeight * 0.8) {
                return;
            }
            
            // Add hover effect only to current target
            target.classList.add('edit-hover');
            
            // Add element type label
            const tagName = target.tagName.toLowerCase();
            let elementType = tagName;
            
            // Provide more descriptive names for common elements
            switch(tagName) {
                case 'h1':
                case 'h2':
                case 'h3':
                case 'h4':
                case 'h5':
                case 'h6':
                    elementType = 'Heading';
                    break;
                case 'p':
                    elementType = 'Paragraph';
                    break;
                case 'div':
                    elementType = 'Container';
                    break;
                case 'section':
                    elementType = 'Section';
                    break;
                case 'img':
                    elementType = 'Image';
                    break;
                case 'a':
                    elementType = 'Link';
                    break;
                case 'button':
                    elementType = 'Button';
                    break;
                case 'ul':
                case 'ol':
                    elementType = 'List';
                    break;
                case 'li':
                    elementType = 'List Item';
                    break;
                case 'span':
                    elementType = 'Text';
                    break;
                case 'input':
                    elementType = 'Input Field';
                    break;
                case 'form':
                    elementType = 'Form';
                    break;
            }
            
            target.setAttribute('data-element-type', elementType);
        }
        
        function handleElementHoverOutEdit(e) {
            if (!isEditMode) return;
            
            const target = e.target;
            const relatedTarget = e.relatedTarget;
            
            if (!target) return;
            
            // Don't remove hover if moving to a child element
            if (relatedTarget && target.contains(relatedTarget)) {
                return;
            }
            
            // Remove hover effect unless it's the context menu target
            if (target !== contextMenuTarget) {
                target.classList.remove('edit-hover');
                target.removeAttribute('data-element-type');
            }
            
            // Clean up any orphaned hover effects (safety measure)
            const iframeDoc = target.ownerDocument || document.getElementById('previewFrame').contentDocument;
            if (iframeDoc) {
                // Count hover elements
                const hoverElements = iframeDoc.querySelectorAll('.edit-hover');
                // If there are multiple hover elements and none are being hovered, clean them all
                if (hoverElements.length > 1) {
                    hoverElements.forEach(el => {
                        if (el !== contextMenuTarget && el !== relatedTarget) {
                            el.classList.remove('edit-hover');
                            el.removeAttribute('data-element-type');
                        }
                    });
                }
            }
        }
        
        function handleContextMenu(e) {
            console.log('handleContextMenu called, isEditMode:', isEditMode);
            // Only handle in edit mode
            if (!isEditMode) return;
            
            e.preventDefault();
            
            const target = e.target;
            console.log('Context menu target element:', target);
            if (!target || target.tagName === 'BODY' || target.tagName === 'HTML' || target.id === 'editModeIndicator') {
                return;
            }
            
            contextMenuTarget = target;
            console.log('contextMenuTarget set to:', contextMenuTarget);
            
            // Don't set selectedElement or switch modes in manual edit mode
            // Manual edit mode is separate from chat's edit mode
            
            // Highlight the element
            const iframeDoc = document.getElementById('previewFrame').contentDocument;
            iframeDoc.querySelectorAll('.element-highlight').forEach(el => {
                el.classList.remove('element-highlight');
            });
            target.classList.add('element-highlight');
            
            // Show/hide menu items based on element type
            const linkOption = document.getElementById('editLinkOption');
            const replaceImageBtn = document.getElementById('replaceImageBtn');
            const alignButtons = [
                document.getElementById('alignLeftBtn'),
                document.getElementById('alignCenterBtn'),
                document.getElementById('alignRightBtn')
            ];
            
            // Show link option for any element that can be made clickable
            if (linkOption) {
                linkOption.style.display = 'block';
                linkOption.innerHTML = target.tagName === 'A' ? 
                    '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px; display: inline-block; vertical-align: middle;"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg> Edit Link' : 
                    '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px; display: inline-block; vertical-align: middle;"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg> Make Clickable';
            }
            
            // Show replace image for images or elements with background
            const hasBackground = window.getComputedStyle(target).backgroundImage !== 'none';
            if (replaceImageBtn) {
                replaceImageBtn.style.display = (target.tagName === 'IMG' || hasBackground) ? 'block' : 'none';
            }
            
            // Show alignment based on element type
            const isTextElement = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'P', 'SPAN', 'DIV', 'SECTION'].includes(target.tagName);
            alignButtons.forEach(btn => {
                if (btn) btn.style.display = isTextElement ? 'block' : 'none';
            });
            
            // Position and show context menu
            const menu = document.getElementById('contextMenu');
            const iframe = document.getElementById('previewFrame');
            const rect = iframe.getBoundingClientRect();
            
            menu.style.left = (rect.left + e.clientX) + 'px';
            menu.style.top = (rect.top + e.clientY) + 'px';
            menu.style.display = 'block';
        }
        
        function hideContextMenu() {
            document.getElementById('contextMenu').style.display = 'none';
            
            // Remove highlight and hover effects
            const iframeDoc = document.getElementById('previewFrame').contentDocument;
            if (iframeDoc) {
                // Remove element highlight
                iframeDoc.querySelectorAll('.element-highlight').forEach(el => {
                    el.classList.remove('element-highlight');
                });
                
                // Remove hover effect from the context menu target
                if (contextMenuTarget) {
                    contextMenuTarget.classList.remove('edit-hover');
                    contextMenuTarget.removeAttribute('data-element-type');
                }
                
                // Remove any other lingering hover effects
                iframeDoc.querySelectorAll('.edit-hover').forEach(el => {
                    el.classList.remove('edit-hover');
                    el.removeAttribute('data-element-type');
                });
            }
            
            // Clear the context menu target
            contextMenuTarget = null;
        }
        
        function editElementText() {
            console.log('editElementText called, target:', contextMenuTarget);
            if (!contextMenuTarget) {
                console.log('No context menu target');
                return;
            }
            
            // Store the target before hiding menu
            const target = contextMenuTarget;
            hideContextMenu();
            
            document.getElementById('editorTitle').textContent = 'Edit Text Content';
            document.getElementById('editorContent').innerHTML = `
                <div class="property-group">
                    <label class="property-label">Text Content:</label>
                    <textarea class="property-input" id="textContent" rows="4">${target.textContent}</textarea>
                </div>
            `;
            document.getElementById('propertyEditor').style.display = 'block';
            
            // Store target for apply function
            contextMenuTarget = target;
        }
        
        // Helper function to parse CSS value and extract number and unit
        function parseCSSValue(value) {
            if (!value || value === 'auto' || value === 'none' || value === 'initial' || value === 'inherit') {
                return { number: '', unit: value || 'auto' };
            }
            const match = value.match(/^([\d.]+)(.*)$/);
            if (match) {
                return { number: match[1], unit: match[2] || 'px' };
            }
            return { number: '', unit: 'px' };
        }

        // Helper function to create input with unit dropdown
        function createSizeInput(id, label, value, includeAuto = true) {
            const parsed = parseCSSValue(value);
            const units = includeAuto ? 
                ['px', '%', 'rem', 'em', 'vh', 'vw', 'auto'] : 
                ['px', '%', 'rem', 'em', 'vh', 'vw'];
            
            return `
                <div class="property-group">
                    <label class="property-label">${label}:</label>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" 
                               class="property-input" 
                               id="${id}" 
                               value="${parsed.number}" 
                               placeholder="Value"
                               style="flex: 1; ${parsed.unit === 'auto' ? 'display: none;' : ''}"
                               ${parsed.unit === 'auto' ? 'disabled' : ''}>
                        <select class="property-input" 
                                id="${id}Unit" 
                                style="width: 80px;"
                                onchange="toggleAutoInput('${id}', this.value)">
                            ${units.map(u => `<option value="${u}" ${parsed.unit === u ? 'selected' : ''}>${u}</option>`).join('')}
                        </select>
                    </div>
                </div>
            `;
        }

        // Function to toggle input visibility when 'auto' is selected
        function toggleAutoInput(inputId, unitValue) {
            const input = document.getElementById(inputId);
            if (unitValue === 'auto') {
                input.style.display = 'none';
                input.disabled = true;
                input.value = '';
            } else {
                input.style.display = '';
                input.disabled = false;
                if (!input.value) input.value = '100';
            }
        }

        function editElementSize() {
            if (!contextMenuTarget) return;
            
            const target = contextMenuTarget;
            const computedStyles = window.getComputedStyle(target);
            hideContextMenu();
            
            document.getElementById('editorTitle').textContent = 'Edit Size';
            document.getElementById('editorContent').innerHTML = `
                ${createSizeInput('elementWidth', 'Width', computedStyles.width)}
                ${createSizeInput('elementHeight', 'Height', computedStyles.height)}
                ${createSizeInput('minWidth', 'Min Width', computedStyles.minWidth)}
                ${createSizeInput('minHeight', 'Min Height', computedStyles.minHeight)}
                ${createSizeInput('maxWidth', 'Max Width', computedStyles.maxWidth)}
                ${createSizeInput('maxHeight', 'Max Height', computedStyles.maxHeight)}
            `;
            document.getElementById('propertyEditor').style.display = 'block';
            contextMenuTarget = target;
        }

        function editElementStyles() {
            if (!contextMenuTarget) return;
            
            const target = contextMenuTarget;
            const computedStyles = window.getComputedStyle(target);
            hideContextMenu();
            
            document.getElementById('editorTitle').textContent = 'Edit Styles';
            document.getElementById('editorContent').innerHTML = `
                <div class="property-group">
                    <label class="property-label">Color:</label>
                    <input type="color" class="property-input" id="styleColor" value="${rgbToHex(computedStyles.color)}" style="height: 40px;">
                </div>
                <div class="property-group">
                    <label class="property-label">Background Color:</label>
                    <input type="color" class="property-input" id="styleBgColor" value="${rgbToHex(computedStyles.backgroundColor)}" style="height: 40px;">
                </div>
                ${createSizeInput('styleFontSize', 'Font Size', computedStyles.fontSize, false)}
                <div class="property-group">
                    <label class="property-label">Font Weight:</label>
                    <select class="property-input" id="styleFontWeight">
                        <option value="normal">Normal</option>
                        <option value="bold">Bold</option>
                        <option value="lighter">Lighter</option>
                        <option value="100">100</option>
                        <option value="200">200</option>
                        <option value="300">300</option>
                        <option value="400">400</option>
                        <option value="500">500</option>
                        <option value="600">600</option>
                        <option value="700">700</option>
                        <option value="800">800</option>
                        <option value="900">900</option>
                    </select>
                </div>
            `;
            document.getElementById('propertyEditor').style.display = 'block';
            contextMenuTarget = target;
        }
        
        function editElementPadding() {
            if (!contextMenuTarget) return;
            
            const target = contextMenuTarget;
            const computedStyles = window.getComputedStyle(target);
            hideContextMenu();
            
            document.getElementById('editorTitle').textContent = 'Edit Padding & Margin';
            document.getElementById('editorContent').innerHTML = `
                ${createSizeInput('stylePaddingTop', 'Padding Top', computedStyles.paddingTop, false)}
                ${createSizeInput('stylePaddingRight', 'Padding Right', computedStyles.paddingRight, false)}
                ${createSizeInput('stylePaddingBottom', 'Padding Bottom', computedStyles.paddingBottom, false)}
                ${createSizeInput('stylePaddingLeft', 'Padding Left', computedStyles.paddingLeft, false)}
                <div style="border-top: 1px solid #e4e4e7; margin: 15px 0;"></div>
                ${createSizeInput('styleMarginTop', 'Margin Top', computedStyles.marginTop, true)}
                ${createSizeInput('styleMarginRight', 'Margin Right', computedStyles.marginRight, true)}
                ${createSizeInput('styleMarginBottom', 'Margin Bottom', computedStyles.marginBottom, true)}
                ${createSizeInput('styleMarginLeft', 'Margin Left', computedStyles.marginLeft, true)}
                <div style="border-top: 1px solid #e4e4e7; margin: 15px 0;"></div>
                ${createSizeInput('styleBorderRadius', 'Border Radius', computedStyles.borderRadius, false)}
            `;
            document.getElementById('propertyEditor').style.display = 'block';
            contextMenuTarget = target;
        }
        
        function editElementLink() {
            if (!contextMenuTarget) return;
            
            const target = contextMenuTarget;
            hideContextMenu();
            
            if (target.tagName !== 'A') {
                // Make element clickable by wrapping in anchor
                const anchor = document.createElement('a');
                anchor.href = '#';
                anchor.target = '_self';
                target.parentNode.insertBefore(anchor, target);
                anchor.appendChild(target);
                contextMenuTarget = anchor;
                updateHTMLFromPreview();
                editElementLink();
                return;
            }
            
            document.getElementById('editorTitle').textContent = 'Edit Link';
            document.getElementById('editorContent').innerHTML = `
                <div class="property-group">
                    <label class="property-label">URL:</label>
                    <input type="url" class="property-input" id="linkHref" value="${target.href}" placeholder="https://example.com">
                </div>
                <div class="property-group">
                    <label class="property-label">Target:</label>
                    <select class="property-input" id="linkTarget">
                        <option value="_self" ${target.target === '_self' ? 'selected' : ''}>Same Window</option>
                        <option value="_blank" ${target.target === '_blank' ? 'selected' : ''}>New Window</option>
                    </select>
                </div>
            `;
            document.getElementById('propertyEditor').style.display = 'block';
            contextMenuTarget = target;
        }
        
        function editElementBackground() {
            if (!contextMenuTarget) return;
            
            const target = contextMenuTarget;
            const computedStyles = window.getComputedStyle(target);
            hideContextMenu();
            
            document.getElementById('editorTitle').textContent = 'Edit Background';
            document.getElementById('editorContent').innerHTML = `
                <div class="property-group">
                    <label class="property-label">Background Color:</label>
                    <input type="color" class="property-input" id="bgColor" value="${rgbToHex(computedStyles.backgroundColor)}" style="height: 40px;">
                </div>
                <div class="property-group">
                    <label class="property-label">Background Image URL:</label>
                    <input type="text" class="property-input" id="bgImage" placeholder="https://example.com/image.jpg">
                </div>
                <div class="property-group">
                    <label class="property-label">Background Size:</label>
                    <select class="property-input" id="bgSize">
                        <option value="auto">Auto</option>
                        <option value="cover">Cover</option>
                        <option value="contain">Contain</option>
                        <option value="100% 100%">Stretch</option>
                    </select>
                </div>
            `;
            document.getElementById('propertyEditor').style.display = 'block';
            contextMenuTarget = target;
        }
        
        function duplicateElement() {
            if (!contextMenuTarget) return;
            
            const target = contextMenuTarget;
            hideContextMenu();
            
            const clone = target.cloneNode(true);
            target.parentNode.insertBefore(clone, target.nextSibling);
            
            // Update the HTML editor
            updateHTMLFromPreview();
            showToast('Element duplicated successfully!', 2000);
        }
        
        function deleteElement() {
            if (!contextMenuTarget) return;
            
            const target = contextMenuTarget;
            hideContextMenu();
            
            if (confirm('Are you sure you want to delete this element?')) {
                target.remove();
                updateHTMLFromPreview();
                showToast('Element deleted successfully!', 2000);
            }
        }
        
        function initializeContextMenuListeners() {
            console.log('Initializing context menu listeners...');
            
            // Add event listeners for context menu items
            const editTextBtn = document.getElementById('editTextBtn');
            const editStylesBtn = document.getElementById('editStylesBtn');
            const editPaddingBtn = document.getElementById('editPaddingBtn');
            const editSizeBtn = document.getElementById('editSizeBtn');
            const editLinkBtn = document.getElementById('editLinkOption');
            const replaceImageBtn = document.getElementById('replaceImageBtn');
            const duplicateBtn = document.getElementById('duplicateBtn');
            const deleteBtn = document.getElementById('deleteBtn');
            
            console.log('Found buttons:', {
                editText: !!editTextBtn,
                editStyles: !!editStylesBtn,
                editPadding: !!editPaddingBtn,
                editSize: !!editSizeBtn,
                editLink: !!editLinkBtn,
                replaceImage: !!replaceImageBtn,
                duplicate: !!duplicateBtn,
                delete: !!deleteBtn
            });
            
            if (editTextBtn) {
                editTextBtn.addEventListener('click', (e) => {
                    console.log('Edit text clicked');
                    e.stopPropagation();
                    editElementText();
                });
            }
            if (editStylesBtn) {
                editStylesBtn.addEventListener('click', (e) => {
                    console.log('Edit styles clicked');
                    e.stopPropagation();
                    editElementStyles();
                });
            }
            if (editPaddingBtn) {
                editPaddingBtn.addEventListener('click', (e) => {
                    console.log('Edit padding clicked');
                    e.stopPropagation();
                    editElementPadding();
                });
            }
            if (editSizeBtn) {
                editSizeBtn.addEventListener('click', (e) => {
                    console.log('Edit size clicked');
                    e.stopPropagation();
                    editElementSize();
                });
            }
            if (editLinkBtn) {
                editLinkBtn.addEventListener('click', (e) => {
                    console.log('Edit link clicked');
                    e.stopPropagation();
                    editElementLink();
                });
            }
            if (replaceImageBtn) {
                replaceImageBtn.addEventListener('click', (e) => {
                    console.log('Replace image clicked');
                    e.stopPropagation();
                    replaceElementImage();
                });
            }
            if (duplicateBtn) {
                duplicateBtn.addEventListener('click', (e) => {
                    console.log('Duplicate clicked');
                    e.stopPropagation();
                    duplicateElement();
                });
            }
            if (deleteBtn) {
                deleteBtn.addEventListener('click', (e) => {
                    console.log('Delete clicked');
                    e.stopPropagation();
                    deleteElement();
                });
            }
            
            // Alignment buttons
            const alignLeftBtn = document.getElementById('alignLeftBtn');
            const alignCenterBtn = document.getElementById('alignCenterBtn');
            const alignRightBtn = document.getElementById('alignRightBtn');
            
            if (alignLeftBtn) {
                alignLeftBtn.addEventListener('click', (e) => {
                    console.log('Align left clicked');
                    e.stopPropagation();
                    alignElement('left');
                });
            }
            if (alignCenterBtn) {
                alignCenterBtn.addEventListener('click', (e) => {
                    console.log('Align center clicked');
                    e.stopPropagation();
                    alignElement('center');
                });
            }
            if (alignRightBtn) {
                alignRightBtn.addEventListener('click', (e) => {
                    console.log('Align right clicked');
                    e.stopPropagation();
                    alignElement('right');
                });
            }
            
            // Reorder buttons
            const moveUpBtn = document.getElementById('moveUpBtn');
            const moveDownBtn = document.getElementById('moveDownBtn');
            
            if (moveUpBtn) {
                moveUpBtn.addEventListener('click', (e) => {
                    console.log('Move up clicked');
                    e.stopPropagation();
                    moveElementUp();
                });
            }
            if (moveDownBtn) {
                moveDownBtn.addEventListener('click', (e) => {
                    console.log('Move down clicked');
                    e.stopPropagation();
                    moveElementDown();
                });
            }
            
            // Responsive buttons
            const hideMobileBtn = document.getElementById('hideMobileBtn');
            const hideDesktopBtn = document.getElementById('hideDesktopBtn');
            
            if (hideMobileBtn) {
                hideMobileBtn.addEventListener('click', (e) => {
                    console.log('Hide mobile clicked');
                    e.stopPropagation();
                    toggleMobileVisibility();
                });
            }
            if (hideDesktopBtn) {
                hideDesktopBtn.addEventListener('click', (e) => {
                    console.log('Hide desktop clicked');
                    e.stopPropagation();
                    toggleDesktopVisibility();
                });
            }
            
            // AI buttons
            const aiRefineBtn = document.getElementById('aiRefineBtn');
            const aiAlternativeBtn = document.getElementById('aiAlternativeBtn');
            
            if (aiRefineBtn) {
                aiRefineBtn.addEventListener('click', (e) => {
                    console.log('AI refine clicked');
                    e.stopPropagation();
                    aiRefineElement();
                });
            }
            if (aiAlternativeBtn) {
                aiAlternativeBtn.addEventListener('click', (e) => {
                    console.log('AI alternative clicked');
                    e.stopPropagation();
                    aiGenerateAlternative();
                });
            }
            
            console.log('Context menu listeners initialized');
        }
        
        // Helper function to extract design context from the page
        function getDesignContext() {
            const iframeDoc = document.getElementById('previewFrame').contentDocument;
            const computedStyles = iframeDoc.defaultView.getComputedStyle(iframeDoc.body);
            
            // Extract colors from the page
            const colors = new Set();
            const elements = iframeDoc.querySelectorAll('*');
            elements.forEach(el => {
                const style = iframeDoc.defaultView.getComputedStyle(el);
                if (style.color) colors.add(style.color);
                if (style.backgroundColor && style.backgroundColor !== 'rgba(0, 0, 0, 0)') {
                    colors.add(style.backgroundColor);
                }
            });
            
            // Get font families
            const fonts = new Set();
            elements.forEach(el => {
                const style = iframeDoc.defaultView.getComputedStyle(el);
                if (style.fontFamily) fonts.add(style.fontFamily);
            });
            
            // Get current CSS
            const currentCSS = document.getElementById('cssEditor').value;
            
            // Get brand guidelines
            const brandGuidelines = document.getElementById('brandGuidelines')?.value || '';
            
            return {
                bodyFont: computedStyles.fontFamily,
                bodyColor: computedStyles.color,
                bodyBg: computedStyles.backgroundColor,
                colors: Array.from(colors).slice(0, 5), // Top 5 colors
                fonts: Array.from(fonts).slice(0, 3), // Top 3 fonts
                currentCSS: currentCSS.substring(0, 500), // First 500 chars of CSS
                brandGuidelines: brandGuidelines
            };
        }
        
        // Helper to analyze element context
        function getElementContext(element) {
            const parent = element.parentElement;
            const siblings = Array.from(parent?.children || []).filter(el => el !== element);
            const elementStyles = window.getComputedStyle(element);
            
            // Determine element role
            let role = 'content';
            const tag = element.tagName.toLowerCase();
            const classes = element.className.toLowerCase();
            
            if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)) {
                role = 'heading';
            } else if (tag === 'button' || classes.includes('button') || classes.includes('btn')) {
                role = 'button';
            } else if (classes.includes('card')) {
                role = 'card';
            } else if (tag === 'nav' || classes.includes('nav')) {
                role = 'navigation';
            } else if (tag === 'header' || classes.includes('header')) {
                role = 'header';
            } else if (tag === 'footer' || classes.includes('footer')) {
                role = 'footer';
            } else if (tag === 'img') {
                role = 'image';
            } else if (tag === 'p') {
                role = 'paragraph';
            } else if (tag === 'a') {
                role = 'link';
            }
            
            return {
                role: role,
                tag: tag,
                hasText: element.textContent.trim().length > 0,
                hasBg: elementStyles.backgroundColor !== 'rgba(0, 0, 0, 0)',
                fontSize: elementStyles.fontSize,
                fontFamily: elementStyles.fontFamily,
                color: elementStyles.color,
                parentTag: parent?.tagName.toLowerCase(),
                siblingCount: siblings.length,
                isInGrid: elementStyles.display === 'grid' || parent?.style.display === 'grid',
                isInFlex: elementStyles.display === 'flex' || parent?.style.display === 'flex'
            };
        }
        
        // New context menu functions for last-mile adjustments
        function alignElement(alignment) {
            if (!contextMenuTarget) return;
            
            const target = contextMenuTarget;
            hideContextMenu();
            
            // Apply alignment based on element type
            const tagName = target.tagName.toLowerCase();
            
            if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'span', 'a'].includes(tagName)) {
                // Text elements - use text-align
                target.style.textAlign = alignment;
            } else {
                // Block elements - use margin auto for centering
                if (alignment === 'center') {
                    target.style.marginLeft = 'auto';
                    target.style.marginRight = 'auto';
                    target.style.display = 'block';
                } else if (alignment === 'left') {
                    target.style.marginLeft = '0';
                    target.style.marginRight = 'auto';
                } else if (alignment === 'right') {
                    target.style.marginLeft = 'auto';
                    target.style.marginRight = '0';
                }
            }
            
            updateHTMLFromPreview();
            showToast(`↔️ Aligned ${alignment}`, 1500);
        }
        
        function moveElementUp() {
            if (!contextMenuTarget) return;
            
            const target = contextMenuTarget;
            hideContextMenu();
            
            const prev = target.previousElementSibling;
            if (prev) {
                target.parentNode.insertBefore(target, prev);
                updateHTMLFromPreview();
                showToast('⬆️ Moved up', 1500);
            } else {
                showToast('Already at the top', 1500);
            }
        }
        
        function moveElementDown() {
            if (!contextMenuTarget) return;
            
            const target = contextMenuTarget;
            hideContextMenu();
            
            const next = target.nextElementSibling;
            if (next) {
                target.parentNode.insertBefore(next, target);
                updateHTMLFromPreview();
                showToast('⬇️ Moved down', 1500);
            } else {
                showToast('Already at the bottom', 1500);
            }
        }
        
        function toggleMobileVisibility() {
            if (!contextMenuTarget) return;
            
            const target = contextMenuTarget;
            hideContextMenu();
            
            // Add/remove a class that hides on mobile
            if (target.classList.contains('hide-mobile')) {
                target.classList.remove('hide-mobile');
                showToast('Visible on mobile', 1500);
            } else {
                target.classList.add('hide-mobile');
                // Add CSS if not exists
                addResponsiveCSS();
                showToast('Hidden on mobile', 1500);
            }
            
            updateHTMLFromPreview();
        }
        
        function toggleDesktopVisibility() {
            if (!contextMenuTarget) return;
            
            const target = contextMenuTarget;
            hideContextMenu();
            
            // Add/remove a class that hides on desktop
            if (target.classList.contains('hide-desktop')) {
                target.classList.remove('hide-desktop');
                showToast('Visible on desktop', 1500);
            } else {
                target.classList.add('hide-desktop');
                // Add CSS if not exists
                addResponsiveCSS();
                showToast('Hidden on desktop', 1500);
            }
            
            updateHTMLFromPreview();
        }
        
        function addResponsiveCSS() {
            // Check if responsive CSS already exists
            const cssEditor = document.getElementById('cssEditor');
            const currentCSS = cssEditor.value;
            
            if (!currentCSS.includes('.hide-mobile')) {
                const responsiveCSS = `
/* Responsive visibility classes */
@media (max-width: 768px) {
    .hide-mobile {
        display: none !important;
    }
}

@media (min-width: 769px) {
    .hide-desktop {
        display: none !important;
    }
}`;
                cssEditor.value = currentCSS + responsiveCSS;
                currentCSS = cssEditor.value;
                updatePreview();
            }
        }
        
        function replaceElementImage() {
            if (!contextMenuTarget) return;
            
            const target = contextMenuTarget;
            hideContextMenu();
            
            // Check if element is an image or has background image
            if (target.tagName === 'IMG') {
                // Show image generation dialog for replacement
                showImageGenerationDialog(true);
                // Store target for later use
                window.imageReplacementTarget = target;
            } else {
                // Check for background image
                editElementBackground();
            }
        }
        
        async function aiRefineElement() {
            if (!contextMenuTarget) return;
            
            const target = contextMenuTarget;
            const elementHTML = target.outerHTML;
            hideContextMenu();
            
            // Show loading state
            showToast('🤖 AI refining element...', 2000);
            
            // Gather context
            const designContext = getDesignContext();
            const elementContext = getElementContext(target);
            
            // Create a comprehensive prompt
            const prompt = `Refine this ${elementContext.role} element to better fit the page design.

CURRENT ELEMENT:
${elementHTML}

ELEMENT CONTEXT:
- Role: ${elementContext.role}
- Parent: ${elementContext.parentTag || 'none'}
- Siblings: ${elementContext.siblingCount} other elements
- Layout: ${elementContext.isInFlex ? 'Flexbox' : elementContext.isInGrid ? 'Grid' : 'Block'}

DESIGN SYSTEM:
- Primary colors: ${designContext.colors.slice(0, 3).join(', ')}
- Fonts in use: ${designContext.fonts.join(', ')}
- Body font: ${designContext.bodyFont}

${designContext.brandGuidelines ? `BRAND GUIDELINES:\n${designContext.brandGuidelines}\n` : ''}

REFINEMENT GOALS:
1. Improve visual hierarchy and readability
2. Ensure consistency with other elements on the page
3. Enhance spacing and alignment
4. Make it more modern and professional
5. Maintain semantic HTML and accessibility
6. Keep the same content and functionality

Return ONLY the refined HTML element. Do not include explanations or markdown code blocks.`;
            
            // Send to AI for refinement
            const apiKey = document.getElementById('apiKey').value;
            if (!apiKey) {
                alert('Please add your API key first');
                return;
            }
            
            try {
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`,
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'VibeCoder'
                    },
                    body: JSON.stringify({
                        model: document.getElementById('modelSelect').value,
                        messages: [
                            { role: 'system', content: 'You are an expert web designer specializing in modern, clean UI refinements. You understand design systems, visual hierarchy, and accessibility. You make thoughtful improvements while maintaining consistency with existing designs. Always return valid HTML without markdown formatting.' },
                            { role: 'user', content: prompt }
                        ]
                    })
                });
                
                const data = await response.json();
                let improvedHTML = data.choices[0].message.content;
                
                // Extract HTML from code blocks if present
                if (improvedHTML.includes('```html')) {
                    improvedHTML = improvedHTML.split('```html')[1].split('```')[0].trim();
                } else if (improvedHTML.includes('```')) {
                    improvedHTML = improvedHTML.split('```')[1].split('```')[0].trim();
                }
                
                // Replace the element with improved version
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = improvedHTML.trim();
                const newElement = tempDiv.firstChild;
                
                if (newElement) {
                    target.parentNode.replaceChild(newElement, target);
                    updateHTMLFromPreview();
                    showToast('Element refined by AI', 2000);
                }
            } catch (error) {
                console.error('AI refinement error:', error);
                showToast('❌ AI refinement failed', 2000);
            }
        }
        
        async function aiGenerateAlternative() {
            if (!contextMenuTarget) return;
            
            const target = contextMenuTarget;
            const elementHTML = target.outerHTML;
            hideContextMenu();
            
            // Show loading state
            showToast('Generating alternative...', 2000);
            
            // Gather context
            const designContext = getDesignContext();
            const elementContext = getElementContext(target);
            
            // Determine appropriate variations based on element role
            let variations = '';
            switch(elementContext.role) {
                case 'heading':
                    variations = '1. Bold statement style with larger size\n2. Subtle elegant style with lighter weight\n3. Accented style with color or underline\n4. Compact style with tighter spacing';
                    break;
                case 'button':
                    variations = '1. Solid filled button\n2. Outlined/ghost button\n3. Gradient or animated button\n4. Text-only link style';
                    break;
                case 'card':
                    variations = '1. Elevated card with shadow\n2. Bordered flat card\n3. Gradient or colored card\n4. Minimal no-border card';
                    break;
                case 'paragraph':
                    variations = '1. Emphasized with background\n2. Quote/callout style\n3. Multi-column layout\n4. With decorative elements';
                    break;
                default:
                    variations = '1. Modern minimalist style\n2. Bold and prominent style\n3. Soft and subtle style\n4. Decorated/accented style';
            }
            
            // Create comprehensive prompt
            const prompt = `Generate an alternative version of this ${elementContext.role} element with a different visual style.

CURRENT ELEMENT:
${elementHTML}

ELEMENT CONTEXT:
- Role: ${elementContext.role}
- Current style: ${elementContext.fontSize} font, ${elementContext.color} color
- Parent: ${elementContext.parentTag || 'none'}
- Layout context: ${elementContext.isInFlex ? 'Flexbox' : elementContext.isInGrid ? 'Grid' : 'Block'}

DESIGN TOKENS AVAILABLE:
- Colors: ${designContext.colors.slice(0, 5).join(', ')}
- Fonts: ${designContext.fonts.join(', ')}
- Base font: ${designContext.bodyFont}

${designContext.brandGuidelines ? `BRAND GUIDELINES:\n${designContext.brandGuidelines}\n` : ''}

VARIATION OPTIONS (choose one):
${variations}

REQUIREMENTS:
1. Keep the exact same content and functionality
2. Maintain semantic HTML structure
3. Create a noticeably different visual style
4. Stay within the design system colors and fonts
5. Ensure accessibility is maintained
6. Make it feel fresh but still cohesive with the page

Return ONLY the alternative HTML element. Do not include explanations or markdown code blocks.`;
            
            // Send to AI for alternative
            const apiKey = document.getElementById('apiKey').value;
            if (!apiKey) {
                alert('Please add your API key first');
                return;
            }
            
            try {
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`,
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'VibeCoder'
                    },
                    body: JSON.stringify({
                        model: document.getElementById('modelSelect').value,
                        messages: [
                            { role: 'system', content: 'You are a creative web designer who creates thoughtful variations of UI elements. You understand how to create distinct visual alternatives while maintaining design system consistency and functionality. You respect brand guidelines and accessibility. Always return valid HTML without markdown formatting.' },
                            { role: 'user', content: prompt }
                        ]
                    })
                });
                
                const data = await response.json();
                let alternativeHTML = data.choices[0].message.content;
                
                // Extract HTML from code blocks if present
                if (alternativeHTML.includes('```html')) {
                    alternativeHTML = alternativeHTML.split('```html')[1].split('```')[0].trim();
                } else if (alternativeHTML.includes('```')) {
                    alternativeHTML = alternativeHTML.split('```')[1].split('```')[0].trim();
                }
                
                // Replace with alternative version
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = alternativeHTML.trim();
                const newElement = tempDiv.firstChild;
                
                if (newElement) {
                    target.parentNode.replaceChild(newElement, target);
                    updateHTMLFromPreview();
                    showToast('Alternative generated', 2000);
                }
            } catch (error) {
                console.error('Alternative generation error:', error);
                showToast('❌ Generation failed', 2000);
            }
        }
        
        // Helper function to get value with unit
        function getValueWithUnit(id) {
            const input = document.getElementById(id);
            const unitSelect = document.getElementById(id + 'Unit');
            
            if (!input || !unitSelect) return '';
            
            const unit = unitSelect.value;
            if (unit === 'auto') {
                return 'auto';
            }
            
            const value = input.value;
            return value ? value + unit : '';
        }

        function applyPropertyEdit() {
            if (!contextMenuTarget) return;
            
            const editorContent = document.getElementById('editorContent');
            const title = document.getElementById('editorTitle').textContent;
            
            if (title.includes('Text')) {
                contextMenuTarget.textContent = document.getElementById('textContent').value;
            } else if (title.includes('Size')) {
                // Apply size properties
                const width = getValueWithUnit('elementWidth');
                const height = getValueWithUnit('elementHeight');
                const minWidth = getValueWithUnit('minWidth');
                const minHeight = getValueWithUnit('minHeight');
                const maxWidth = getValueWithUnit('maxWidth');
                const maxHeight = getValueWithUnit('maxHeight');
                
                if (width) contextMenuTarget.style.width = width;
                if (height) contextMenuTarget.style.height = height;
                if (minWidth) contextMenuTarget.style.minWidth = minWidth;
                if (minHeight) contextMenuTarget.style.minHeight = minHeight;
                if (maxWidth) contextMenuTarget.style.maxWidth = maxWidth;
                if (maxHeight) contextMenuTarget.style.maxHeight = maxHeight;
            } else if (title.includes('Styles')) {
                contextMenuTarget.style.color = document.getElementById('styleColor').value;
                contextMenuTarget.style.backgroundColor = document.getElementById('styleBgColor').value;
                
                const fontSize = getValueWithUnit('styleFontSize');
                if (fontSize) contextMenuTarget.style.fontSize = fontSize;
                
                const fontWeight = document.getElementById('styleFontWeight');
                if (fontWeight) contextMenuTarget.style.fontWeight = fontWeight.value;
            } else if (title.includes('Padding')) {
                // Apply padding properties
                const paddingTop = getValueWithUnit('stylePaddingTop');
                const paddingRight = getValueWithUnit('stylePaddingRight');
                const paddingBottom = getValueWithUnit('stylePaddingBottom');
                const paddingLeft = getValueWithUnit('stylePaddingLeft');
                
                if (paddingTop) contextMenuTarget.style.paddingTop = paddingTop;
                if (paddingRight) contextMenuTarget.style.paddingRight = paddingRight;
                if (paddingBottom) contextMenuTarget.style.paddingBottom = paddingBottom;
                if (paddingLeft) contextMenuTarget.style.paddingLeft = paddingLeft;
                
                // Apply margin properties
                const marginTop = getValueWithUnit('styleMarginTop');
                const marginRight = getValueWithUnit('styleMarginRight');
                const marginBottom = getValueWithUnit('styleMarginBottom');
                const marginLeft = getValueWithUnit('styleMarginLeft');
                
                if (marginTop) contextMenuTarget.style.marginTop = marginTop;
                if (marginRight) contextMenuTarget.style.marginRight = marginRight;
                if (marginBottom) contextMenuTarget.style.marginBottom = marginBottom;
                if (marginLeft) contextMenuTarget.style.marginLeft = marginLeft;
                
                // Apply border radius
                const borderRadius = getValueWithUnit('styleBorderRadius');
                if (borderRadius) contextMenuTarget.style.borderRadius = borderRadius;
            } else if (title.includes('Link')) {
                contextMenuTarget.href = document.getElementById('linkHref').value;
                contextMenuTarget.target = document.getElementById('linkTarget').value;
            } else if (title.includes('Background')) {
                contextMenuTarget.style.backgroundColor = document.getElementById('bgColor').value;
                const bgImage = document.getElementById('bgImage').value;
                if (bgImage) {
                    contextMenuTarget.style.backgroundImage = `url(${bgImage})`;
                }
                contextMenuTarget.style.backgroundSize = document.getElementById('bgSize').value;
            }
            
            // Update the HTML editor
            updateHTMLFromPreview();
            
            // Close the editor
            cancelPropertyEdit();
            
            showToast('✅ Element updated successfully!', 2000);
        }
        
        function cancelPropertyEdit() {
            document.getElementById('propertyEditor').style.display = 'none';
            
            // Remove any hover effects when canceling property edit
            const iframeDoc = document.getElementById('previewFrame').contentDocument;
            if (iframeDoc && contextMenuTarget) {
                contextMenuTarget.classList.remove('edit-hover');
                contextMenuTarget.removeAttribute('data-element-type');
            }
            
            contextMenuTarget = null;
        }
        
        function updateHTMLFromPreview() {
            const iframeDoc = document.getElementById('previewFrame').contentDocument;
            const bodyHTML = iframeDoc.body.innerHTML;
            
            // Remove any highlight classes before saving
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = bodyHTML;
            tempDiv.querySelectorAll('.element-highlight').forEach(el => {
                el.classList.remove('element-highlight');
            });
            
            currentHTML = tempDiv.innerHTML;
            document.getElementById('htmlEditor').value = currentHTML;
            generateOxygenJSON();
            saveCurrentConversation();
        }
        
        function rgbToHex(rgb) {
            if (!rgb || rgb === 'rgba(0, 0, 0, 0)' || rgb === 'transparent') {
                return '#ffffff';
            }
            
            const result = rgb.match(/\d+/g);
            if (!result) return '#000000';
            
            const r = parseInt(result[0]);
            const g = parseInt(result[1]);
            const b = parseInt(result[2]);
            
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function generateOxygenJSON() {
            // Create Oxygen JSON structure with code block
            currentJSON = {
                "id": 0,
                "name": "root",
                "children": [{
                    "id": 1,
                    "name": "ct_code_block",
                    "options": {
                        "ct_id": 1,
                        "ct_parent": 0,
                        "selector": `code_block-1-${postId}`,
                        "original": {
                            "code-php": currentHTML,
                            "code-css": currentCSS,
                            "code-js": currentJS || ""
                        }
                    }
                }]
            };
            
            document.getElementById('jsonOutput').textContent = JSON.stringify(currentJSON, null, 2);
        }

        let currentDevice = 'desktop';
        let isFullscreen = false;
        let isChatVisible = false;
        
        function toggleFullscreenChat() {
            const floatingWrapper = document.getElementById('floatingChatWrapper');
            if (!floatingWrapper) {
                console.log('No floating wrapper found');
                return;
            }
            
            isChatVisible = !isChatVisible;
            floatingWrapper.style.display = isChatVisible ? 'block' : 'none';
            
            // Update toggle button icon opacity
            const toggleBtn = document.getElementById('chatToggleBtn');
            if (toggleBtn) {
                toggleBtn.style.opacity = isChatVisible ? '1' : '0.7';
            }
        }
        
        function toggleFullscreen() {
            const previewFrame = document.getElementById('previewFrame');
            const mainContainer = document.querySelector('.main-container');
            const header = document.querySelector('.header');
            
            if (!isFullscreen) {
                // Enter fullscreen mode
                isFullscreen = true;
                isChatVisible = false; // Start with chat hidden
                
                // Create fullscreen container
                const fullscreenContainer = document.createElement('div');
                fullscreenContainer.id = 'fullscreenContainer';
                fullscreenContainer.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: white;
                    z-index: 99999;
                    display: flex;
                    flex-direction: column;
                `;
                
                // Create exit button bar
                const exitBar = document.createElement('div');
                exitBar.style.cssText = `
                    background: #ffffff;
                    border-bottom: 1px solid #e4e4e7;
                    padding: 10px 20px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
                `;
                
                // Add title and buttons
                exitBar.innerHTML = `
                    <div style="color: #09090b; font-weight: 600; font-size: 14px;">
                        🖥️ Fullscreen Preview Mode
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button id="chatToggleBtn" onclick="toggleFullscreenChat()" style="
                            background: #f4f4f5;
                            color: #71717a;
                            border: 1px solid #e4e4e7;
                            padding: 8px 16px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 16px;
                            transition: all 0.2s ease;
                        " onmouseover="this.style.background='#e4e4e7';this.style.color='#09090b'" 
                           onmouseout="this.style.background='#f4f4f5';this.style.color='#71717a'"
                           title="Toggle Chat">
                            💬
                        </button>
                        <button onclick="toggleFullscreen()" style="
                            background: #09090b;
                            color: white;
                            border: none;
                            padding: 8px 16px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-weight: bold;
                            font-size: 14px;
                            display: flex;
                            align-items: center;
                            gap: 8px;
                            transition: all 0.2s;
                        " onmouseover="this.style.background='#27272a'" onmouseout="this.style.background='#09090b'">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3" />
                            </svg>
                            Exit Fullscreen
                        </button>
                    </div>
                `;
                
                // Create iframe container
                const iframeContainer = document.createElement('div');
                iframeContainer.style.cssText = `
                    flex: 1;
                    position: relative;
                    overflow: hidden;
                `;
                
                // Clone the preview frame
                const fullscreenFrame = document.createElement('iframe');
                fullscreenFrame.id = 'fullscreenFrame';
                fullscreenFrame.style.cssText = `
                    width: 100%;
                    height: 100%;
                    border: none;
                    background: white;
                `;
                
                // Assemble fullscreen view first (iframe needs to be in DOM to access contentDocument)
                iframeContainer.appendChild(fullscreenFrame);
                fullscreenContainer.appendChild(exitBar);
                fullscreenContainer.appendChild(iframeContainer);
                
                // Attach the existing chat window to fullscreen mode BEFORE appending to body
                attachChatToFullscreen(fullscreenContainer);
                
                document.body.appendChild(fullscreenContainer);
                
                // Now copy content to fullscreen frame after it's in the DOM
                setTimeout(() => {
                    const originalDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
                    const fullDoc = fullscreenFrame.contentDocument || fullscreenFrame.contentWindow.document;
                    
                    if (fullDoc && originalDoc) {
                        fullDoc.open();
                        fullDoc.write(originalDoc.documentElement.outerHTML);
                        fullDoc.close();
                    }
                }, 100);
                
                // Hide main UI
                mainContainer.style.display = 'none';
                header.style.display = 'none';
                
                // Add escape key listener
                document.addEventListener('keydown', handleFullscreenEscape);
                
                // Update button icon
                const fullscreenBtn = document.getElementById('fullscreenBtn');
                fullscreenBtn.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3" />
                    </svg>
                `;
                
            } else {
                // Exit fullscreen mode
                exitFullscreen();
            }
        }
        
        function exitFullscreen() {
            isFullscreen = false;
            isChatVisible = false;
            
            // Restore chat to original position BEFORE removing fullscreen container
            restoreChatToOriginal();
            
            // Remove fullscreen container
            const fullscreenContainer = document.getElementById('fullscreenContainer');
            if (fullscreenContainer) {
                fullscreenContainer.remove();
            }
            
            // Show main UI
            const mainContainer = document.querySelector('.main-container');
            const header = document.querySelector('.header');
            mainContainer.style.display = '';
            header.style.display = '';
            
            // Remove escape key listener
            document.removeEventListener('keydown', handleFullscreenEscape);
            
            // Update button icon back to expand
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            fullscreenBtn.innerHTML = `
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" />
                </svg>
            `;
        }
        
        function handleFullscreenEscape(e) {
            if (e.key === 'Escape' && isFullscreen) {
                exitFullscreen();
            }
        }
        
        function setDevice(device) {
            currentDevice = device;
            
            // Update toggle buttons
            document.querySelectorAll('.device-toggle').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.closest('.device-toggle').classList.add('active');
            
            // Update iframe class
            const iframe = document.getElementById('previewFrame');
            iframe.className = 'preview-frame ' + device;
            
            // Add device frame styling for mobile/tablet
            const previewContent = iframe.parentElement;
            if (device === 'mobile' || device === 'tablet') {
                previewContent.style.background = '#e0e0e0';
                iframe.style.boxShadow = '0 10px 50px rgba(0,0,0,0.2)';
            } else {
                previewContent.style.background = '#f5f5f5';
                iframe.style.boxShadow = 'none';
            }
        }
        
        function switchTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.preview-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            // Hide all content
            document.getElementById('previewFrame').style.display = 'none';
            document.getElementById('htmlEditor').style.display = 'none';
            document.getElementById('cssEditor').style.display = 'none';
            document.getElementById('jsEditor').style.display = 'none';
            document.getElementById('jsonOutput').style.display = 'none';
            
            // Show selected content
            switch(tab) {
                case 'preview':
                    document.getElementById('previewFrame').style.display = 'block';
                    break;
                case 'html':
                    document.getElementById('htmlEditor').style.display = 'block';
                    break;
                case 'css':
                    document.getElementById('cssEditor').style.display = 'block';
                    break;
                case 'js':
                    document.getElementById('jsEditor').style.display = 'block';
                    break;
                case 'json':
                    document.getElementById('jsonOutput').style.display = 'block';
                    break;
            }
        }

        function refreshPreview() {
            currentHTML = document.getElementById('htmlEditor').value;
            currentCSS = document.getElementById('cssEditor').value;
            currentJS = document.getElementById('jsEditor').value;
            updatePreview();
            generateOxygenJSON();
        }

        function clearAll() {
            if (confirm('Clear chat conversation history? (Your code will be preserved)')) {
                // Only clear conversation history and chat display
                conversationHistory = [];
                localStorage.removeItem('vibe_coder_conversations');
                localStorage.removeItem('vibe_coder_current_conversation');
                
                // Reset chat display with suggestions
                const isCollapsed = localStorage.getItem('vibe_suggestions_collapsed') === 'true';
                document.getElementById('chatMessages').innerHTML = `
                    <div class="prompt-suggestions ${isCollapsed ? 'collapsed' : ''}" id="promptSuggestions">
                        <div class="suggestions-header" onclick="toggleSuggestions()" style="cursor: pointer;">
                            <span class="suggestions-label">💡 Quick starts</span>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <button class="add-suggestion-btn" onclick="event.stopPropagation(); showAddSuggestionDialog()" title="Add custom quick start" style="background: none; border: none; color: #71717a; cursor: pointer; padding: 4px; display: flex; align-items: center; font-size: 16px;">+</button>
                                <svg class="suggestions-toggle" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="6 9 12 15 18 9"></polyline>
                                </svg>
                            </div>
                        </div>
                        <div class="suggestions-grid" id="suggestionsGrid">
                        </div>
                    </div>
                `;
                
                // Load suggestions
                loadSuggestions();
                
                // Apply collapsed state icon if needed
                if (isCollapsed) {
                    const toggleIcon = document.querySelector('.suggestions-toggle');
                    if (toggleIcon) {
                        toggleIcon.style.transform = 'rotate(-90deg)';
                    }
                }
                
                // Show success message
                showToast('✅ Chat history cleared. Your code has been preserved.', 3000);
                
                // Note: We keep currentHTML and currentCSS intact
                // The preview and code editors maintain their content
            }
        }

        function exportToOxygen() {
            const jsonText = JSON.stringify(currentJSON, null, 2);
            navigator.clipboard.writeText(jsonText).then(() => {
                alert('Oxygen JSON copied to clipboard! You can now paste it into Oxygen Builder.');
            }).catch(() => {
                alert('Failed to copy to clipboard. Please copy manually from the JSON tab.');
            });
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        function toggleSuggestions() {
            const container = document.getElementById('promptSuggestions');
            const toggleIcon = container.querySelector('.suggestions-toggle');
            
            if (container) {
                container.classList.toggle('collapsed');
                const isCollapsed = container.classList.contains('collapsed');
                
                // Update icon rotation
                if (toggleIcon) {
                    toggleIcon.style.transform = isCollapsed ? 'rotate(-90deg)' : 'rotate(0deg)';
                }
                
                // Save state to localStorage
                localStorage.setItem('vibe_suggestions_collapsed', isCollapsed);
            }
        }

        function useSuggestion(textElement) {
            // Get the text content from the text span
            let text = textElement.textContent.trim();
            
            // Remove emoji by finding first letter/number
            const firstLetterIndex = text.search(/[a-zA-Z0-9]/);
            if (firstLetterIndex > 0) {
                text = text.substring(firstLetterIndex).trim();
            }
            
            document.getElementById('userInput').value = text;
            document.getElementById('userInput').focus();
        }
        
        // Default suggestions
        const defaultSuggestions = [
            { emoji: '🏗️', text: 'Build landing page with sections', tooltip: 'Start with a complete page structure' },
            { emoji: '📸', text: 'Recreate from my screenshot', tooltip: 'Upload a screenshot to recreate' },
            { emoji: '🔧', text: 'Debug and improve my code', tooltip: 'Fix issues in existing code' },
            { emoji: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>', text: 'Add dark mode to my site', tooltip: 'Add new functionality' },
            { emoji: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2"><rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line></svg>', text: 'Make my design mobile-friendly', tooltip: 'Make responsive for all devices' },
            { emoji: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M12 2v20"></path><path d="M12 2a10 10 0 0 1 0 20"></path></svg>', text: 'Add animations and effects', tooltip: 'Add smooth animations' },
            { emoji: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>', text: 'Convert HTML to Oxygen', tooltip: 'Convert to Oxygen format' },
            { emoji: '⚡', text: 'Optimize for speed and SEO', tooltip: 'Improve performance' }
        ];
        
        function loadSuggestions() {
            const grid = document.getElementById('suggestionsGrid');
            if (!grid) return;
            
            // Load custom suggestions from localStorage
            const customSuggestions = JSON.parse(localStorage.getItem('vibe_custom_suggestions') || '[]');
            
            // Clear grid
            grid.innerHTML = '';
            
            // Add all suggestions (custom first, then defaults)
            const allSuggestions = [...customSuggestions, ...defaultSuggestions];
            
            allSuggestions.forEach((suggestion, index) => {
                const chip = document.createElement('span');
                chip.className = 'suggestion-chip';
                chip.title = suggestion.tooltip || suggestion.text;
                
                // Add custom class for custom suggestions
                if (index < customSuggestions.length) {
                    chip.className += ' custom';
                }
                
                // Create text span for the suggestion content
                const textSpan = document.createElement('span');
                textSpan.textContent = `${suggestion.emoji} ${suggestion.text}`;
                chip.appendChild(textSpan);
                
                // Set onclick on the chip but only use the text span content
                chip.onclick = function() { 
                    useSuggestion(textSpan); 
                };
                
                // Add delete button for custom suggestions
                if (index < customSuggestions.length) {
                    const deleteBtn = document.createElement('span');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.innerHTML = '🗑';  // Trash icon
                    deleteBtn.title = 'Delete this quick start';
                    deleteBtn.onclick = function(e) {
                        e.stopPropagation();
                        deleteSuggestion(index);
                    };
                    chip.appendChild(deleteBtn);
                }
                
                grid.appendChild(chip);
            });
        }
        
        function deleteSuggestion(index) {
            const customSuggestions = JSON.parse(localStorage.getItem('vibe_custom_suggestions') || '[]');
            customSuggestions.splice(index, 1);
            localStorage.setItem('vibe_custom_suggestions', JSON.stringify(customSuggestions));
            loadSuggestions();
        }
        
        function showAddSuggestionDialog() {
            // Create dialog overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            // Create dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white;
                border-radius: 8px;
                padding: 24px;
                max-width: 400px;
                width: 90%;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 16px 0; color: #09090b;">Add Custom Quick Start</h3>
                <div style="margin-bottom: 12px;">
                    <label style="display: block; font-size: 13px; color: #71717a; margin-bottom: 4px;">Emoji (optional)</label>
                    <input type="text" id="suggestionEmoji" placeholder="🚀" maxlength="2" style="width: 60px; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px;">
                </div>
                <div style="margin-bottom: 12px;">
                    <label style="display: block; font-size: 13px; color: #71717a; margin-bottom: 4px;">Text *</label>
                    <input type="text" id="suggestionText" placeholder="Create a pricing table" style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px;">
                </div>
                <div style="margin-bottom: 16px;">
                    <label style="display: block; font-size: 13px; color: #71717a; margin-bottom: 4px;">Tooltip (optional)</label>
                    <input type="text" id="suggestionTooltip" placeholder="Build a responsive pricing section" style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px;">
                </div>
                <div style="display: flex; gap: 8px; justify-content: flex-end;">
                    <button id="cancelSuggestionBtn" style="padding: 8px 16px; background: white; border: 1px solid #e4e4e7; border-radius: 6px; cursor: pointer;">Cancel</button>
                    <button id="addSuggestionBtn" style="padding: 8px 16px; background: #09090b; color: white; border: none; border-radius: 6px; cursor: pointer;">Add</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Add overlay ID for easy removal
            overlay.id = 'suggestionDialogOverlay';
            
            // Add event listeners to buttons
            document.getElementById('cancelSuggestionBtn').onclick = function() {
                document.getElementById('suggestionDialogOverlay').remove();
            };
            
            document.getElementById('addSuggestionBtn').onclick = function() {
                addCustomSuggestion();
            };
            
            // Focus on text input
            setTimeout(() => {
                document.getElementById('suggestionText').focus();
            }, 100);
        }
        
        function addCustomSuggestion() {
            const emoji = document.getElementById('suggestionEmoji').value || '💡';
            const text = document.getElementById('suggestionText').value.trim();
            const tooltip = document.getElementById('suggestionTooltip').value.trim();
            
            if (!text) {
                alert('Please enter the quick start text');
                return;
            }
            
            // Get existing custom suggestions
            const customSuggestions = JSON.parse(localStorage.getItem('vibe_custom_suggestions') || '[]');
            
            // Add new suggestion
            customSuggestions.push({ emoji, text, tooltip: tooltip || text });
            
            // Save to localStorage
            localStorage.setItem('vibe_custom_suggestions', JSON.stringify(customSuggestions));
            
            // Reload suggestions
            loadSuggestions();
            
            // Close dialog
            document.getElementById('suggestionDialogOverlay').remove();
        }
        
        function setMode(mode) {
            currentMode = mode;
            document.getElementById('addModeBtn').classList.toggle('active', mode === 'add');
            document.getElementById('editModeBtn').classList.toggle('active', mode === 'edit');
            document.getElementById('referenceModeBtn').classList.toggle('active', mode === 'reference');
            document.getElementById('planModeBtn').classList.toggle('active', mode === 'plan');
            
            // Update floating chat mode buttons if they exist
            const floatingChat = document.getElementById('floatingChat');
            if (floatingChat) {
                const modeButtons = floatingChat.querySelectorAll('.mode-button');
                modeButtons.forEach(btn => {
                    const btnMode = btn.textContent.includes('Add') ? 'add' : 
                                  btn.textContent.includes('Edit') ? 'edit' : 
                                  btn.textContent.includes('Reference') ? 'reference' : '';
                    if (btnMode) {
                        const isActive = btnMode === mode;
                        btn.style.background = isActive ? 'linear-gradient(135deg, #667eea, #764ba2)' : '#f0f0f0';
                        btn.style.color = isActive ? 'white' : '#333';
                    }
                });
            }
            
            // Show/hide UI elements based on mode
            // Hide element picker button - we'll auto-enable it in edit mode
            document.getElementById('elementPickerBtn').style.display = 'none';
            document.getElementById('referenceInput').style.display = mode === 'reference' ? 'flex' : 'none';
            
            // Clear selection effects when changing modes (except when entering edit mode)
            if (mode !== 'edit') {
                clearSelectionEffects();
                // Disable element picker if it was active
                if (elementPickerActive) {
                    elementPickerActive = false;
                    disableElementPicker();
                }
            }
            
            // Update placeholder text
            const textarea = document.getElementById('userInput');
            if (mode === 'add') {
                textarea.placeholder = "Describe what you want to add... (e.g., 'Add a footer with contact information')";
                // Reset selected element when switching to add mode
                selectedElement = null;
            } else if (mode === 'edit') {
                // Automatically enable element picker when entering edit mode
                if (!elementPickerActive && !selectedElement) {
                    elementPickerActive = true;
                    enableElementPicker();
                }
                textarea.placeholder = selectedElement ? 
                    `Describe how to edit the selected ${selectedElement.tag}...` :
                    "Click on an element in the preview to select it...";
            } else if (mode === 'reference') {
                textarea.placeholder = "Enter a URL above, then describe what you want to recreate (e.g., 'Create a similar hero section')";
                // Reset selected element
                selectedElement = null;
            } else if (mode === 'plan') {
                textarea.placeholder = "Describe your website project... I'll help you plan it step by step before we start building.";
                // Reset selected element
                selectedElement = null;
            }
            
            // Clear reference data when leaving reference mode
            if (mode !== 'reference') {
                referenceData = null;
            }
            
            // Reset plan mode when switching away
            if (mode !== 'plan') {
                isPlanMode = false;
                // Don't clear tasks if we're actively working on them
                if (currentTaskIndex === 0 || currentTaskIndex >= plannedTasks.length) {
                    plannedTasks = [];
                    currentTaskIndex = 0;
                }
            }
        }
        
        function showToast(message, duration = 3000) {
            // Remove any existing toast
            const existingToast = document.getElementById('elementPickerToast');
            if (existingToast) {
                existingToast.remove();
            }
            
            // Create toast element
            const toast = document.createElement('div');
            toast.id = 'elementPickerToast';
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #09090b;
                color: white;
                padding: 10px 16px;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                border: 1px solid #27272a;
                z-index: 100001;
                font-size: 14px;
                font-weight: 500;
                animation: slideDown 0.3s ease-out;
            `;
            
            toast.innerHTML = `<span>${message}</span>`;
            
            // Add animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideDown {
                    from {
                        opacity: 0;
                        transform: translateX(-50%) translateY(-20px);
                    }
                    to {
                        opacity: 1;
                        transform: translateX(-50%) translateY(0);
                    }
                }
                @keyframes slideUp {
                    from {
                        opacity: 1;
                        transform: translateX(-50%) translateY(0);
                    }
                    to {
                        opacity: 0;
                        transform: translateX(-50%) translateY(-20px);
                    }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(toast);
            
            // Auto-remove after duration
            setTimeout(() => {
                toast.style.animation = 'slideUp 0.3s ease-out';
                setTimeout(() => {
                    toast.remove();
                }, 300);
            }, duration);
        }
        
        function updateSelectedElementDisplay() {
            if (!selectedElement) {
                return;
            }
            
            // Add ESC key handler for canceling selection
            if (!window.elementSelectionEscapeHandler) {
                window.elementSelectionEscapeHandler = (e) => {
                    if (e.key === 'Escape' && selectedElement && currentMode === 'edit') {
                        e.preventDefault();
                        clearSelectionEffects();
                        selectedElement = null;
                        
                        // Update placeholder text
                        const textarea = document.getElementById('userInput');
                        if (textarea) {
                            textarea.placeholder = "Click on an element in the preview to select it...";
                        }
                        
                        // Remove selection message
                        const selectionMsg = document.querySelector('.element-selection-message');
                        if (selectionMsg) {
                            selectionMsg.remove();
                        }
                        
                        // Show toast
                        showToast('Selection cancelled • Click another element to select', 2000);
                        
                        // Remove the handler
                        document.removeEventListener('keydown', window.elementSelectionEscapeHandler);
                        delete window.elementSelectionEscapeHandler;
                    }
                };
                document.addEventListener('keydown', window.elementSelectionEscapeHandler);
            }
            
            // Also show in chat messages area when in edit mode
            if (currentMode === 'edit') {
                // Check if there's already a selected element message
                let selectionMsg = document.querySelector('.element-selection-message');
                if (!selectionMsg) {
                    selectionMsg = document.createElement('div');
                    selectionMsg.className = 'element-selection-message';
                    selectionMsg.style.cssText = `
                        background: #f4f4f5;
                        border: 1px solid #e4e4e7;
                        border-radius: 8px;
                        padding: 12px;
                        margin: 10px;
                        display: flex;
                        align-items: center;
                        gap: 10px;
                    `;
                    
                    const chatMessages = document.getElementById('chatMessages');
                    chatMessages.appendChild(selectionMsg);
                }
                
                selectionMsg.innerHTML = `
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#71717a" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path d="M12 1v6m0 6v6m11-11h-6m-6 0H1"></path>
                </svg>
                    <div style="flex: 1;">
                        <div style="font-size: 12px; color: #71717a; font-weight: 600;">Selected Element</div>
                        <div style="font-size: 14px; color: #09090b; margin-top: 4px;">
                            <code style="background: white; padding: 2px 6px; border-radius: 4px; border: 1px solid #e4e4e7;">${selectedElement.selector}</code>
                        </div>
                        ${selectedElement.text ? `<div style="font-size: 12px; color: #a1a1aa; margin-top: 4px; font-style: italic;">"${selectedElement.text.substring(0, 50)}${selectedElement.text.length > 50 ? '...' : ''}"</div>` : ''}
                    </div>
                    <div style="font-size: 11px; color: #a1a1aa; white-space: nowrap;">
                        Press ESC to cancel
                    </div>
                `;
            }
        }
        
        function clearSelectionEffects() {
            const previewFrame = document.getElementById('previewFrame');
            if (!previewFrame) return;
            
            const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
            if (!iframeDoc) return;
            
            // Remove selection class
            iframeDoc.querySelectorAll('.element-selected').forEach(el => {
                el.classList.remove('element-selected');
            });
            
            // Remove fade overlay
            const overlay = iframeDoc.querySelector('.editing-fade-overlay');
            if (overlay) {
                overlay.remove();
            }
            
            // Remove selection message from chat
            const selectionMsg = document.querySelector('.element-selection-message');
            if (selectionMsg) {
                selectionMsg.remove();
            }
            
            // Clean up ESC key handler for element selection
            if (window.elementSelectionEscapeHandler) {
                document.removeEventListener('keydown', window.elementSelectionEscapeHandler);
                delete window.elementSelectionEscapeHandler;
            }
        }
        
        function toggleElementPicker() {
            elementPickerActive = !elementPickerActive;
            const btn = document.getElementById('elementPickerBtn');
            btn.classList.toggle('active', elementPickerActive);
            
            if (elementPickerActive) {
                setMode('edit'); // Switch to edit mode when picking elements
                enableElementPicker();
            } else {
                disableElementPicker();
            }
        }
        
        function enableElementPicker() {
            const previewFrame = document.getElementById('previewFrame');
            const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
            
            // Show toast with ESC shortcut info
            showToast('Click an element to select it • Press ESC to cancel', 4000);
            
            // Add ESC key listener
            const escapeHandler = (e) => {
                if (e.key === 'Escape' && elementPickerActive) {
                    e.preventDefault();
                    elementPickerActive = false;
                    const btn = document.getElementById('elementPickerBtn');
                    btn.classList.remove('active');
                    disableElementPicker();
                    showToast('Selection cancelled', 2000);
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
            
            // Store the handler so we can remove it later
            window.elementPickerEscapeHandler = escapeHandler;
            
            // Create overlay
            let overlay = iframeDoc.getElementById('elementPickerOverlay');
            if (!overlay) {
                overlay = iframeDoc.createElement('div');
                overlay.id = 'elementPickerOverlay';
                overlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 9999;
                    pointer-events: none;
                `;
                iframeDoc.body.appendChild(overlay);
            }
            
            // Add hover effect to all elements
            const style = iframeDoc.createElement('style');
            style.id = 'elementPickerStyles';
            style.textContent = `
                body * {
                    cursor: crosshair !important;
                    position: relative;
                }
                body *:hover {
                    outline: 2px dashed #09090b !important;
                    background-color: rgba(9, 9, 11, 0.05) !important;
                }
                .element-selected {
                    position: relative !important;
                    z-index: 10001 !important;
                    border: 3px dashed white !important;
                    box-shadow: 
                        inset 0 0 0 1px rgba(0, 0, 0, 0.2),
                        0 0 0 1px rgba(0, 0, 0, 0.2),
                        0 0 20px rgba(255, 255, 255, 0.8) !important;
                    animation: pulseSelection 1.5s ease-in-out infinite !important;
                }
                @keyframes pulseSelection {
                    0%, 100% {
                        border-color: white;
                        box-shadow: 
                            inset 0 0 0 1px rgba(0, 0, 0, 0.2),
                            0 0 0 1px rgba(0, 0, 0, 0.2),
                            0 0 20px rgba(255, 255, 255, 0.8);
                    }
                    50% {
                        border-color: rgba(255, 255, 255, 0.8);
                        box-shadow: 
                            inset 0 0 0 1px rgba(0, 0, 0, 0.3),
                            0 0 0 1px rgba(0, 0, 0, 0.3),
                            0 0 30px rgba(255, 255, 255, 1);
                    }
                }
                .editing-fade-overlay {
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(255, 255, 255, 0.8);
                    z-index: 10000;
                    pointer-events: none;
                }
            `;
            iframeDoc.head.appendChild(style);
            
            // Add click handlers to all elements
            iframeDoc.body.addEventListener('click', handleElementClick, true);
            iframeDoc.body.addEventListener('mouseover', handleElementHover, true);
        }
        
        function disableElementPicker() {
            const previewFrame = document.getElementById('previewFrame');
            const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
            
            // Remove ESC key listener if it exists
            if (window.elementPickerEscapeHandler) {
                document.removeEventListener('keydown', window.elementPickerEscapeHandler);
                delete window.elementPickerEscapeHandler;
            }
            
            // Remove overlay
            const overlay = iframeDoc.getElementById('elementPickerOverlay');
            if (overlay) overlay.remove();
            
            // Remove styles
            const style = iframeDoc.getElementById('elementPickerStyles');
            if (style) style.remove();
            
            // Remove event listeners
            iframeDoc.body.removeEventListener('click', handleElementClick, true);
            iframeDoc.body.removeEventListener('mouseover', handleElementHover, true);
        }
        
        function handleElementClick(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const element = e.target;
            const tagName = element.tagName.toLowerCase();
            const classes = element.className ? `.${element.className.split(' ').filter(c => c !== 'element-selected' && c !== 'editing-label').join('.')}` : '';
            const id = element.id ? `#${element.id}` : '';
            
            // Store selected element info
            selectedElement = {
                element: element,
                tag: tagName,
                selector: tagName + id + classes,
                html: element.outerHTML,
                text: element.textContent.substring(0, 50)
            };
            
            // Update UI
            updateSelectedElementDisplay();
            
            // Remove toast if it exists
            const toast = document.getElementById('elementPickerToast');
            if (toast) {
                toast.remove();
            }
            
            // Keep element picker active but update placeholder
            const textarea = document.getElementById('userInput');
            if (textarea) {
                textarea.placeholder = `Describe how to edit the selected ${selectedElement.tag}...`;
                textarea.focus();
            }
            
            // Remove previous selection and effects
            const previewFrame = document.getElementById('previewFrame');
            const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
            
            // Remove previous selection
            iframeDoc.querySelectorAll('.element-selected').forEach(el => {
                el.classList.remove('element-selected');
            });
            
            // Remove previous fade overlay
            const existingOverlay = iframeDoc.querySelector('.editing-fade-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
            
            // Remove previous editing label
            const existingLabel = iframeDoc.querySelector('.editing-label');
            if (existingLabel) {
                existingLabel.remove();
            }
            
            // Add fade overlay
            const fadeOverlay = iframeDoc.createElement('div');
            fadeOverlay.className = 'editing-fade-overlay';
            iframeDoc.body.appendChild(fadeOverlay);
            
            // Add selection class
            element.classList.add('element-selected');
            
            // Disable picker
            toggleElementPicker();
            
            // Update placeholder
            document.getElementById('userInput').placeholder = `Describe how to edit the selected ${tagName}...`;
            document.getElementById('userInput').focus();
        }
        
        function handleElementHover(e) {
            // Could add hover tooltip here if needed
        }
        
        async function fetchReference() {
            const urlInput = document.getElementById('referenceUrl');
            const url = urlInput.value.trim();
            
            if (!url) {
                alert('Please enter a valid URL');
                return;
            }
            
            // Validate URL format
            try {
                new URL(url);
            } catch (e) {
                alert('Please enter a valid URL (e.g., https://example.com)');
                return;
            }
            
            const fetchBtn = document.querySelector('.fetch-button');
            fetchBtn.disabled = true;
            fetchBtn.textContent = '⏳ Fetching...';
            
            showMessage('assistant', `🔍 Fetching and analyzing ${url}...`);
            
            try {
                // Use CORS proxy to fetch the website
                const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                
                const response = await fetch(proxyUrl);
                const data = await response.json();
                
                if (data.status.http_code !== 200) {
                    throw new Error('Failed to fetch the website');
                }
                
                // Parse the HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(data.contents, 'text/html');
                
                // Extract the main structure
                const bodyHTML = doc.body ? doc.body.innerHTML : '';
                
                // Extract styles
                const styles = Array.from(doc.querySelectorAll('style')).map(s => s.textContent).join('\n');
                const linkedStyles = Array.from(doc.querySelectorAll('link[rel="stylesheet"]')).map(l => `/* External CSS: ${l.href} */`).join('\n');
                
                // Store reference data
                referenceData = {
                    url: url,
                    html: bodyHTML,
                    css: styles + '\n' + linkedStyles,
                    title: doc.title || 'Untitled'
                };
                
                showToast(`✅ Successfully fetched "${referenceData.title}"`, 3000);
                showMessage('assistant', 'The website structure has been loaded as reference. Now describe what elements you want to recreate.');
                
                // Focus on the input
                document.getElementById('userInput').focus();
                
            } catch (error) {
                console.error('Fetch error:', error);
                showMessage('assistant', `❌ Error fetching website: ${error.message}. As an alternative, you can describe the design you want to recreate manually.`);
                
                // Fallback: Let user describe manually
                referenceData = {
                    url: url,
                    html: null,
                    css: null,
                    manual: true
                };
            } finally {
                fetchBtn.disabled = false;
                fetchBtn.textContent = '🌐 Fetch & Analyze';
            }
        }
        
        let attachedImageData = null;
        
        // Function to compress and resize images
        async function compressAndResizeImage(dataUrl, maxWidth = 1024, maxHeight = 1024, quality = 0.85) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    // Calculate new dimensions while maintaining aspect ratio
                    let width = img.width;
                    let height = img.height;
                    
                    if (width > maxWidth || height > maxHeight) {
                        const aspectRatio = width / height;
                        
                        if (width > height) {
                            width = maxWidth;
                            height = Math.round(maxWidth / aspectRatio);
                        } else {
                            height = maxHeight;
                            width = Math.round(maxHeight * aspectRatio);
                        }
                    }
                    
                    // Create canvas for resizing
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert to JPEG with compression
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    
                    console.log(`Image compressed: ${img.width}x${img.height} -> ${width}x${height}, Size reduction: ${Math.round((1 - compressedDataUrl.length / dataUrl.length) * 100)}%`);
                    
                    resolve(compressedDataUrl);
                };
                img.src = dataUrl;
            });
        }
        
        function attachImage() {
            document.getElementById('imageInput').click();
        }
        
        function handleImageSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                // Compress the image before storing
                const uncompressedData = e.target.result;
                attachedImageData = await compressAndResizeImage(uncompressedData, 1024, 1024, 0.85);
                
                // Show indicator that image is attached
                const attachBtn = document.querySelector('.attach-image-button');
                attachBtn.style.background = '#667eea';
                attachBtn.style.color = 'white';
                attachBtn.innerHTML = '✅';
                
                // Add a note in the textarea
                const textarea = document.getElementById('userInput');
                if (!textarea.value.includes('[Image attached]')) {
                    textarea.value += textarea.value ? '\n[Image attached]' : '[Image attached]';
                }
                
                showMessage('assistant', '📎 Image attached and compressed! Add your message and send.');
            };
            reader.readAsDataURL(file);
        }
        
        async function screenshotWithPrompt() {
            // First take the screenshot
            const imageData = await captureScreenshot();
            if (!imageData) return;
            
            // Show a prompt dialog for custom instructions
            const userPrompt = prompt('What would you like me to do with this screenshot?', 
                'Analyze this design and suggest improvements for better UI/UX');
            
            if (!userPrompt) return;
            
            // Send the screenshot with custom prompt
            await sendMessageWithImage(imageData, userPrompt);
        }
        
        async function captureScreenshot() {
            const previewFrame = document.getElementById('previewFrame');
            
            try {
                showToast('📸 Capturing preview screenshot...', 2000);
                
                // Use html2canvas library to capture the iframe content
                if (typeof html2canvas === 'undefined') {
                    await loadHtml2Canvas();
                }
                
                const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
                const clonedBody = iframeDoc.body.cloneNode(true);
                
                const tempContainer = document.createElement('div');
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px';
                tempContainer.style.width = previewFrame.offsetWidth + 'px';
                tempContainer.innerHTML = clonedBody.innerHTML;
                
                const styleElement = document.createElement('style');
                const styles = iframeDoc.head.querySelector('style');
                if (styles) {
                    styleElement.textContent = styles.textContent;
                    tempContainer.appendChild(styleElement);
                }
                
                document.body.appendChild(tempContainer);
                
                const canvas = await html2canvas(tempContainer, {
                    width: previewFrame.offsetWidth,
                    height: previewFrame.offsetHeight,
                    backgroundColor: '#ffffff',
                    logging: false
                });
                
                document.body.removeChild(tempContainer);
                
                // Compress the screenshot before returning
                const uncompressedDataUrl = canvas.toDataURL('image/png');
                const compressedDataUrl = await compressAndResizeImage(uncompressedDataUrl, 1024, 1024, 0.85);
                
                return compressedDataUrl;
            } catch (error) {
                console.error('Screenshot error:', error);
                showToast('❌ Failed to capture screenshot. Please try again.', 3000);
                return null;
            }
        }
        
        async function screenshotAndFix() {
            const previewFrame = document.getElementById('previewFrame');
            
            try {
                // Show loading state
                document.getElementById('sendButton').disabled = true;
                document.getElementById('loadingIndicator').classList.add('active');
                showToast('📸 Capturing preview screenshot...', 2000);
                
                // Use html2canvas library to capture the iframe content
                // First, we need to inject html2canvas if not already loaded
                if (typeof html2canvas === 'undefined') {
                    await loadHtml2Canvas();
                }
                
                // Get the iframe document
                const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
                
                // Clone the iframe content to capture it
                const clonedBody = iframeDoc.body.cloneNode(true);
                
                // Create a temporary container
                const tempContainer = document.createElement('div');
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px';
                tempContainer.style.width = previewFrame.offsetWidth + 'px';
                tempContainer.innerHTML = clonedBody.innerHTML;
                
                // Add the styles from iframe
                const styleElement = document.createElement('style');
                const styles = iframeDoc.head.querySelector('style');
                if (styles) {
                    styleElement.textContent = styles.textContent;
                    tempContainer.appendChild(styleElement);
                }
                
                document.body.appendChild(tempContainer);
                
                // Capture using html2canvas
                const canvas = await html2canvas(tempContainer, {
                    width: previewFrame.offsetWidth,
                    height: previewFrame.offsetHeight,
                    scale: 1,
                    useCORS: true,
                    logging: false
                });
                
                // Remove temporary container
                document.body.removeChild(tempContainer);
                
                // Convert canvas to base64 and compress
                const uncompressedData = canvas.toDataURL('image/png');
                const imageData = await compressAndResizeImage(uncompressedData, 1024, 1024, 0.85);
                
                // Send to AI with the compressed screenshot
                await sendMessageWithImage(imageData);
                
            } catch (error) {
                console.error('Screenshot error:', error);
                showMessage('assistant', `Error capturing screenshot: ${error.message}. As a fallback, I'll analyze your current code instead.`);
                
                // Fallback: send current code for analysis
                const fallbackMessage = `Please review and improve this code:\n\nHTML:\n${currentHTML}\n\nCSS:\n${currentCSS}\n\nMake it more visually appealing and fix any issues.`;
                document.getElementById('userInput').value = fallbackMessage;
                await sendMessage();
            } finally {
                document.getElementById('sendButton').disabled = false;
                document.getElementById('loadingIndicator').classList.remove('active');
            }
        }
        
        async function loadHtml2Canvas() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
        
        let generatedImageData = null; // Store the generated image data
        let selectedImageFiles = []; // Store selected image files for input
        
        function handleImageSelection(input) {
            selectedImageFiles = [];
            const previewContainer = document.getElementById('selectedImagesPreview');
            previewContainer.innerHTML = '';
            
            if (input.files && input.files.length > 0) {
                Array.from(input.files).forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        selectedImageFiles.push(e.target.result);
                        
                        // Create preview thumbnail
                        const imgContainer = document.createElement('div');
                        imgContainer.style.cssText = 'position: relative; width: 80px; height: 80px;';
                        
                        const img = document.createElement('img');
                        img.src = e.target.result;
                        img.style.cssText = 'width: 100%; height: 100%; object-fit: cover; border-radius: 6px; background: white; border: 1px solid #e4e4e7;';
                        
                        const removeBtn = document.createElement('button');
                        removeBtn.innerHTML = '×';
                        removeBtn.style.cssText = 'position: absolute; top: -5px; right: -5px; background: red; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; cursor: pointer; font-size: 14px;';
                        removeBtn.onclick = function() {
                            selectedImageFiles.splice(index, 1);
                            imgContainer.remove();
                        };
                        
                        imgContainer.appendChild(img);
                        imgContainer.appendChild(removeBtn);
                        previewContainer.appendChild(imgContainer);
                    };
                    reader.readAsDataURL(file);
                });
            }
        }
        
        function showImageGenerationDialog(showUploadOption = false) {
            // Image generation model is always set (only one option)
            
            const dialog = document.getElementById('imageGenDialog');
            dialog.style.display = 'flex';
            
            // Modify dialog for upload option if from context menu
            if (showUploadOption) {
                const dialogContent = dialog.querySelector('div');
                
                // Check if tabs already exist
                if (!dialog.querySelector('.image-tabs')) {
                    // Add tabs at the top
                    const tabsHTML = `
                        <div class="image-tabs" style="display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid #eee; padding-bottom: 10px;">
                            <button id="galleryTabBtn" onclick="switchImageTab('gallery')" style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px 6px 0 0; cursor: pointer; font-weight: bold;">
                                🖼️ Gallery
                            </button>
                            <button id="uploadTabBtn" onclick="switchImageTab('upload')" style="padding: 8px 16px; background: #f0f0f0; color: #333; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">
                                📤 Upload Image
                            </button>
                            <button id="generateTabBtn" onclick="switchImageTab('generate')" style="padding: 8px 16px; background: #f0f0f0; color: #333; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 4px; display: inline-block; vertical-align: middle;">
                                    <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                                </svg>
                                Generate with AI
                            </button>
                        </div>
                        <div id="galleryTabContent" style="display: block;">
                            <h3 style="margin: 0 0 20px 0; color: #333;">🖼️ Choose from Gallery</h3>
                            <div id="dialogMediaGalleryTab" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; max-height: 300px; overflow-y: auto; padding: 10px; border: 1px solid #e4e4e7; border-radius: 8px; background: #fafafa;">
                                <!-- Gallery images will be loaded here -->
                            </div>
                            <p id="noGalleryImagesTab" style="text-align: center; color: #999; font-size: 14px; margin: 20px 0; display: none;">No images in gallery yet. Generate some images first!</p>
                        </div>
                        <div id="uploadTabContent" style="display: none;">
                            <h3 style="margin: 0 0 20px 0; color: #333;">📤 Upload Your Image</h3>
                            <div style="margin-bottom: 20px;">
                                <input type="file" id="directImageUpload" accept="image/*" onchange="handleDirectImageUpload(this)" style="display: none;">
                                <button onclick="document.getElementById('directImageUpload').click()" style="padding: 12px 24px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; width: 100%;">
                                    📁 Choose Image File
                                </button>
                                <div id="uploadedImagePreview" style="margin-top: 20px; text-align: center;"></div>
                            </div>
                        </div>
                        <div id="generateTabContent" style="display: none;">
                    `;
                    
                    // Insert tabs before the existing content
                    const h2 = dialogContent.querySelector('h2');
                    h2.insertAdjacentHTML('afterend', tabsHTML);
                    
                    // Move buttons to the bottom, outside tabs
                    const buttonsDiv = dialogContent.querySelector('div[style*="justify-content: flex-end"]');
                    if (buttonsDiv) {
                        // Remove from current position and append at the end
                        buttonsDiv.remove();
                        dialogContent.appendChild(buttonsDiv);
                    }
                    
                    // Wrap existing generation content (excluding buttons)
                    const existingContent = Array.from(dialogContent.children).slice(3); // Skip h2 and tabs
                    const generateWrapper = document.createElement('div');
                    generateWrapper.innerHTML = '</div>';
                    existingContent.forEach(el => {
                        if (!el.classList.contains('image-tabs') && 
                            el.id !== 'uploadTabContent' && 
                            el.id !== 'generateTabContent' &&
                            el.id !== 'galleryTabContent' &&
                            !el.querySelector('#generateImageButton') &&
                            !el.querySelector('#insertImageButton')) {
                            generateWrapper.appendChild(el);
                        }
                    });
                }
                
                // Populate the gallery tab
                const dialogGalleryTab = document.getElementById('dialogMediaGalleryTab');
                const noGalleryMsgTab = document.getElementById('noGalleryImagesTab');
                
                if (dialogGalleryTab && generatedImages.length > 0) {
                    dialogGalleryTab.innerHTML = generatedImages.map((img, index) => `
                        <div style="position: relative; cursor: pointer; border: 2px solid transparent; border-radius: 4px; transition: all 0.2s; padding: 4px;"
                             onclick="selectGalleryImage('${img.url.replace(/'/g, "\\'")}')" 
                             onmouseover="this.style.borderColor='#667eea'; this.style.transform='scale(1.05)'" 
                             onmouseout="if(this.style.backgroundColor !== 'rgba(102, 126, 234, 0.1)') { this.style.borderColor='transparent'; this.style.transform='scale(1)' }">
                            <img src="${img.url}" style="width: 100%; height: 100px; object-fit: cover; border-radius: 4px; pointer-events: none;" 
                                 title="${(img.prompt || 'Generated image').replace(/"/g, '&quot;')}" />
                        </div>
                    `).join('');
                    dialogGalleryTab.style.display = 'grid';
                    if (noGalleryMsgTab) noGalleryMsgTab.style.display = 'none';
                } else if (dialogGalleryTab) {
                    dialogGalleryTab.innerHTML = '';
                    dialogGalleryTab.style.display = 'none';
                    if (noGalleryMsgTab) noGalleryMsgTab.style.display = 'block';
                }
                
                // Show gallery tab by default when from context menu (if images exist)
                if (generatedImages.length > 0) {
                    switchImageTab('gallery');
                } else {
                    switchImageTab('upload');
                }
            }
            
            // Populate gallery with generated images
            const dialogGallery = document.getElementById('dialogMediaGallery');
            const noGalleryMsg = document.getElementById('noGalleryImages');
            
            if (dialogGallery && generatedImages.length > 0) {
                dialogGallery.innerHTML = generatedImages.map((img, index) => `
                    <div style="position: relative; cursor: pointer; border: 2px solid transparent; border-radius: 4px; transition: all 0.2s;"
                         onclick="selectGalleryImage('${img.url.replace(/'/g, "\\'")}')" 
                         onmouseover="this.style.borderColor='#667eea'" 
                         onmouseout="this.style.borderColor='transparent'">
                        <img src="${img.url}" style="width: 100%; height: 80px; object-fit: cover; border-radius: 4px;" 
                             title="${(img.prompt || 'Generated image').replace(/"/g, '&quot;')}" />
                    </div>
                `).join('');
                dialogGallery.style.display = 'grid';
                if (noGalleryMsg) noGalleryMsg.style.display = 'none';
            } else if (dialogGallery) {
                dialogGallery.style.display = 'none';
                if (noGalleryMsg) noGalleryMsg.style.display = 'block';
            }
            
            // Reset the dialog state
            document.getElementById('imagePrompt').value = '';
            document.getElementById('imageGenLoading').style.display = 'none';
            document.getElementById('imageGenResult').style.display = 'none';
            document.getElementById('generateImageButton').style.display = 'inline-block';
            document.getElementById('insertImageButton').style.display = 'none';
            document.getElementById('imageInputFiles').value = '';
            document.getElementById('selectedImagesPreview').innerHTML = '';
            selectedImageFiles = [];
        }
        
        function selectGalleryImage(imageUrl) {
            // Set the selected image as the generated image
            generatedImageData = imageUrl;
            
            // Show preview
            const previewImg = document.getElementById('generatedImagePreview');
            const resultDiv = document.getElementById('imageGenResult');
            if (previewImg && resultDiv) {
                previewImg.src = imageUrl;
                resultDiv.style.display = 'block';
            }
            
            // Hide generate button, show insert button
            const generateBtn = document.getElementById('generateImageButton');
            const insertBtn = document.getElementById('insertImageButton');
            const loadingDiv = document.getElementById('imageGenLoading');
            
            if (loadingDiv) loadingDiv.style.display = 'none';
            if (generateBtn) {
                generateBtn.style.display = 'none';
            }
            if (insertBtn) {
                insertBtn.style.display = 'inline-block';
                insertBtn.style.visibility = 'visible';
                // Ensure the button's parent is also visible
                if (insertBtn.parentElement) {
                    insertBtn.parentElement.style.display = 'flex';
                }
                console.log('Insert button should now be visible');
            } else {
                console.error('Insert button not found in DOM');
            }
            
            // Add visual feedback to selected image
            const galleryImages = document.querySelectorAll('#dialogMediaGalleryTab > div');
            galleryImages.forEach(div => {
                const imgSrc = div.querySelector('img')?.src;
                if (imgSrc === imageUrl) {
                    div.style.borderColor = '#667eea';
                    div.style.backgroundColor = 'rgba(102, 126, 234, 0.1)';
                } else {
                    div.style.borderColor = 'transparent';
                    div.style.backgroundColor = 'transparent';
                }
            });
            
            // Visual feedback
            showToast('✅ Image selected! Click "Insert Image" to apply.', 3000);
            
            // Also ensure cancel button is visible
            const cancelBtn = document.querySelector('#imageGenDialog button[onclick="closeImageGenDialog()"]');
            if (cancelBtn) cancelBtn.style.display = 'inline-block';
        }
        
        function switchImageTab(tab) {
            const galleryTab = document.getElementById('galleryTabContent');
            const uploadTab = document.getElementById('uploadTabContent');
            const generateTab = document.getElementById('generateTabContent');
            const galleryBtn = document.getElementById('galleryTabBtn');
            const uploadBtn = document.getElementById('uploadTabBtn');
            const generateBtn = document.getElementById('generateTabBtn');
            
            if (tab === 'gallery') {
                if (galleryTab) galleryTab.style.display = 'block';
                if (uploadTab) uploadTab.style.display = 'none';
                if (generateTab) generateTab.style.display = 'none';
                if (galleryBtn) {
                    galleryBtn.style.background = '#667eea';
                    galleryBtn.style.color = 'white';
                    galleryBtn.style.fontWeight = 'bold';
                }
                if (uploadBtn) {
                    uploadBtn.style.background = '#f0f0f0';
                    uploadBtn.style.color = '#333';
                    uploadBtn.style.fontWeight = 'normal';
                }
                if (generateBtn) {
                    generateBtn.style.background = '#f0f0f0';
                    generateBtn.style.color = '#333';
                    generateBtn.style.fontWeight = 'normal';
                }
                // Hide generate button if in gallery
                document.getElementById('generateImageButton').style.display = 'none';
            } else if (tab === 'upload') {
                if (galleryTab) galleryTab.style.display = 'none';
                if (uploadTab) uploadTab.style.display = 'block';
                if (generateTab) generateTab.style.display = 'none';
                if (uploadBtn) {
                    uploadBtn.style.background = '#667eea';
                    uploadBtn.style.color = 'white';
                    uploadBtn.style.fontWeight = 'bold';
                }
                if (generateBtn) {
                    generateBtn.style.background = '#f0f0f0';
                    generateBtn.style.color = '#333';
                    generateBtn.style.fontWeight = 'normal';
                }
                if (galleryBtn) {
                    galleryBtn.style.background = '#f0f0f0';
                    galleryBtn.style.color = '#333';
                    galleryBtn.style.fontWeight = 'normal';
                }
                // Hide generate button, show insert button if image is uploaded
                document.getElementById('generateImageButton').style.display = 'none';
                if (generatedImageData) {
                    document.getElementById('insertImageButton').style.display = 'inline-block';
                }
            } else {
                if (galleryTab) galleryTab.style.display = 'none';
                if (uploadTab) uploadTab.style.display = 'none';
                if (generateTab) generateTab.style.display = 'block';
                if (generateBtn) {
                    generateBtn.style.background = '#667eea';
                    generateBtn.style.color = 'white';
                    generateBtn.style.fontWeight = 'bold';
                }
                if (uploadBtn) {
                    uploadBtn.style.background = '#f0f0f0';
                    uploadBtn.style.color = '#333';
                    uploadBtn.style.fontWeight = 'normal';
                }
                if (galleryBtn) {
                    galleryBtn.style.background = '#f0f0f0';
                    galleryBtn.style.color = '#333';
                    galleryBtn.style.fontWeight = 'normal';
                }
                // Show appropriate button
                document.getElementById('generateImageButton').style.display = generatedImageData ? 'none' : 'inline-block';
                document.getElementById('insertImageButton').style.display = generatedImageData ? 'inline-block' : 'none';
            }
        }
        
        function handleDirectImageUpload(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                generatedImageData = e.target.result;
                
                // Show preview
                const preview = document.getElementById('uploadedImagePreview');
                preview.innerHTML = `
                    <img src="${generatedImageData}" style="max-width: 100%; max-height: 300px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);" />
                    <p style="margin-top: 10px; color: #71717a; font-size: 14px;">✅ Image ready to insert</p>
                `;
                
                // Show insert button
                document.getElementById('insertImageButton').style.display = 'inline-block';
                document.getElementById('generateImageButton').style.display = 'none';
            };
            
            reader.readAsDataURL(file);
        }
        
        function closeImageGenDialog() {
            document.getElementById('imageGenDialog').style.display = 'none';
            generatedImageData = null;
            selectedImageFiles = [];
            window.imageReplacementTarget = null; // Clear replacement target
            
            // Clean up tabs if they exist
            const tabs = document.querySelector('.image-tabs');
            if (tabs) {
                tabs.remove();
            }
            const uploadContent = document.getElementById('uploadTabContent');
            if (uploadContent) {
                uploadContent.remove();
            }
            const generateContent = document.getElementById('generateTabContent');
            if (generateContent) {
                generateContent.remove();
            }
            
            // Reset context menu target if we were adding image from context menu
            if (contextMenuTarget) {
                contextMenuTarget = null;
            }
        }
        
        function addImageToElement() {
            // Store the target element from context menu
            const previewFrame = document.getElementById('previewFrame');
            if (!previewFrame || !contextMenuTarget) return;
            
            // Show the image generation dialog with upload option
            showImageGenerationDialog(true);
            
            // Modify the insert button behavior for context menu mode
            const insertBtn = document.getElementById('insertImageButton');
            const originalOnclick = insertBtn.onclick;
            
            // Override the insert function for this context
            insertBtn.onclick = function() {
                if (!generatedImageData) {
                    alert('No image to insert');
                    return;
                }
                
                const insertType = document.getElementById('imageInsertType').value;
                const prompt = document.getElementById('imagePrompt').value;
                const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
                
                if (!iframeDoc) return;
                
                // Create the image element
                let imageElement;
                if (insertType === 'img') {
                    imageElement = iframeDoc.createElement('img');
                    imageElement.src = generatedImageData;
                    imageElement.alt = prompt;
                    imageElement.style.cssText = 'max-width: 100%; height: auto; display: block; margin: 10px 0;';
                } else if (insertType === 'background') {
                    // Apply background to the target element
                    if (contextMenuTarget) {
                        contextMenuTarget.style.backgroundImage = `url('${generatedImageData}')`;
                        contextMenuTarget.style.backgroundSize = 'cover';
                        contextMenuTarget.style.backgroundPosition = 'center';
                        contextMenuTarget.style.backgroundRepeat = 'no-repeat';
                        // Ensure element has minimum height if empty
                        if (!contextMenuTarget.offsetHeight || contextMenuTarget.offsetHeight < 200) {
                            contextMenuTarget.style.minHeight = '300px';
                        }
                    }
                    
                    // Update the HTML/CSS storage
                    currentHTML = iframeDoc.body.innerHTML;
                    
                    // Close dialog and reset
                    closeImageGenDialog();
                    insertBtn.onclick = originalOnclick;
                    return;
                } else {
                    // Create a figure with caption
                    const figure = iframeDoc.createElement('figure');
                    figure.style.cssText = 'margin: 20px 0; text-align: center;';
                    
                    imageElement = iframeDoc.createElement('img');
                    imageElement.src = generatedImageData;
                    imageElement.alt = prompt;
                    imageElement.style.cssText = 'max-width: 100%; height: auto; display: block; margin: 0 auto;';
                    
                    const caption = iframeDoc.createElement('figcaption');
                    caption.textContent = prompt;
                    caption.style.cssText = 'margin-top: 10px; color: #71717a; font-style: italic;';
                    
                    figure.appendChild(imageElement);
                    figure.appendChild(caption);
                    imageElement = figure;
                }
                
                // Insert the image relative to the context menu target
                if (contextMenuTarget) {
                    // Check if target is a container element
                    const isContainer = ['DIV', 'SECTION', 'ARTICLE', 'MAIN', 'ASIDE', 'NAV', 'HEADER', 'FOOTER'].includes(contextMenuTarget.tagName);
                    
                    if (isContainer && contextMenuTarget.children.length > 0) {
                        // If it's a container with children, add at the end
                        contextMenuTarget.appendChild(imageElement);
                    } else if (isContainer) {
                        // If it's an empty container, add inside
                        contextMenuTarget.appendChild(imageElement);
                    } else {
                        // For inline elements or non-containers, insert after
                        contextMenuTarget.parentNode.insertBefore(imageElement, contextMenuTarget.nextSibling);
                    }
                } else {
                    // Fallback: add to end of body
                    iframeDoc.body.appendChild(imageElement);
                }
                
                // Update the HTML storage
                currentHTML = iframeDoc.body.innerHTML;
                
                // Close dialog and reset
                closeImageGenDialog();
                insertBtn.onclick = originalOnclick;
                
                // Hide context menu
                const contextMenu = document.getElementById('elementContextMenu');
                if (contextMenu) {
                    contextMenu.style.display = 'none';
                }
            };
        }
        
        async function generateImage() {
            const apiKey = document.getElementById('apiKey').value;
            const imageGenModel = document.getElementById('imageGenModelSelect').value;
            const prompt = document.getElementById('imagePrompt').value.trim();
            const size = document.getElementById('imageSize').value;
            
            if (!apiKey) {
                alert('Please enter your OpenRouter API key first');
                return;
            }
            
            if (!prompt) {
                alert('Please describe the image you want to generate');
                return;
            }
            
            // Show loading state
            document.getElementById('generateImageButton').style.display = 'none';
            document.getElementById('imageGenLoading').style.display = 'block';
            document.getElementById('imageGenResult').style.display = 'none';
            
            try {
                // Prepare the request based on the model
                let requestBody;
                
                // Special handling for DALL-E 3
                if (imageGenModel.includes('dall-e')) {
                    requestBody = {
                        model: imageGenModel,
                        prompt: prompt,
                        n: 1,
                        size: size
                    };
                } else {
                    // Standard chat completion with image modality
                    // Check if we have input images
                    let messageContent;
                    if (selectedImageFiles.length > 0) {
                        // Build content array with text and images
                        messageContent = [
                            {
                                type: 'text',
                                text: prompt
                            }
                        ];
                        
                        // Add each selected image
                        selectedImageFiles.forEach(imageData => {
                            messageContent.push({
                                type: 'image_url',
                                image_url: {
                                    url: imageData
                                }
                            });
                        });
                    } else {
                        // Just text prompt
                        messageContent = prompt;
                    }
                    
                    requestBody = {
                        model: imageGenModel,
                        messages: [
                            {
                                role: 'user',
                                content: messageContent
                            }
                        ],
                        modalities: ['image'],  // Only request image output, no text
                        max_tokens: 4000
                    };
                }
                
                console.log('Image generation request:', requestBody);
                
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Vibe Coder Image Generation'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                const data = await response.json();
                console.log('Image generation response:', data);
                
                if (data.error) {
                    console.error('Image generation error response:', data.error);
                    throw new Error(data.error.message || 'Image generation failed');
                }
                
                // Extract the image data
                let imageUrl;
                
                console.log('Parsing response for image data...');
                
                if (data.choices && data.choices[0]) {
                    const choice = data.choices[0];
                    console.log('Choice data:', choice);
                    
                    // Check for images array first (new format)
                    if (choice.message && choice.message.images && Array.isArray(choice.message.images)) {
                        console.log('Found images array with', choice.message.images.length, 'images');
                        for (const img of choice.message.images) {
                            if (img.image_url && img.image_url.url) {
                                console.log('Found image in images array');
                                imageUrl = img.image_url.url;
                                break;
                            } else if (img.url) {
                                console.log('Found direct URL in images array');
                                imageUrl = img.url;
                                break;
                            }
                        }
                    }
                    
                    // Check for image in the message content (fallback)
                    if (!imageUrl && choice.message && choice.message.content) {
                        console.log('Message content type:', typeof choice.message.content);
                        console.log('Message content:', choice.message.content);
                        
                        // Check if content is an array (multimodal response)
                        if (Array.isArray(choice.message.content)) {
                            console.log('Content is array with', choice.message.content.length, 'parts');
                            
                            // Log all parts to understand structure
                            choice.message.content.forEach((part, index) => {
                                console.log(`Part ${index}:`, part);
                            });
                            
                            // Look for image in various formats
                            for (const part of choice.message.content) {
                                // Check for different image formats
                                if (part.type === 'image' && part.image) {
                                    console.log('Found image part with "image" property:', part);
                                    imageUrl = part.image;
                                    break;
                                } else if (part.type === 'image_url' && part.image_url) {
                                    console.log('Found image_url part:', part);
                                    imageUrl = part.image_url.url;
                                    break;
                                } else if (part.type === 'image' && part.data) {
                                    console.log('Found image part with "data" property:', part);
                                    // Check if data is base64 or needs formatting
                                    if (part.data.startsWith('data:image')) {
                                        imageUrl = part.data;
                                    } else {
                                        // Assume it's raw base64 and add data URI prefix
                                        imageUrl = `data:image/png;base64,${part.data}`;
                                    }
                                    break;
                                } else if (part.type === 'text' && part.text) {
                                    // Sometimes the image URL might be in text
                                    const urlMatch = part.text.match(/(https?:\/\/[^\s]+\.(png|jpg|jpeg|webp|gif)[^\s]*)/i);
                                    if (urlMatch) {
                                        console.log('Found image URL in text part:', urlMatch[0]);
                                        imageUrl = urlMatch[0];
                                    }
                                    // Also check for base64 in text
                                    const base64Match = part.text.match(/data:image\/(png|jpeg|jpg|webp);base64,([^"'\s]+)/);
                                    if (base64Match) {
                                        console.log('Found base64 image in text part');
                                        imageUrl = base64Match[0];
                                    }
                                }
                            }
                            
                            // If still no image, check if the last part might be an image
                            if (!imageUrl && choice.message.content.length > 1) {
                                const lastPart = choice.message.content[choice.message.content.length - 1];
                                console.log('Checking last part specifically:', lastPart);
                                
                                // Sometimes the image is just a string in the last element
                                if (typeof lastPart === 'string' && lastPart.startsWith('data:image')) {
                                    imageUrl = lastPart;
                                } else if (typeof lastPart === 'string' && lastPart.match(/^[A-Za-z0-9+/]+=*$/)) {
                                    // Looks like base64
                                    console.log('Last part appears to be base64 string');
                                    imageUrl = `data:image/png;base64,${lastPart}`;
                                }
                            }
                        } else if (typeof choice.message.content === 'string') {
                            // Look for base64 image data in string content
                            const base64Match = choice.message.content.match(/data:image\/(png|jpeg|jpg|webp);base64,([^"]+)/);
                            if (base64Match) {
                                console.log('Found base64 image in string content');
                                imageUrl = base64Match[0];
                            } else if (choice.message.content.includes('http')) {
                                // Look for URL
                                const urlMatch = choice.message.content.match(/(https?:\/\/[^\s]+)/);
                                if (urlMatch) {
                                    console.log('Found URL in string content:', urlMatch[0]);
                                    imageUrl = urlMatch[0];
                                }
                            }
                        }
                    }
                    
                    // Check for finish_reason with modality details
                    if (!imageUrl && choice.finish_details && choice.finish_details.type === 'max_tokens_image') {
                        console.log('Image generation hit max tokens, may need to increase max_tokens');
                    }
                } else if (data.data && data.data[0]) {
                    // DALL-E format
                    console.log('Using DALL-E format response');
                    imageUrl = data.data[0].url || data.data[0].b64_json;
                    if (data.data[0].b64_json) {
                        imageUrl = `data:image/png;base64,${data.data[0].b64_json}`;
                    }
                }
                
                console.log('Final extracted imageUrl:', imageUrl ? 'Found' : 'Not found');
                
                if (!imageUrl) {
                    console.error('Failed to extract image from response structure:', data);
                    throw new Error('No image was generated. The model might not support image generation or the response format is unexpected.');
                }
                
                // Store the generated image data
                generatedImageData = imageUrl;
                
                // Save to media gallery (async but don't wait)
                saveGeneratedImage(imageUrl, prompt).catch(e => console.error('Failed to save image to gallery:', e));
                
                // Show the generated image
                document.getElementById('generatedImagePreview').src = imageUrl;
                document.getElementById('imageGenResult').style.display = 'block';
                document.getElementById('imageGenLoading').style.display = 'none';
                document.getElementById('insertImageButton').style.display = 'inline-block';
                
                showToast('Image generated and saved to gallery!', 3000);
                showMessage('assistant', 'You can now insert the image into your design.');
                
            } catch (error) {
                console.error('Image generation error:', error);
                alert(`Failed to generate image: ${error.message}`);
                document.getElementById('imageGenLoading').style.display = 'none';
                document.getElementById('generateImageButton').style.display = 'inline-block';
            }
        }
        
        async function autoGeneratePlaceholderImages(skipConfirm = false) {
            const imageGenModel = document.getElementById('imageGenModelSelect').value; // Always set
            const apiKey = document.getElementById('apiKey').value;
            
            if (!apiKey) {
                if (!skipConfirm) {
                    alert('Please enter your OpenRouter API key first');
                }
                return;
            }
            
            // Make sure we're using the latest HTML from the editor
            currentHTML = document.getElementById('htmlEditor').value || currentHTML;
            
            // Find all placeholder images in the current HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = currentHTML;
            const placeholderImages = tempDiv.querySelectorAll('img[src*="placeholder.com"], img[data-image-prompt]');
            
            console.log(`Found ${placeholderImages.length} placeholder images to replace`);
            
            if (placeholderImages.length === 0) {
                if (!skipConfirm) {
                    alert('No placeholder images found in the current HTML');
                }
                return;
            }
            
            // Skip confirmation if auto-generating
            if (!skipConfirm) {
                const confirmGenerate = confirm(`Found ${placeholderImages.length} placeholder image(s). Generate real images for all of them?`);
                if (!confirmGenerate) return;
            }
            
            showMessage('assistant', `Starting to generate ${placeholderImages.length} images in parallel...`);
            
            const imagePromptTemplate = document.getElementById('imagePromptTemplate')?.value || 
                'Professional photography, high quality, 8k resolution, {description}, modern aesthetic';
            
            // Create an array of image generation promises
            const imageGenerationPromises = Array.from(placeholderImages).map(async (img, i) => {
                const placeholderSrc = img.src;
                
                // Extract description from various sources
                let description = '';
                
                // Try data-image-prompt first
                if (img.getAttribute('data-image-prompt')) {
                    description = img.getAttribute('data-image-prompt');
                } 
                // Try extracting from placeholder URL text parameter
                else if (placeholderSrc.includes('text=')) {
                    const textMatch = placeholderSrc.match(/text=([^&]+)/);
                    if (textMatch) {
                        description = decodeURIComponent(textMatch[1].replace(/\+/g, ' '));
                    }
                }
                // Fallback to alt text
                else if (img.alt) {
                    description = img.alt;
                }
                
                if (!description) {
                    console.log(`Skipping image ${i + 1}: No description found`);
                    return { success: false, error: 'No description', img, placeholderSrc };
                }
                
                // Build the prompt using the template
                const imagePrompt = imagePromptTemplate.replace('{description}', description);
                
                showMessage('assistant', `📸 Generating image ${i + 1}/${placeholderImages.length}: ${description.substring(0, 50)}...`);
                
                try {
                    // Add a small random delay to stagger requests slightly (0-500ms)
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 500));
                    
                    // Generate the image
                    const requestBody = imageGenModel.includes('dall-e') ? {
                        model: imageGenModel,
                        prompt: imagePrompt,
                        n: 1,
                        size: '1024x1024'
                    } : {
                        model: imageGenModel,
                        messages: [{
                            role: 'user',
                            content: imagePrompt
                        }],
                        modalities: ['image'],  // Only request image output, no text
                        max_tokens: 4000
                    };
                    
                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Vibe Coder Auto Image Generation'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    const data = await response.json();
                    
                    if (data.error) {
                        throw new Error(data.error.message || 'Image generation failed');
                    }
                    
                    // Extract the image URL
                    let imageUrl;
                    if (data.choices && data.choices[0]) {
                        const choice = data.choices[0];
                        
                        // Check for images array first (new format when using modalities: ['image'])
                        if (choice.message && choice.message.images && Array.isArray(choice.message.images)) {
                            for (const imgData of choice.message.images) {
                                if (imgData.image_url && imgData.image_url.url) {
                                    imageUrl = imgData.image_url.url;
                                    break;
                                } else if (imgData.url) {
                                    imageUrl = imgData.url;
                                    break;
                                }
                            }
                        }
                        
                        // Fallback to checking content
                        if (!imageUrl && choice.message && choice.message.content) {
                            const base64Match = choice.message.content.match(/data:image\/(png|jpeg|jpg|webp);base64,([^"]+)/);
                            if (base64Match) {
                                imageUrl = base64Match[0];
                            } else if (choice.message.content.includes('http')) {
                                const urlMatch = choice.message.content.match(/(https?:\/\/[^\s]+)/);
                                if (urlMatch) {
                                    imageUrl = urlMatch[0];
                                }
                            }
                        }
                    } else if (data.data && data.data[0]) {
                        imageUrl = data.data[0].url || `data:image/png;base64,${data.data[0].b64_json}`;
                    }
                    
                    if (imageUrl) {
                        // Save to media gallery (async but don't wait)
                        saveGeneratedImage(imageUrl, imagePrompt).catch(e => console.error('Failed to save image to gallery:', e));
                        return { success: true, imageUrl, img, placeholderSrc };
                    } else {
                        return { success: false, error: 'No image URL found', img, placeholderSrc };
                    }
                    
                } catch (error) {
                    console.error(`Failed to generate image ${i + 1}:`, error);
                    return { success: false, error: error.message, img, placeholderSrc };
                }
            });
            
            // Wait for all image generations to complete
            const results = await Promise.all(imageGenerationPromises);
            
            // Process results and update HTML
            let successCount = 0;
            let failCount = 0;
            
            for (const result of results) {
                if (result.success) {
                    // Create a regex to find the image with this placeholder src
                    const placeholderSrc = result.placeholderSrc;
                    const imageUrl = result.imageUrl;
                    
                    // Escape special regex characters in the URL
                    const escapedSrc = placeholderSrc.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    
                    // Try multiple replacement patterns
                    // Pattern 1: Direct src attribute replacement
                    const srcPattern = new RegExp(`src=["']${escapedSrc}["']`, 'gi');
                    if (srcPattern.test(currentHTML)) {
                        currentHTML = currentHTML.replace(srcPattern, `src="${imageUrl}"`);
                        successCount++;
                        console.log(`Replaced placeholder: ${placeholderSrc.substring(0, 50)}...`);
                    } 
                    // Pattern 2: Look for the full img tag with this src
                    else {
                        const imgTagPattern = new RegExp(`<img[^>]*src=["']${escapedSrc}["'][^>]*>`, 'gi');
                        if (imgTagPattern.test(currentHTML)) {
                            currentHTML = currentHTML.replace(imgTagPattern, (match) => {
                                return match.replace(placeholderSrc, imageUrl);
                            });
                            successCount++;
                            console.log(`Replaced img tag with placeholder: ${placeholderSrc.substring(0, 50)}...`);
                        } else {
                            console.warn(`Could not find placeholder in HTML: ${placeholderSrc.substring(0, 50)}...`);
                            failCount++;
                        }
                    }
                } else {
                    failCount++;
                }
            }
            
            // Update the editors and preview
            if (successCount > 0) {
                // Update the HTML editor with replaced images
                document.getElementById('htmlEditor').value = currentHTML;
                
                // IMPORTANT: Update the global currentHTML variable
                window.currentHTML = currentHTML;
                
                // Refresh the preview to show the new images
                updatePreview();
                generateOxygenJSON();
                
                console.log(`Successfully replaced ${successCount} placeholder images`);
                console.log('Updated HTML:', currentHTML.substring(0, 500) + '...');
            } else if (placeholderImages.length > 0) {
                console.error('Failed to replace any placeholder images');
                console.log('Current HTML sample:', currentHTML.substring(0, 500) + '...');
            }
            
            showToast(`✅ Image generation complete! ${successCount} image(s) generated${failCount > 0 ? `, ${failCount} failed` : ''}`, 3000);
        }
        
        function insertGeneratedImage() {
            if (!generatedImageData) {
                alert('No image to insert');
                return;
            }
            
            // Check if we're replacing an existing image element
            if (window.imageReplacementTarget) {
                const target = window.imageReplacementTarget;
                
                // Replace the image src directly in the iframe
                if (target.tagName === 'IMG') {
                    // Store original dimensions if they exist
                    const originalStyle = target.getAttribute('style') || '';
                    const originalWidth = target.getAttribute('width') || '';
                    const originalHeight = target.getAttribute('height') || '';
                    
                    // Replace the src
                    target.src = generatedImageData;
                    
                    // Preserve original styling if it exists
                    if (originalStyle && !originalStyle.includes('max-width')) {
                        target.setAttribute('style', originalStyle);
                    } else if (originalWidth || originalHeight) {
                        // Keep original dimensions if specified
                        if (originalWidth) target.setAttribute('width', originalWidth);
                        if (originalHeight) target.setAttribute('height', originalHeight);
                    }
                    
                    // Update the HTML editor to reflect the change
                    const iframeDoc = document.getElementById('previewFrame').contentDocument;
                    const bodyHTML = iframeDoc.body.innerHTML;
                    
                    // Update currentHTML with the new content
                    currentHTML = bodyHTML;
                    document.getElementById('htmlEditor').value = currentHTML;
                    
                    // Clear the replacement target
                    window.imageReplacementTarget = null;
                    
                    // Close dialog and show success
                    closeImageGenDialog();
                    showToast('✅ Image replaced successfully!', 2000);
                    return;
                }
            }
            
            // Original insertion logic for non-replacement cases
            // Get insert type, default to 'img' if not found (when using from context menu)
            const insertTypeEl = document.getElementById('imageInsertType');
            const insertType = insertTypeEl ? insertTypeEl.value : 'img';
            
            // Get prompt, use empty string if not found
            const promptEl = document.getElementById('imagePrompt');
            const prompt = promptEl ? promptEl.value : 'Generated image';
            
            let newHTML = '';
            let newCSS = '';
            
            switch (insertType) {
                case 'img':
                    // Simple image element
                    newHTML = `<img src="${generatedImageData}" alt="${prompt}" style="max-width: 100%; height: auto; display: block; margin: 20px auto;">`;
                    break;
                    
                case 'background':
                    // Add as background to existing element or create new section
                    const sectionId = 'generated-section-' + Date.now();
                    newHTML = `<section id="${sectionId}" class="generated-bg-section">
    <div class="content">
        <h2>Your Content Here</h2>
        <p>This section has your generated image as background</p>
    </div>
</section>`;
                    newCSS = `#${sectionId} {
    background-image: url('${generatedImageData}');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    min-height: 500px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}

#${sectionId} .content {
    background: rgba(255, 255, 255, 0.95);
    padding: 40px;
    border-radius: 12px;
    text-align: center;
    max-width: 600px;
}`;
                    break;
                    
                case 'hero':
                    // Create a complete hero section
                    newHTML = `<section class="ai-hero-section" style="background-image: url('${generatedImageData}'); background-size: cover; background-position: center; min-height: 600px; position: relative; display: flex; align-items: center; justify-content: center;">
    <div class="hero-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.4);"></div>
    <div class="hero-content" style="position: relative; z-index: 1; text-align: center; color: white; padding: 40px;">
        <h1 style="font-size: 48px; margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">Welcome to Our Site</h1>
        <p style="font-size: 20px; margin-bottom: 30px; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">Your journey starts here with stunning AI-generated visuals</p>
        <button style="background: white; color: #333; padding: 15px 40px; border: none; border-radius: 50px; font-size: 18px; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">Get Started</button>
    </div>
</section>`;
                    break;
            }
            
            // Add the generated content to the current HTML/CSS
            if (currentMode === 'add' || !currentHTML) {
                currentHTML = (currentHTML || '') + '\n' + newHTML;
                currentCSS = (currentCSS || '') + (newCSS ? '\n' + newCSS : '');
            } else {
                currentHTML = newHTML + '\n' + (currentHTML || '');
                currentCSS = newCSS + '\n' + (currentCSS || '');
            }
            
            // Update editors and preview
            document.getElementById('htmlEditor').value = currentHTML;
            document.getElementById('cssEditor').value = currentCSS;
            updatePreview();
            generateOxygenJSON();
            
            // Close the dialog
            closeImageGenDialog();
            
            // Show success message
            showToast(`✅ Image inserted as ${insertType === 'img' ? 'an image element' : insertType === 'background' ? 'a background image' : 'a hero section'}!`, 3000);
        }
        
        async function sendMessageWithImage(imageData, customPrompt = null) {
            const apiKey = document.getElementById('apiKey').value;
            // Use vision model for screenshot analysis, fall back to regular model if not set
            const visionModel = document.getElementById('visionModelSelect')?.value || 
                               document.getElementById('modelSelect').value;
            
            if (!apiKey) {
                alert('Please enter your OpenRouter API key first');
                return;
            }
            
            // Store current content BEFORE AI modifies it (for ADD mode merging)
            const previousHTML = currentHTML;
            const previousCSS = currentCSS;
            
            // Use custom prompt or default message
            const userMessage = customPrompt || 'Here is a screenshot of the current design. Please analyze it and provide improvements to make it more visually appealing, fix any layout issues, and ensure it follows modern web design best practices. Provide the updated HTML and CSS code.';
            
            // Don't show duplicate message if already shown
            if (!customPrompt) {
                showMessage('user', '📸 ' + userMessage + ' [Screenshot attached]');
            }
            
            // Ensure image is compressed before sending (safety check)
            let compressedImageData = imageData;
            if (imageData.startsWith('data:image/png') || imageData.length > 500000) {
                // Compress if it's PNG or larger than ~500KB
                compressedImageData = await compressAndResizeImage(imageData, 1024, 1024, 0.85);
            }
            
            // Add to conversation history with image
            const messageWithImage = {
                role: 'user',
                content: [
                    {
                        type: 'text',
                        text: userMessage
                    },
                    {
                        type: 'image_url',
                        image_url: {
                            url: compressedImageData
                        }
                    }
                ]
            };
            
            conversationHistory.push(messageWithImage);
            
            try {
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Vibe Coder for Oxygen'
                    },
                    body: JSON.stringify({
                        model: visionModel,
                        messages: [
                            {
                                role: 'system',
                                content: getSystemPromptWithBrandGuidelines() + `

IMPORTANT: You MUST follow this EXACT format for ALL responses:

[EXPLANATION]
Brief description of what you created or fixed

[HTML]
\`\`\`html
(your HTML code here)
\`\`\`

[CSS]
\`\`\`css
(your CSS code here)
\`\`\`

When analyzing screenshots, identify issues and provide improved code.`
                            },
                            ...conversationHistory
                        ],
                        temperature: 0.7,
                        max_tokens: getModelContextLength(visionModel)
                    })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error.message || 'API request failed');
                }
                
                const aiResponse = data.choices[0].message.content;
                
                // Add AI response to history (simplified for storage)
                conversationHistory.push({ role: 'assistant', content: aiResponse });
                
                // Parse and extract code from response (pass previous content for ADD mode)
                parseAIResponse(aiResponse, previousHTML, previousCSS, currentJS);
                
                // Show AI message
                const explanation = aiResponse.split('[HTML]')[0].replace('[EXPLANATION]', '').trim();
                if (explanation) {
                    showMessage('assistant', explanation);
                }
                
            } catch (error) {
                showMessage('assistant', `Error: ${error.message}`);
            } finally {
                document.getElementById('sendButton').disabled = false;
                document.getElementById('loadingIndicator').classList.remove('active');
            }
        }

        // Auto-update preview when editing HTML/CSS
        document.getElementById('htmlEditor')?.addEventListener('input', () => {
            currentHTML = document.getElementById('htmlEditor').value;
            updatePreview();
            generateOxygenJSON();
        });

        document.getElementById('cssEditor')?.addEventListener('input', () => {
            currentCSS = document.getElementById('cssEditor').value;
            // Update backup when user manually edits CSS
            if (currentCSS.trim()) {
                lastKnownGoodCSS = currentCSS;
            }
            updatePreview();
            generateOxygenJSON();
        });
    </script>
</body>
</html>