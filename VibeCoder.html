<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Good Vibes Only - AI-Powered Website Builder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: #fafafa;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #ffffff;
            padding: 20px;
            text-align: center;
            color: #09090b;
            border-bottom: 1px solid #e4e4e7;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-weight: 600;
        }

        .header p {
            color: #71717a;
            font-size: 14px;
        }

        .main-container {
            flex: 1;
            display: flex;
            gap: 20px;
            padding: 20px;
            max-width: 1600px;
            width: 100%;
            margin: 0 auto;
        }

        .chat-panel {
            width: 30%; /* 30% of screen */
            min-width: 350px;
            max-width: 500px;
            background: white;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border: 1px solid #e4e4e7;
            overflow: hidden;
        }

        .chat-header {
            padding: 15px;
            background: #ffffff;
            color: #09090b;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #e4e4e7;
            font-weight: 500;
        }

        .settings-toggle {
            background: #f4f4f5;
            border: 1px solid #e4e4e7;
            color: #71717a;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-toggle:hover {
            background: #e4e4e7;
            color: #09090b;
        }

        .api-config {
            background: #fafafa;
            border-bottom: 1px solid #e4e4e7;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                max-height: 300px;
                transform: translateY(0);
            }
        }

        .api-config input {
            flex: 1;
            min-width: 200px;
            padding: 8px 12px;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            font-size: 14px;
        }

        .api-config select {
            padding: 8px 12px;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #fafbfc;
        }

        .message {
            margin-bottom: 15px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            text-align: right;
        }

        .message.assistant {
            text-align: left;
        }

        .message-content {
            display: inline-block;
            padding: 10px 15px;
            border-radius: 8px;
            max-width: 80%;
            word-wrap: break-word;
        }

        .message.user .message-content {
            background: #09090b;
            color: white;
        }

        .message.assistant .message-content {
            background: #f4f4f5;
            color: #09090b;
            border: 1px solid #e4e4e7;
        }

        .message-label {
            font-size: 12px;
            color: #71717a;
            margin-bottom: 5px;
        }

        .chat-input {
            padding: 20px;
            background: white;
            border-top: 1px solid #e4e4e7;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .input-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .mode-toggle {
            display: flex;
            background: #f4f4f5;
            border-radius: 6px;
            padding: 3px;
            gap: 2px;
        }
        
        .mode-toggle button {
            padding: 6px 12px;
            border: none;
            background: transparent;
            border-radius: 6px; background: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #71717a;
            transition: all 0.2s;
        }
        
        .mode-toggle button.active {
            background: white;
            color: #09090b;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        
        .element-picker-btn {
            padding: 6px 12px;
            background: white;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            color: #71717a;
            transition: all 0.2s;
        }
        
        .element-picker-btn:hover {
            border-color: #a1a1aa;
            background: #fafafa;
            color: #09090b;
        }
        
        .element-picker-btn.active {
            background: #09090b;
            color: white;
            border-color: #09090b;
        }
        
        .selected-element-tag {
            padding: 4px 8px;
            background: #f4f4f5;
            color: #09090b;
            border-radius: 6px; background: white;
            font-size: 12px;
            font-family: monospace;
            border: 1px solid #e4e4e7;
        }
        
        .reference-input {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .reference-input input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }
        
        .reference-input input:focus {
            outline: none;
            border-color: #a1a1aa;
            box-shadow: 0 0 0 3px rgba(161, 161, 170, 0.1);
        }
        
        .fetch-button {
            padding: 8px 16px;
            background: #09090b;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            white-space: nowrap;
        }
        
        .fetch-button:hover {
            background: #27272a;
            transform: translateY(-1px);
        }
        
        .fetch-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .chat-input-row {
            display: flex;
            flex-direction: column;
            gap: 10px;
            position: relative;
        }
        
        .button-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .attach-image-button {
            background: white;
            border: 1px solid #e4e4e7;
            color: #71717a;
            width: 40px;
            height: 40px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .attach-image-button:hover {
            background: #f4f4f5;
            border-color: #a1a1aa;
            color: #09090b;
        }
        
        .clear-chat-button {
            background: transparent;
            border: 1px solid #e4e4e7;
            color: #a1a1aa;
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            align-self: flex-start;
            margin-top: -5px;
        }
        
        .clear-chat-button:hover {
            background: #fafafa;
            border-color: #a1a1aa;
            color: #71717a;
        }

        .chat-input textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            font-size: 14px;
            resize: vertical;
            font-family: inherit;
            min-height: 80px;
            max-height: 200px;
            background: white;
        }

        .send-button {
            width: 100%;
            padding: 10px 20px;
            background: #09090b;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .send-button:hover {
            background: #27272a;
            transform: translateY(-1px);
        }
        
        .send-button:active {
            transform: translateY(0);
        }

        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            background: #e4e4e7;
        }

        .preview-panel {
            flex: 1;
            background: white;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border: 1px solid #e4e4e7;
            overflow: hidden;
        }

        .preview-tabs {
            display: flex;
            background: #fafafa;
            border-bottom: 1px solid #e4e4e7;
        }

        .preview-tab {
            padding: 10px 16px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 14px;
            font-weight: 500;
            color: #71717a;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .preview-tab.active {
            color: #09090b;
            border-bottom-color: #09090b;
            background: white;
        }
        
        .device-toggles {
            margin-left: auto;
            display: flex;
            gap: 8px;
            padding-right: 15px;
        }
        
        .device-toggle {
            padding: 8px;
            background: transparent;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            cursor: pointer;
            color: #71717a;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .device-toggle:hover {
            background: #fafafa;
            border-color: #a1a1aa;
            color: #09090b;
        }
        
        .device-toggle.active {
            background: #09090b;
            border-color: #09090b;
            color: white;
        }
        
        .device-toggle svg {
            width: 20px;
            height: 20px;
        }

        .preview-content {
            flex: 1;
            overflow: auto;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: #fafafa;
        }

        .code-editor {
            width: 100%;
            height: 100%;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            line-height: 1.6;
            background: #1e1e1e;
            color: #d4d4d4;
            border: none;
            outline: none;
            resize: none;
        }

        .preview-frame {
            width: 100%;
            height: 100%;
            border: 1px solid #e4e4e7;
            background: white;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border-radius: 6px;
        }
        
        /* Device-specific preview sizes */
        .preview-frame.desktop {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
        }
        
        .preview-frame.tablet {
            width: 768px;
            max-width: 90%;
            height: 1024px;
            max-height: 90%;
        }
        
        .preview-frame.mobile {
            width: 375px;
            max-width: 90%;
            height: 667px;
            max-height: 90%;
        }

        .json-output {
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            word-wrap: break-word;
            height: 100%;
            overflow: auto;
        }

        .controls {
            padding: 15px;
            background: #fafafa;
            border-top: 1px solid #e4e4e7;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .control-button {
            padding: 8px 16px;
            background: white;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .control-button:hover {
            background: #fafafa;
            border-color: #a1a1aa;
            color: #09090b;
        }

        .control-button.primary {
            background: #09090b;
            color: white;
            border-color: #09090b;
        }

        .control-button.primary:hover {
            background: #27272a;
        }
        .control-button.active {
            background: #09090b !important;
            color: white !important;
            border-color: #09090b !important;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .prompt-suggestions {
            background: #fafafa;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            margin-bottom: 10px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .prompt-suggestions.collapsed .suggestions-grid {
            display: none;
        }

        .suggestions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #f4f4f5;
            cursor: pointer;
            user-select: none;
        }

        .suggestions-label {
            font-size: 12px;
            color: #71717a;
            font-weight: 500;
        }

        .suggestions-toggle {
            background: none;
            border: none;
            color: #71717a;
            cursor: pointer;
            padding: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s;
        }

        .prompt-suggestions.collapsed .suggestions-toggle {
            transform: rotate(-90deg);
        }

        .suggestions-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            padding: 8px;
        }

        .suggestion-chip {
            display: flex;
            align-items: center;
            padding: 5px 8px;
            background: white;
            border: 1px solid #e4e4e7;
            border-radius: 6px; background: white;
            font-size: 11px;
            color: #52525b;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .suggestion-chip:hover {
            background: #09090b;
            color: white;
            border-color: #09090b;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .loading-indicator {
            display: none;
            padding: 10px;
            text-align: center;
            color: #71717a;
        }

        .loading-indicator.active {
            display: block;
        }

        .loading-dots {
            display: inline-block;
        }

        .loading-dots::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .element-picker-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }
        
        .element-picker-overlay.active {
            pointer-events: auto;
        }
        
        .element-highlight {
            position: absolute;
            border: 2px dashed #a1a1aa;
            background: rgba(161, 161, 170, 0.1);
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .element-highlight:hover {
            background: rgba(161, 161, 170, 0.2);
            border-color: #71717a;
        }
        
        .element-highlight.selected {
            border: 2px solid #09090b;
            background: rgba(9, 9, 11, 0.05);
            box-shadow: 0 0 0 4px rgba(9, 9, 11, 0.1);
        }
        
        .element-label {
            position: absolute;
            top: -24px;
            left: -2px;
            background: #09090b;
            color: white;
            padding: 2px 8px;
            border-radius: 4px 4px 0 0;
            font-size: 11px;
            font-family: monospace;
            white-space: nowrap;
        }
        
        .context-menu-item:hover {
            background: #f4f4f5;
        }
        
        .property-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e4e4e7;
            border-radius: 6px;
            font-size: 14px;
            margin: 5px 0;
            background: white;
        }
        
        .property-input:focus {
            outline: none;
            border-color: #a1a1aa;
            box-shadow: 0 0 0 3px rgba(161, 161, 170, 0.1);
        }
        
        .property-group {
            margin: 15px 0;
        }
        
        .property-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #09090b;
            font-size: 14px;
        }
        
        .element-highlight {
            outline: 2px dashed #a1a1aa !important;
            outline-offset: 2px;
        }
        
        @media (max-width: 1024px) {
            .main-container {
                flex-direction: column;
            }
            
            .preview-panel {
                min-height: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>✨ Good Vibes Only<span style="font-size: 14px; opacity: 0.8;">for Oxygen Builder</span></h1>
        <p>Chat with AI to create beautiful websites - Export directly to Oxygen Builder</p>
    </div>

    <div class="main-container">
        <div class="chat-panel">
            <div class="chat-header">
                <h3 style="margin: 0; flex: 1;">Vibe here</h3>
                <button class="settings-toggle" onclick="toggleSettings()" title="Settings">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </button>
            </div>

            <div class="api-config" id="settingsPanel" style="display: none;">
                <div style="padding: 15px; background: #ffffff; border-radius: 6px; margin: 10px; max-height: 500px; overflow-y: auto; border: 1px solid #e4e4e7;">
                    <h4 style="margin: 0 0 15px 0; color: #09090b; font-weight: 600;">⚙️ Settings</h4>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 12px; color: #71717a; margin-bottom: 5px;">OpenRouter API Key:</label>
                        <input type="password" id="apiKey" placeholder="Enter your API key" style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px; background: white;" />
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 12px; color: #71717a; margin-bottom: 5px;">AI Model for Coding:</label>
                        <select id="modelSelect" style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px; background: white;">
                            <option value="x-ai/grok-code-fast-1">Grok Code Fast (128K)</option>
                            <option value="openai/gpt-5">GPT-5 (200K)</option>
                            <option value="x-ai/grok-4">Grok 4 (128K)</option>
                            <option value="google/gemini-2.5-flash">Gemini 2.5 Flash (1M)</option>
                            <option value="google/gemini-2.5-pro">Gemini 2.5 Pro (2M)</option>
                            <option value="anthropic/claude-sonnet-4">Claude Sonnet 4 (200K)</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 12px; color: #71717a; margin-bottom: 5px;">AI Vision Model (for screenshot analysis):</label>
                        <select id="visionModelSelect" style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px; background: white;">
                            <option value="google/gemini-2.5-flash-image-preview">Gemini 2.5 Flash Image Preview (1M)</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 12px; color: #71717a; margin-bottom: 5px;">AI Image Generation Model:</label>
                        <select id="imageGenModelSelect" style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px; background: white;">
                            <option value="google/gemini-2.5-flash-image-preview">Gemini 2.5 Flash Image Preview (1M)</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 12px; color: #71717a; margin-bottom: 5px;">System Prompt (customize AI behavior):</label>
                        <textarea id="systemPrompt" placeholder="You are an expert web developer..." style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px; background: white; min-height: 100px; font-family: monospace; font-size: 12px; resize: vertical;">You are an expert web developer specializing in creating beautiful, modern web components. You focus on clean, semantic HTML, modern CSS with smooth animations, and efficient JavaScript when needed.

IMPORTANT IMAGE HANDLING:
- Always use placeholder images from https://via.placeholder.com/
- Format: https://via.placeholder.com/WIDTHxHEIGHT/BGCOLOR/TEXTCOLOR?text=DESCRIPTION
- Include descriptive text that clearly explains what the final image should be
- Examples:
  - https://via.placeholder.com/1920x600/667eea/ffffff?text=Hero+Banner:+Team+Collaboration+in+Modern+Office
  - https://via.placeholder.com/400x300/f0f0f0/333333?text=Product+Image:+Laptop+on+Desk
- Add data-image-prompt attribute with detailed prompt for AI generation later
- Example: &lt;img src="placeholder.jpg" data-image-prompt="Professional team meeting in bright modern office, diverse group collaborating around table with laptops, natural lighting"&gt;</textarea>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 12px; color: #71717a; margin-bottom: 5px;">Brand Guidelines (colors, fonts, style preferences):</label>
                        <textarea id="brandGuidelines" placeholder="Primary color: #667eea&#10;Font: Inter, sans-serif&#10;Style: Modern, minimalist..." style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px; background: white; min-height: 80px; font-family: monospace; font-size: 12px; resize: vertical;"></textarea>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; font-size: 12px; color: #71717a; margin-bottom: 5px;">Image Generation Prompt Template:</label>
                        <textarea id="imagePromptTemplate" placeholder="Professional photography, high quality, 8k resolution, {description}, modern aesthetic, clean composition..." style="width: 100%; padding: 8px; border: 1px solid #e4e4e7; border-radius: 6px; background: white; min-height: 80px; font-family: monospace; font-size: 12px; resize: vertical;">Professional photography, high quality, 8k resolution, {description}, modern aesthetic, clean composition, natural lighting, sharp focus, visually appealing</textarea>
                        <small style="color: #a1a1aa; font-size: 11px;">Use {description} as placeholder for the image description from placeholders</small>
                    </div>
                    
                    <button class="control-button" onclick="saveConfig()" style="width: 100%;">💾 Save Settings</button>
                </div>
            </div>

            <div class="chat-messages" id="chatMessages">
                <div class="prompt-suggestions" id="promptSuggestions">
                    <div class="suggestions-header">
                        <span class="suggestions-label">💡 Quick starts</span>
                        <button class="suggestions-toggle" onclick="toggleSuggestions()" title="Toggle suggestions">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </button>
                    </div>
                    <div class="suggestions-grid" id="suggestionsGrid">
                        <span class="suggestion-chip" onclick="useSuggestion(this)" title="Start with a complete page structure">🏗️ Build landing page with sections</span>
                        <span class="suggestion-chip" onclick="useSuggestion(this)" title="Upload a screenshot to recreate">📸 Recreate from my screenshot</span>
                        <span class="suggestion-chip" onclick="useSuggestion(this)" title="Fix issues in existing code">🔧 Debug and improve my code</span>
                        <span class="suggestion-chip" onclick="useSuggestion(this)" title="Add new functionality">✨ Add dark mode to my site</span>
                        <span class="suggestion-chip" onclick="useSuggestion(this)" title="Make responsive for all devices">📱 Make my design mobile-friendly</span>
                        <span class="suggestion-chip" onclick="useSuggestion(this)" title="Add smooth animations">🎨 Add animations and effects</span>
                        <span class="suggestion-chip" onclick="useSuggestion(this)" title="Convert to Oxygen format">🔄 Convert HTML to Oxygen</span>
                        <span class="suggestion-chip" onclick="useSuggestion(this)" title="Improve performance">⚡ Optimize for speed and SEO</span>
                    </div>
                </div>
            </div>

            <div class="loading-indicator" id="loadingIndicator">
                <span>AI is thinking</span><span class="loading-dots"></span>
            </div>

            <div class="chat-input">
                <div class="input-controls">
                    <div class="mode-toggle">
                        <button id="addModeBtn" class="active" onclick="setMode('add')">➕ Add</button>
                        <button id="editModeBtn" onclick="setMode('edit')">✏️ Edit</button>
                        <button id="referenceModeBtn" onclick="setMode('reference')">🔗 Reference</button>
                        <button id="planModeBtn" onclick="setMode('plan')">📋 Plan</button>
                    </div>
                    <button class="element-picker-btn" id="elementPickerBtn" onclick="toggleElementPicker()" style="display: none;">
                        🎯 Select Element
                    </button>
                </div>
                <div class="reference-input" id="referenceInput" style="display: none;">
                    <input type="url" id="referenceUrl" placeholder="Enter website URL to reference (e.g., https://example.com)" />
                    <button class="fetch-button" onclick="fetchReference()">🌐 Fetch & Analyze</button>
                </div>
                <div class="chat-input-row">
                    <textarea id="userInput" placeholder="Describe what you want to build... (e.g., 'Create a modern hero section with a gradient background and call-to-action button')" 
                        onkeydown="handleKeyPress(event)"></textarea>
                    <div class="button-row">
                        <button class="send-button" onclick="sendMessage()" id="sendButton">✨ Send Message</button>
                        <button class="attach-image-button" onclick="attachImage()" title="Attach an image">
                            📎
                        </button>
                    </div>
                    <button class="clear-chat-button" onclick="clearAll()" title="Clear conversation history">Clear chat</button>
                    <div style="display: flex; align-items: center; gap: 8px; margin-top: 10px;">
                        <input type="checkbox" id="autoGenerateImages" style="width: 16px; height: 16px; cursor: pointer;">
                        <label for="autoGenerateImages" style="font-size: 13px; color: #71717a; cursor: pointer; user-select: none;">
                            Auto-generate images for all placeholders
                        </label>
                    </div>
                </div>
                <input type="file" id="imageInput" accept="image/*" style="display: none;" onchange="handleImageSelect(event)">
            </div>
        </div>

        <div class="preview-panel">
            <div class="preview-tabs">
                <button class="preview-tab active" onclick="switchTab('preview')">Preview</button>
                <button class="preview-tab" onclick="switchTab('html')">HTML</button>
                <button class="preview-tab" onclick="switchTab('css')">CSS</button>
                <button class="preview-tab" onclick="switchTab('js')">JavaScript</button>
                <button class="preview-tab" onclick="switchTab('json')">Oxygen JSON</button>
                
                <div class="device-toggles">
                    <button class="device-toggle active" onclick="setDevice('desktop')" title="Desktop View">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="2" y="3" width="20" height="14" rx="2" />
                            <line x1="8" y1="21" x2="16" y2="21" />
                            <line x1="12" y1="17" x2="12" y2="21" />
                        </svg>
                    </button>
                    <button class="device-toggle" onclick="setDevice('tablet')" title="Tablet View">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="4" y="2" width="16" height="20" rx="2" />
                            <line x1="12" y1="18" x2="12.01" y2="18" />
                        </svg>
                    </button>
                    <button class="device-toggle" onclick="setDevice('mobile')" title="Mobile View">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="5" y="2" width="14" height="20" rx="2" />
                            <line x1="12" y1="18" x2="12.01" y2="18" />
                        </svg>
                    </button>
                    <button class="device-toggle" onclick="toggleFullscreen()" id="fullscreenBtn" title="Fullscreen View">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" />
                        </svg>
                    </button>
                </div>
            </div>

            <div class="preview-content">
                <iframe class="preview-frame" id="previewFrame" style="display: block;"></iframe>
                <textarea class="code-editor" id="htmlEditor" style="display: none;"></textarea>
                <textarea class="code-editor" id="cssEditor" style="display: none;"></textarea>
                <textarea class="code-editor" id="jsEditor" style="display: none;"></textarea>
                <div class="json-output" id="jsonOutput" style="display: none;"></div>
            </div>

            <div class="controls">
                <button class="control-button" onclick="screenshotWithPrompt()" id="screenshotBtn" style="display: none;">📸 Screenshot</button>
                <button class="control-button" onclick="showImageGenerationDialog()" id="generateImageBtn" style="display: none;">Generate Image</button>
                <button class="control-button" onclick="showMemoryDialog()">📜 History</button>
                <button class="control-button" onclick="toggleEditMode()" id="manualEditModeBtn">✏️ Manual Edit Mode</button>
                <button class="control-button primary" onclick="exportToOxygen()">📤 Export to Oxygen</button>
            </div>
        </div>
    </div>
    
    <!-- Image Generation Dialog -->
    <div id="imageGenDialog" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; border-radius: 12px; padding: 30px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
            <h2 style="margin: 0 0 20px 0; color: #333;">🎨 Generate Image with AI</h2>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Upload reference images (optional):</label>
                <input type="file" id="imageInputFiles" multiple accept="image/*" onchange="handleImageSelection(this)" 
                    style="display: none;">
                <button onclick="document.getElementById('imageInputFiles').click()" 
                    style="padding: 10px 20px; background: #f0f0f0; border: 1px solid #e4e4e7; border-radius: 6px; cursor: pointer; margin-bottom: 10px;">
                    📁 Choose Images
                </button>
                <div id="selectedImagesPreview" style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px;"></div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Describe the image you want:</label>
                <textarea id="imagePrompt" placeholder="E.g., A modern hero section background with abstract geometric shapes in purple and blue gradients" 
                    style="width: 100%; min-height: 100px; padding: 12px; border: 1px solid #e4e4e7; border-radius: 6px; font-size: 14px; resize: vertical;"></textarea>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Image Size:</label>
                <select id="imageSize" style="width: 100%; padding: 10px; border: 1px solid #e4e4e7; border-radius: 6px;">
                    <option value="1024x1024">Square (1024x1024)</option>
                    <option value="1792x1024">Landscape (1792x1024)</option>
                    <option value="1024x1792">Portrait (1024x1792)</option>
                </select>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold; color: #555;">Insert as:</label>
                <select id="imageInsertType" style="width: 100%; padding: 10px; border: 1px solid #e4e4e7; border-radius: 6px;">
                    <option value="img">Image Element (&lt;img&gt;)</option>
                    <option value="background">CSS Background</option>
                    <option value="hero">Hero Section with Image</option>
                </select>
            </div>
            
            <div id="imageGenLoading" style="display: none; text-align: center; padding: 20px;">
                <div style="font-size: 40px; animation: spin 1s linear infinite;">🎨</div>
                <p style="margin-top: 10px; color: #71717a;">Generating your image...</p>
            </div>
            
            <div id="imageGenResult" style="display: none; margin: 20px 0;">
                <img id="generatedImagePreview" style="max-width: 100%; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);" />
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                <button onclick="closeImageGenDialog()" style="padding: 10px 20px; background: #f0f0f0; border: none; border-radius: 6px; cursor: pointer;">Cancel</button>
                <button onclick="generateImage()" id="generateImageButton" style="padding: 10px 20px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">Generate Image</button>
                <button onclick="insertGeneratedImage()" id="insertImageButton" style="display: none; padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">Insert Image</button>
            </div>
        </div>
    </div>
    
    <!-- Context Menu for Preview Elements -->
    <div id="contextMenu" style="display: none; position: absolute; background: white; border: 1px solid #e4e4e7; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 9999; min-width: 200px;">
        <div style="padding: 8px 0;">
            <div class="context-menu-item" onclick="editElementText()" style="padding: 10px 20px; cursor: pointer; font-size: 14px;">
                ✏️ Edit Text
            </div>
            <div class="context-menu-item" onclick="editElementStyles()" style="padding: 10px 20px; cursor: pointer; font-size: 14px;">
                🎨 Edit Styles
            </div>
            <div class="context-menu-item" onclick="editElementPadding()" style="padding: 10px 20px; cursor: pointer; font-size: 14px;">
                📐 Edit Padding/Margin
            </div>
            <div class="context-menu-item" onclick="editElementLink()" id="editLinkOption" style="padding: 10px 20px; cursor: pointer; font-size: 14px;">
                🔗 Edit Link
            </div>
            <div class="context-menu-item" onclick="editElementBackground()" style="padding: 10px 20px; cursor: pointer; font-size: 14px;">
                🖼️ Edit Background
            </div>
            <div class="context-menu-item" onclick="addImageToElement()" style="padding: 10px 20px; cursor: pointer; font-size: 14px; border-top: 1px solid #eee;">
                ➕ Add Image Here
            </div>
            <div class="context-menu-item" onclick="duplicateElement()" style="padding: 10px 20px; cursor: pointer; font-size: 14px;">
                📋 Duplicate
            </div>
            <div class="context-menu-item" onclick="deleteElement()" style="padding: 10px 20px; cursor: pointer; font-size: 14px; color: #dc3545;">
                🗑️ Delete
            </div>
        </div>
    </div>
    
    <!-- Property Editor Modal -->
    <div id="propertyEditor" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10001;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 12px; padding: 25px; width: 90%; max-width: 500px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
            <h3 id="editorTitle" style="margin-top: 0; color: #333; border-bottom: 2px solid #667eea; padding-bottom: 10px;">Edit Property</h3>
            <div id="editorContent" style="margin: 20px 0;">
                <!-- Dynamic content will be inserted here -->
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="cancelPropertyEdit()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer;">Cancel</button>
                <button onclick="applyPropertyEdit()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;">Apply</button>
            </div>
        </div>
    </div>
    
    <!-- Memory Dialog Modal -->
    <div id="memoryDialog" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 12px; padding: 30px; width: 90%; max-width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3);">
            <h2 style="margin-top: 0; color: #333; border-bottom: 2px solid #667eea; padding-bottom: 10px;">📜 Conversation History</h2>
            
            <div id="memoryStats" style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <!-- Stats will be populated here -->
            </div>
            
            <div id="memoryList" style="max-height: 300px; overflow-y: auto; margin: 20px 0;">
                <!-- Memory items will be populated here -->
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                <button onclick="clearMemory()" style="padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 6px; cursor: pointer;">Clear All Memory</button>
                <button onclick="closeMemoryDialog()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;">Close</button>
            </div>
        </div>
    </div>

    <script>
        let currentHTML = '';
        let currentCSS = '';
        let currentJS = '';
        let lastKnownGoodCSS = ''; // Backup for CSS recovery
        let lastKnownGoodJS = ''; // Backup for JS recovery
        let currentJSON = {};
        let conversationHistory = [];
        let conversationMemory = []; // Long-term memory storage
        let postId = 1;
        let currentMode = 'add'; // 'add', 'edit', 'reference', or 'plan'
        let selectedElement = null;
        let elementPickerActive = false;
        let referenceData = null; // Store fetched reference data
        let contextMenuTarget = null; // Store the element being edited via context menu
        let originalElementState = null; // Store original state for undo
        let isPlanMode = false; // Track if we're in planning phase
        let isEditMode = false; // Track if edit mode is active
        let plannedTasks = []; // Store planned tasks
        let currentTaskIndex = 0; // Track current task being worked on
        
        // Composable chat window management
        let chatWindowElement = null;
        let chatWindowOriginalParent = null;
        let chatWindowIsFloating = false;
        
        function createChatWindow() {
            // Return existing chat window if already created
            if (chatWindowElement) {
                return chatWindowElement;
            }
            
            // Get the existing chat panel from DOM
            chatWindowElement = document.querySelector('.chat-panel');
            if (chatWindowElement) {
                chatWindowOriginalParent = chatWindowElement.parentElement;
                return chatWindowElement;
            }
            
            // If somehow it doesn't exist, return null (shouldn't happen)
            console.log('Chat panel not found!');
            return null;
        }
        
        function attachChatToFullscreen(fullscreenContainer) {
            const chatWindow = createChatWindow();
            if (!chatWindow) {
                console.log('No chat window found to attach');
                return;
            }
            
            console.log('Attaching chat to fullscreen, chat window:', chatWindow);
            
            // Store original parent if not already stored
            if (!chatWindowOriginalParent) {
                chatWindowOriginalParent = chatWindow.parentElement;
            }
            
            // Create floating wrapper (minimal, just for positioning)
            const floatingWrapper = document.createElement('div');
            floatingWrapper.id = 'floatingChatWrapper';
            floatingWrapper.style.cssText = `
                position: fixed;
                left: 20px;
                top: 80px;
                bottom: 20px;
                width: 400px;
                z-index: 100000;
                display: none;
                resize: horizontal;
                min-width: 300px;
                max-width: 600px;
            `;
            
            // Move chat window directly to floating wrapper
            floatingWrapper.appendChild(chatWindow);
            fullscreenContainer.appendChild(floatingWrapper);
            
            // Apply floating styles to chat window
            chatWindow.style.height = '100%';
            chatWindow.style.display = 'flex';
            chatWindow.style.flexDirection = 'column';
            chatWindow.style.background = 'white';
            chatWindow.style.borderRadius = '12px';
            chatWindow.style.boxShadow = '0 10px 40px rgba(0,0,0,0.2)';
            chatWindow.style.overflow = 'hidden';
            
            // Add close button to existing chat header
            const chatHeader = chatWindow.querySelector('.chat-header');
            if (chatHeader && !chatHeader.querySelector('.fullscreen-close-btn')) {
                const closeBtn = document.createElement('button');
                closeBtn.className = 'fullscreen-close-btn settings-toggle';
                closeBtn.onclick = toggleFullscreenChat;
                closeBtn.style.cssText = `
                    margin-left: 8px;
                `;
                closeBtn.title = 'Close Chat';
                closeBtn.innerHTML = `
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                `;
                chatHeader.appendChild(closeBtn);
                
                // Make the header draggable
                chatHeader.style.cursor = 'move';
                makeDraggable(floatingWrapper, chatHeader);
            }
            
            // Mark as floating
            chatWindowIsFloating = true;
            chatWindow.dataset.floating = 'true';
            
            console.log('Floating wrapper created and attached:', document.getElementById('floatingChatWrapper'));
        }
        
        function restoreChatToOriginal() {
            const chatWindow = chatWindowElement;
            if (!chatWindow || !chatWindowOriginalParent) return;
            
            // Remove from floating wrapper
            const floatingWrapper = document.getElementById('floatingChatWrapper');
            if (floatingWrapper) {
                floatingWrapper.remove();
            }
            
            // Restore original styles
            chatWindow.style.height = '';
            chatWindow.style.display = '';
            chatWindow.style.flexDirection = '';
            chatWindow.style.background = '';
            chatWindow.style.borderRadius = '';
            chatWindow.style.boxShadow = '';
            chatWindow.style.overflow = '';
            
            // Remove the close button we added
            const closeBtn = chatWindow.querySelector('.fullscreen-close-btn');
            if (closeBtn) {
                closeBtn.remove();
            }
            
            // Restore header cursor
            const chatHeader = chatWindow.querySelector('.chat-header');
            if (chatHeader) {
                chatHeader.style.cursor = '';
            }
            
            // Move back to original parent at the beginning (left side)
            // Use prepend to ensure it goes to the beginning, maintaining left position
            chatWindowOriginalParent.prepend(chatWindow);
            
            // Mark as not floating
            chatWindowIsFloating = false;
            delete chatWindow.dataset.floating;
        }
        
        function makeDraggable(element, handle) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
            handle.onmousedown = dragMouseDown;
            
            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }
            
            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }
        
        // Memory management constants
        const MAX_MEMORY_ITEMS = 50; // Maximum number of memory items to store
        const MEMORY_STORAGE_KEY = 'vibecoder_memory';
        const CONVERSATION_STORAGE_KEY = 'vibecoder_conversation';
        
        // Multimodal models that support image input
        const multimodalModels = [
            'anthropic/claude-3.5-sonnet',
            'anthropic/claude-sonnet-4', 
            'anthropic/claude-3-opus',
            'anthropic/claude-3-sonnet',
            'anthropic/claude-3-haiku',
            'google/gemini-2.5-pro',
            'google/gemini-2.5-flash',
            'google/gemini-pro-1.5',
            'google/gemini-pro',
            'openai/gpt-4o',
            'openai/gpt-4-turbo',
            'openai/gpt-5'
        ];

        // Hide context menu when clicking outside
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('contextMenu');
            if (!menu.contains(e.target)) {
                hideContextMenu();
            }
        });
        
        // Hardcoded model context lengths for performance
        const modelContextLengths = {
            'x-ai/grok-code-fast-1': 128000,
            'openai/gpt-5': 200000,
            'x-ai/grok-4': 128000,
            'google/gemini-2.5-flash': 1000000,
            'google/gemini-2.5-pro': 2000000,
            'anthropic/claude-sonnet-4': 200000,
            'google/gemini-2.5-flash-image-preview': 1000000
        };
        
        
        function getModelContextLength(modelId) {
            return modelContextLengths[modelId] || 128000; // Default to 128K if not found
        }
        
        // Load saved API key and memory on startup
        window.onload = function() {
            
            const savedKey = localStorage.getItem('openrouter_api_key');
            const savedModel = localStorage.getItem('openrouter_model');
            const savedVisionModel = localStorage.getItem('openrouter_vision_model');
            const savedImageGenModel = localStorage.getItem('openrouter_image_gen_model');
            const savedSystemPrompt = localStorage.getItem('vibe_system_prompt');
            const savedBrandGuidelines = localStorage.getItem('vibe_brand_guidelines');
            const savedImagePromptTemplate = localStorage.getItem('vibe_image_prompt_template');
            const savedAutoGenerate = localStorage.getItem('vibe_auto_generate_images');
            
            if (savedKey) {
                document.getElementById('apiKey').value = savedKey;
            }
            if (savedModel) {
                document.getElementById('modelSelect').value = savedModel;
                checkMultimodalSupport(savedModel);
            }
            if (savedVisionModel) {
                document.getElementById('visionModelSelect').value = savedVisionModel;
            }
            // Always enable screenshot button since we have a vision model by default
            document.getElementById('screenshotBtn').style.display = 'inline-block';
            
            // Always enable image generation buttons since we have an image model by default
            document.getElementById('generateImageBtn').style.display = 'inline-block';
            document.getElementById('autoGenerateBtn').style.display = 'inline-block';
            if (savedSystemPrompt) {
                document.getElementById('systemPrompt').value = savedSystemPrompt;
            }
            if (savedBrandGuidelines) {
                document.getElementById('brandGuidelines').value = savedBrandGuidelines;
            }
            if (savedImagePromptTemplate) {
                document.getElementById('imagePromptTemplate').value = savedImagePromptTemplate;
            }
            
            // Load auto-generate images checkbox state
            if (savedAutoGenerate !== null) {
                const autoGenCheckbox = document.getElementById('autoGenerateImages');
                if (autoGenCheckbox) {
                    autoGenCheckbox.checked = savedAutoGenerate === 'true';
                }
            }
            
            // Add event listener to save checkbox state when changed
            const autoGenCheckbox = document.getElementById('autoGenerateImages');
            if (autoGenCheckbox) {
                autoGenCheckbox.addEventListener('change', function() {
                    localStorage.setItem('vibe_auto_generate_images', this.checked.toString());
                });
            }
            
            // Load conversation memory
            loadMemory();
            
            // Load last conversation if exists
            loadLastConversation();
            
            // Apply collapsed state for suggestions
            const isCollapsed = localStorage.getItem('vibe_suggestions_collapsed') === 'true';
            if (isCollapsed) {
                const container = document.getElementById('promptSuggestions');
                if (container) {
                    container.classList.add('collapsed');
                    const toggleBtn = container.querySelector('.suggestions-toggle svg');
                    if (toggleBtn) {
                        toggleBtn.style.transform = 'rotate(-90deg)';
                    }
                }
            }
            
            updatePreview();
        };

        // Memory Management Functions
        function loadMemory() {
            try {
                const saved = localStorage.getItem(MEMORY_STORAGE_KEY);
                if (saved) {
                    conversationMemory = JSON.parse(saved);
                    console.log(`Loaded ${conversationMemory.length} memory items`);
                }
            } catch (e) {
                console.error('Error loading memory:', e);
                conversationMemory = [];
            }
        }
        
        function saveMemory() {
            try {
                // Keep only the most recent items
                if (conversationMemory.length > MAX_MEMORY_ITEMS) {
                    conversationMemory = conversationMemory.slice(-MAX_MEMORY_ITEMS);
                }
                localStorage.setItem(MEMORY_STORAGE_KEY, JSON.stringify(conversationMemory));
                console.log(`Saved ${conversationMemory.length} memory items`);
            } catch (e) {
                console.error('Error saving memory:', e);
            }
        }
        
        function addToMemory(input, response, context = {}) {
            const memoryItem = {
                timestamp: new Date().toISOString(),
                input: input,
                response: response.substring(0, 500), // Store truncated response
                mode: currentMode,
                context: {
                    hasHTML: !!currentHTML,
                    hasCSS: !!currentCSS,
                    hasJS: !!currentJS,
                    url: context.url || null
                },
                // Store code snapshot for version history
                codeSnapshot: {
                    html: currentHTML,
                    css: currentCSS,
                    js: currentJS
                }
            };
            
            conversationMemory.push(memoryItem);
            
            // Limit memory to last 50 items to prevent excessive storage
            if (conversationMemory.length > 50) {
                conversationMemory = conversationMemory.slice(-50);
            }
            
            saveMemory();
        }
        
        function loadLastConversation() {
            try {
                const saved = localStorage.getItem(CONVERSATION_STORAGE_KEY);
                if (saved) {
                    const data = JSON.parse(saved);
                    currentHTML = data.html || '';
                    currentCSS = data.css || '';
                    conversationHistory = data.history || [];
                    
                    // Update editors
                    if (currentHTML || currentCSS) {
                        document.getElementById('htmlEditor').value = currentHTML;
                        document.getElementById('cssEditor').value = currentCSS;
                        updatePreview();
                        generateOxygenJSON();
                        
                        showMessage('assistant', '💾 Restored your last session. Continue where you left off!');
                    }
                }
            } catch (e) {
                console.error('Error loading last conversation:', e);
            }
        }
        
        function saveCurrentConversation() {
            try {
                const data = {
                    html: currentHTML,
                    css: currentCSS,
                    history: conversationHistory.slice(-10), // Keep last 10 messages
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem(CONVERSATION_STORAGE_KEY, JSON.stringify(data));
            } catch (e) {
                console.error('Error saving conversation:', e);
            }
        }
        
        function getMemoryContext() {
            // Get relevant memory for context
            if (conversationMemory.length === 0) return '';
            
            // Get recent relevant memories
            const recentMemories = conversationMemory.slice(-5);
            let context = '\n\n[MEMORY CONTEXT]\n';
            context += 'Recent work in this session:\n';
            
            recentMemories.forEach((mem, idx) => {
                const date = new Date(mem.timestamp);
                const timeAgo = getTimeAgo(date);
                context += `${idx + 1}. ${timeAgo}: User asked about "${mem.input.substring(0, 50)}..." in ${mem.mode} mode\n`;
            });
            
            return context;
        }
        
        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            let interval = seconds / 31536000;
            if (interval > 1) return Math.floor(interval) + " years ago";
            
            interval = seconds / 2592000;
            if (interval > 1) return Math.floor(interval) + " months ago";
            
            interval = seconds / 86400;
            if (interval > 1) return Math.floor(interval) + " days ago";
            
            interval = seconds / 3600;
            if (interval > 1) return Math.floor(interval) + " hours ago";
            
            interval = seconds / 60;
            if (interval > 1) return Math.floor(interval) + " minutes ago";
            
            return "Just now";
        }
        
        function clearMemory() {
            if (confirm('Are you sure you want to clear all conversation memory? This cannot be undone.')) {
                conversationMemory = [];
                conversationHistory = [];
                localStorage.removeItem(MEMORY_STORAGE_KEY);
                localStorage.removeItem(CONVERSATION_STORAGE_KEY);
                showMessage('assistant', '🧹 Memory cleared. Starting fresh!');
                closeMemoryDialog();
            }
        }
        
        function showMemoryDialog() {
            const dialog = document.getElementById('memoryDialog');
            const statDiv = document.getElementById('memoryStats');
            const listDiv = document.getElementById('memoryList');
            
            // Show stats
            const totalMemory = conversationMemory.length;
            const todayMemory = conversationMemory.filter(m => {
                const date = new Date(m.timestamp);
                const today = new Date();
                return date.toDateString() === today.toDateString();
            }).length;
            
            statDiv.innerHTML = `
                <div style="display: flex; justify-content: space-around;">
                    <div style="text-align: center;">
                        <div style="font-size: 24px; font-weight: bold; color: #667eea;">${totalMemory}</div>
                        <div style="font-size: 12px; color: #71717a;">Total Memories</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 24px; font-weight: bold; color: #28a745;">${todayMemory}</div>
                        <div style="font-size: 12px; color: #71717a;">Today's Sessions</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 24px; font-weight: bold; color: #17a2b8;">${conversationHistory.length}</div>
                        <div style="font-size: 12px; color: #71717a;">Current Chat</div>
                    </div>
                </div>
            `;
            
            // Show memory list
            if (conversationMemory.length === 0) {
                listDiv.innerHTML = '<p style="text-align: center; color: #999;">No memories yet. Start creating!</p>';
            } else {
                const memories = conversationMemory.slice().reverse(); // Show newest first
                listDiv.innerHTML = memories.slice(0, 20).map((mem, index) => {
                    const date = new Date(mem.timestamp);
                    const timeAgo = getTimeAgo(date);
                    const modeIcon = mem.mode === 'add' ? '➕' : (mem.mode === 'edit' ? '✏️' : '🔗');
                    const memIndex = conversationMemory.length - 1 - index; // Get actual index in array
                    
                    // Check if this version has code
                    const hasCode = mem.codeSnapshot && (mem.codeSnapshot.html || mem.codeSnapshot.css || mem.codeSnapshot.js);
                    
                    return `
                        <div style="background: #f8f9fa; padding: 12px; margin: 8px 0; border-radius: 8px; border-left: 3px solid #667eea;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                <span style="font-weight: 500; color: #333;">${modeIcon} ${mem.mode.toUpperCase()} Mode</span>
                                <span style="font-size: 12px; color: #999;">${timeAgo}</span>
                            </div>
                            <div style="font-size: 14px; color: #71717a; margin-bottom: 5px;">
                                <strong>Q:</strong> ${mem.input.substring(0, 100)}${mem.input.length > 100 ? '...' : ''}
                            </div>
                            <div style="font-size: 13px; color: #888; margin-bottom: 8px;">
                                <strong>A:</strong> ${mem.response.substring(0, 150)}${mem.response.length > 150 ? '...' : ''}
                            </div>
                            ${hasCode ? `
                                <div style="display: flex; gap: 8px; margin-top: 8px;">
                                    <button onclick="restoreCodeVersion(${memIndex})" style="background: #667eea; color: white; border: none; padding: 6px 12px; border-radius: 6px; background: white; font-size: 12px; cursor: pointer;">
                                        🔄 Restore This Version
                                    </button>
                                    <button onclick="viewCodeSnapshot(${memIndex})" style="background: #6c757d; color: white; border: none; padding: 6px 12px; border-radius: 6px; background: white; font-size: 12px; cursor: pointer;">
                                        👁️ Preview Code
                                    </button>
                                </div>
                            ` : '<div style="font-size: 11px; color: #999; font-style: italic;">No code snapshot available</div>'}
                        </div>
                    `;
                }).join('');
            }
            
            dialog.style.display = 'block';
        }
        
        function closeMemoryDialog() {
            document.getElementById('memoryDialog').style.display = 'none';
        }
        
        function restoreCodeVersion(index) {
            const memory = conversationMemory[index];
            if (!memory || !memory.codeSnapshot) {
                alert('No code snapshot available for this version');
                return;
            }
            
            if (confirm(`Restore code from "${memory.input.substring(0, 50)}..."?\n\nThis will replace your current code.`)) {
                // Restore the code
                currentHTML = memory.codeSnapshot.html || '';
                currentCSS = memory.codeSnapshot.css || '';
                currentJS = memory.codeSnapshot.js || '';
                
                // Update editors
                document.getElementById('htmlEditor').value = currentHTML;
                document.getElementById('cssEditor').value = currentCSS;
                document.getElementById('jsEditor').value = currentJS;
                
                // Update preview
                updatePreview();
                generateOxygenJSON();
                
                // Close dialog and show success message
                closeMemoryDialog();
                showMessage('assistant', `✅ Restored code version from ${getTimeAgo(new Date(memory.timestamp))}`);
            }
        }
        
        function viewCodeSnapshot(index) {
            const memory = conversationMemory[index];
            if (!memory || !memory.codeSnapshot) {
                alert('No code snapshot available for this version');
                return;
            }
            
            // Create a modal to show the code
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                z-index: 10002;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                border-radius: 12px;
                max-width: 900px;
                max-height: 80vh;
                width: 100%;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            `;
            
            content.innerHTML = `
                <div style="padding: 20px; border-bottom: 1px solid #e9ecef;">
                    <h3 style="margin: 0; color: #333;">Code Snapshot - ${getTimeAgo(new Date(memory.timestamp))}</h3>
                    <p style="margin: 5px 0 0 0; color: #71717a; font-size: 14px;">${memory.input.substring(0, 100)}...</p>
                </div>
                <div style="flex: 1; overflow-y: auto; padding: 20px;">
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #667eea; margin-bottom: 10px;">HTML</h4>
                        <pre style="background: #f8f9fa; padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 12px; max-height: 200px;">${escapeHtml(memory.codeSnapshot.html || 'No HTML')}</pre>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #667eea; margin-bottom: 10px;">CSS</h4>
                        <pre style="background: #f8f9fa; padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 12px; max-height: 200px;">${escapeHtml(memory.codeSnapshot.css || 'No CSS')}</pre>
                    </div>
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: #667eea; margin-bottom: 10px;">JavaScript</h4>
                        <pre style="background: #f8f9fa; padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 12px; max-height: 200px;">${escapeHtml(memory.codeSnapshot.js || 'No JavaScript')}</pre>
                    </div>
                </div>
                <div style="padding: 20px; border-top: 1px solid #e9ecef; display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="this.closest('div[style*=\\"position: fixed\\"]').remove()" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 6px; cursor: pointer;">Close</button>
                    <button onclick="restoreCodeVersion(${index}); this.closest('div[style*=\\"position: fixed\\"]').remove()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;">Restore This Version</button>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Close on backdrop click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function toggleSettings() {
            const settingsPanel = document.getElementById('settingsPanel');
            const isVisible = settingsPanel.style.display !== 'none';
            
            if (isVisible) {
                settingsPanel.style.display = 'none';
            } else {
                settingsPanel.style.display = 'block';
                // Focus on API key input if empty
                const apiKeyInput = document.getElementById('apiKey');
                if (!apiKeyInput.value) {
                    apiKeyInput.focus();
                }
            }
        }

        function saveConfig() {
            const apiKey = document.getElementById('apiKey').value;
            const model = document.getElementById('modelSelect').value;
            const visionModel = document.getElementById('visionModelSelect').value;
            const imageGenModel = document.getElementById('imageGenModelSelect').value;
            const systemPrompt = document.getElementById('systemPrompt').value;
            const brandGuidelines = document.getElementById('brandGuidelines').value;
            const imagePromptTemplate = document.getElementById('imagePromptTemplate').value;
            
            if (!apiKey) {
                alert('Please enter your OpenRouter API key');
                return;
            }
            
            localStorage.setItem('openrouter_api_key', apiKey);
            localStorage.setItem('openrouter_model', model);
            localStorage.setItem('openrouter_vision_model', visionModel);
            localStorage.setItem('openrouter_image_gen_model', imageGenModel);
            localStorage.setItem('vibe_system_prompt', systemPrompt);
            localStorage.setItem('vibe_brand_guidelines', brandGuidelines);
            localStorage.setItem('vibe_image_prompt_template', imagePromptTemplate);
            
            checkMultimodalSupport(model);
            
            // Also enable screenshot if vision model is selected
            if (visionModel) {
                document.getElementById('screenshotBtn').style.display = 'inline-block';
            }
            
            // Always show image generation button (only one model available)
            document.getElementById('generateImageBtn').style.display = 'inline-block';
            
            // Hide settings panel after saving
            document.getElementById('settingsPanel').style.display = 'none';
            
            showMessage('assistant', '✅ Settings saved! Your system prompt and brand guidelines will be applied to all conversations.');
        }
        
        function getSystemPromptWithBrandGuidelines() {
            const customSystemPrompt = document.getElementById('systemPrompt')?.value || 
                'You are an expert web developer specializing in creating beautiful, modern web components.';
            const brandGuidelines = document.getElementById('brandGuidelines')?.value;
            
            let prompt = customSystemPrompt;
            
            if (brandGuidelines && brandGuidelines.trim()) {
                prompt += `\n\nBRAND GUIDELINES:\n${brandGuidelines}\n\nIMPORTANT: Apply these brand guidelines to all designs and components you create.`;
            }
            
            return prompt;
        }
        
        function checkMultimodalSupport(model) {
            const screenshotBtn = document.getElementById('screenshotBtn');
            if (multimodalModels.includes(model)) {
                screenshotBtn.style.display = 'inline-block';
                console.log('Multimodal model detected - screenshot feature enabled');
            } else {
                screenshotBtn.style.display = 'none';
                console.log('Text-only model - screenshot feature disabled');
            }
        }
        
        // Add event listener for model selection changes
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('modelSelect').addEventListener('change', function() {
                checkMultimodalSupport(this.value);
            });
        });

        function showMessage(role, content) {
            const messagesDiv = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'message-label';
            labelDiv.textContent = role === 'user' ? 'You' : 'AI Assistant';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = content;
            
            messageDiv.appendChild(labelDiv);
            messageDiv.appendChild(contentDiv);
            messagesDiv.appendChild(messageDiv);
            
            // Scroll to bottom
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function extractCSSContext(css) {
            if (!css) return { classes: [], variables: [], summary: '' };
            
            // Extract class names
            const classNames = [...css.matchAll(/\.([a-zA-Z0-9_-]+)/g)].map(m => m[1]);
            const uniqueClasses = [...new Set(classNames)];
            
            // Extract CSS variables
            const cssVars = [...css.matchAll(/--([a-zA-Z0-9_-]+)/g)].map(m => `--${m[1]}`);
            const uniqueVars = [...new Set(cssVars)];
            
            // Analyze common patterns
            const hasGrid = css.includes('display: grid') || css.includes('display:grid');
            const hasFlex = css.includes('display: flex') || css.includes('display:flex');
            const hasAnimations = css.includes('@keyframes');
            const hasMediaQueries = css.includes('@media');
            
            let summary = 'Design system includes: ';
            const features = [];
            if (hasGrid) features.push('Grid layouts');
            if (hasFlex) features.push('Flexbox layouts');
            if (hasAnimations) features.push('Animations');
            if (hasMediaQueries) features.push('Responsive design');
            if (uniqueVars.length > 0) features.push('CSS variables');
            
            summary += features.join(', ') || 'Basic styles';
            
            return {
                classes: uniqueClasses,
                variables: uniqueVars,
                summary: summary
            };
        }
        
        function extractPlanTasks(response) {
            // Extract numbered tasks from the AI response
            // Try multiple patterns to catch different formatting styles
            plannedTasks = [];
            
            // Pattern 1: Look for "Task Breakdown" or similar section
            const taskSectionRegex = /(?:task\s+breakdown|tasks?|step-by-step|implementation\s+steps?)[\s\S]*?(\d+\.[\s\S]+?)(?=\n\n|\n#|$)/gi;
            const taskSection = response.match(taskSectionRegex);
            
            let textToSearch = response;
            if (taskSection && taskSection[0]) {
                textToSearch = taskSection[0];
                console.log('Found task section:', textToSearch);
            }
            
            // Pattern 2: Extract numbered items (handles markdown and plain text)
            // This regex captures numbered lists with various formatting
            const patterns = [
                /^\d+\.\s+\*\*(.+?)\*\*:?\s*(.+?)(?=\n\d+\.|\n\n|$)/gm,  // **Bold** format
                /^\d+\.\s+(.+?)(?:\n|$)/gm,  // Simple numbered format
                /^[\*\-]\s+\*\*(.+?)\*\*:?\s*(.+?)(?=\n[\*\-]|\n\n|$)/gm,  // Bullet with bold
                /^[\*\-]\s+(.+?)(?:\n|$)/gm  // Simple bullet format
            ];
            
            for (const pattern of patterns) {
                const matches = [...textToSearch.matchAll(pattern)];
                
                for (const match of matches) {
                    let taskDescription = '';
                    
                    // Combine captured groups based on what was matched
                    if (match[2]) {
                        // Format with title and description
                        taskDescription = match[1] + ': ' + match[2];
                    } else {
                        // Simple format
                        taskDescription = match[1];
                    }
                    
                    // Clean up the task description
                    taskDescription = taskDescription
                        .replace(/\*\*/g, '')  // Remove markdown bold
                        .replace(/^[\*\-]\s+/, '')  // Remove bullet points
                        .replace(/^\d+\.\s+/, '')  // Remove numbers
                        .trim();
                    
                    // Filter out section headers and non-actionable items
                    if (taskDescription.length > 10 && 
                        !taskDescription.toLowerCase().includes('understanding') &&
                        !taskDescription.toLowerCase().includes('overview') &&
                        !taskDescription.toLowerCase().includes('summary') &&
                        !taskDescription.endsWith(':') &&
                        taskDescription.split(' ').length > 2) {  // At least 3 words
                        
                        // Check if this task is already in the list (avoid duplicates)
                        const isDuplicate = plannedTasks.some(t => 
                            t.description.toLowerCase().includes(taskDescription.toLowerCase()) ||
                            taskDescription.toLowerCase().includes(t.description.toLowerCase())
                        );
                        
                        if (!isDuplicate) {
                            plannedTasks.push({
                                description: taskDescription,
                                completed: false
                            });
                        }
                    }
                }
                
                // If we found tasks, stop trying other patterns
                if (plannedTasks.length > 0) {
                    break;
                }
            }
            
            // If still no tasks found, try to extract any line that starts with an action verb
            if (plannedTasks.length === 0) {
                const actionVerbs = ['create', 'build', 'add', 'implement', 'design', 'develop', 'set up', 'configure', 'integrate', 'update', 'modify', 'enhance', 'optimize'];
                const lines = response.split('\n');
                
                for (const line of lines) {
                    const cleanLine = line.trim().replace(/^[\*\-\d\.]\s+/, '').replace(/\*\*/g, '');
                    const lowerLine = cleanLine.toLowerCase();
                    
                    if (actionVerbs.some(verb => lowerLine.startsWith(verb)) && cleanLine.length > 15) {
                        plannedTasks.push({
                            description: cleanLine,
                            completed: false
                        });
                    }
                }
            }
            
            console.log('Extracted tasks:', plannedTasks);
            console.log('Total tasks found:', plannedTasks.length);
        }
        
        function showPlanExitPrompt() {
            const messagesDiv = document.getElementById('chatMessages');
            const exitPrompt = document.createElement('div');
            exitPrompt.className = 'plan-exit-prompt';
            exitPrompt.innerHTML = `
                <div style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 15px; border-radius: 8px; margin: 15px 0;">
                    <h4 style="margin: 0 0 10px 0;">📋 Planning Complete!</h4>
                    <p style="margin: 10px 0;">I've created a plan with ${plannedTasks.length} tasks. Ready to start building?</p>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button onclick="exitPlanMode()" style="background: white; color: #667eea; padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">
                            ✅ Start Building
                        </button>
                        <button onclick="continuePlanning()" style="background: rgba(255,255,255,0.2); color: white; padding: 8px 16px; border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; cursor: pointer;">
                            💭 Continue Planning
                        </button>
                    </div>
                </div>
            `;
            messagesDiv.appendChild(exitPrompt);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        function exitPlanMode() {
            if (plannedTasks.length === 0) {
                alert('No tasks have been planned yet. Please continue planning or switch to another mode.');
                return;
            }
            
            // Exit plan mode and switch to Edit mode
            isPlanMode = false;
            currentTaskIndex = 0;
            setMode('edit');
            
            // Show task tracker
            showTaskTracker();
            
            // Start working on first task
            startNextTask();
        }
        
        function continuePlanning() {
            // Just remove the prompt and continue in plan mode
            const prompt = document.querySelector('.plan-exit-prompt');
            if (prompt) prompt.remove();
        }
        
        function showTaskTracker() {
            const messagesDiv = document.getElementById('chatMessages');
            const tracker = document.createElement('div');
            tracker.id = 'taskTracker';
            tracker.className = 'task-tracker';
            tracker.innerHTML = `
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #667eea;">
                    <h4 style="margin: 0 0 10px 0; color: #333;">🚀 Task Progress</h4>
                    <div id="taskList" style="margin: 10px 0;">
                        ${plannedTasks.map((task, index) => `
                            <div class="task-item" style="padding: 8px; margin: 5px 0; background: white; border-radius: 6px; background: white; display: flex; align-items: center;">
                                <span style="margin-right: 10px;">${task.completed ? '✅' : index === currentTaskIndex ? '🔄' : '⏳'}</span>
                                <span style="flex: 1; ${index === currentTaskIndex ? 'font-weight: bold;' : ''}">${task.description}</span>
                            </div>
                        `).join('')}
                    </div>
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #dee2e6;">
                        <strong>Current Task (${currentTaskIndex + 1}/${plannedTasks.length}):</strong>
                        <p style="margin: 5px 0;">${plannedTasks[currentTaskIndex].description}</p>
                    </div>
                </div>
            `;
            messagesDiv.appendChild(tracker);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        function startNextTask() {
            if (currentTaskIndex >= plannedTasks.length) {
                showMessage('assistant', '🎉 All tasks completed! Your website is ready.');
                return;
            }
            
            const currentTask = plannedTasks[currentTaskIndex];
            const taskMessage = `Task ${currentTaskIndex + 1} of ${plannedTasks.length}: ${currentTask.description}`;
            
            // Show what task we're working on
            showMessage('user', `Please implement: ${currentTask.description}`);
            
            // Build context for the AI with emphasis on reusing classes
            let cssContext = '';
            if (currentCSS) {
                const cssInfo = extractCSSContext(currentCSS);
                cssContext = `\n\n## CSS REUSE GUIDELINES:\n`;
                cssContext += `${cssInfo.summary}\n\n`;
                
                if (cssInfo.classes.length > 0) {
                    cssContext += `MUST REUSE these existing CSS classes where appropriate:\n`;
                    cssContext += `${cssInfo.classes.join(', ')}\n\n`;
                }
                
                if (cssInfo.variables.length > 0) {
                    cssContext += `Available CSS variables to use:\n`;
                    cssContext += `${cssInfo.variables.join(', ')}\n\n`;
                }
                
                cssContext += `Guidelines:\n`;
                cssContext += `- Reuse existing classes before creating new ones\n`;
                cssContext += `- Extend existing styles rather than duplicating\n`;
                cssContext += `- Maintain consistent naming conventions\n`;
                cssContext += `- Use CSS variables for colors and spacing when available`;
            }
            
            const contextMessage = `[TASK EXECUTION MODE]\nCurrent task (${currentTaskIndex + 1}/${plannedTasks.length}): ${currentTask.description}\n\nPlease implement this specific task. Provide the HTML and CSS code needed.${cssContext}\n\nCurrent HTML:\n${currentHTML || 'None yet'}\n\nCurrent CSS:\n${currentCSS || 'None yet'}`;
            
            // Send the task to AI automatically
            setTimeout(() => {
                // Set the mode to add or edit based on whether we have content
                if (!currentHTML || currentHTML.trim() === '') {
                    setMode('edit'); // First task, start fresh
                } else {
                    setMode('add'); // Subsequent tasks, add to existing
                }
                
                // Send the implementation request
                document.getElementById('userInput').value = `Implement: ${currentTask.description}`;
                sendMessage();
            }, 500);
        }
        
        function updateTaskTracker() {
            const tracker = document.getElementById('taskTracker');
            if (!tracker) return;
            
            const taskList = document.getElementById('taskList');
            taskList.innerHTML = plannedTasks.map((task, index) => `
                <div class="task-item" style="padding: 8px; margin: 5px 0; background: white; border-radius: 6px; background: white; display: flex; align-items: center;">
                    <span style="margin-right: 10px;">${task.completed ? '✅' : index === currentTaskIndex ? '🔄' : '⏳'}</span>
                    <span style="flex: 1; ${index === currentTaskIndex ? 'font-weight: bold;' : ''}">${task.description}</span>
                </div>
            `).join('');
        }
        
        async function sendMessage() {
            const apiKey = document.getElementById('apiKey').value;
            const model = document.getElementById('modelSelect').value;
            const input = document.getElementById('userInput').value.trim();
            
            if (!apiKey) {
                alert('Please enter your OpenRouter API key first');
                return;
            }
            
            if (!input) return;
            
            // Store current content BEFORE AI modifies it (for ADD mode merging)
            const previousHTML = currentHTML;
            const previousCSS = currentCSS;
            
            // Check if there's an attached image
            if (attachedImageData) {
                // Send message with attached image
                showMessage('user', input + ' [📎 Image attached]');
                
                // Clear input and disable button
                document.getElementById('userInput').value = '';
                document.getElementById('sendButton').disabled = true;
                document.getElementById('loadingIndicator').classList.add('active');
                
                // Send with image
                await sendMessageWithImage(attachedImageData, input);
                
                // Reset attachment
                attachedImageData = null;
                const attachBtn = document.querySelector('.attach-image-button');
                attachBtn.style.background = 'white';
                attachBtn.style.color = '#667eea';
                attachBtn.innerHTML = '📎';
                document.getElementById('imageInput').value = '';
                
                return;
            }
            
            // Show user message
            showMessage('user', input);
            
            // Clear input and disable button
            document.getElementById('userInput').value = '';
            document.getElementById('sendButton').disabled = true;
            document.getElementById('loadingIndicator').classList.add('active');
            
            // Build context message based on mode
            let contextMessage = input;
            
            // Add memory context for better continuity
            const memoryContext = getMemoryContext();
            
            if (currentMode === 'plan') {
                if (isPlanMode) {
                    // We're already in planning phase, continue the discussion
                    contextMessage = `[PLAN MODE - Continue Planning]\n${input}\n\nWe are currently planning the website project. Please continue helping with the planning phase.${memoryContext}`;
                } else {
                    // First message in plan mode - start planning
                    isPlanMode = true;
                    
                    // Include existing CSS context if available
                    let existingContext = '';
                    if (currentHTML || currentCSS) {
                        existingContext = '\n\n## Existing Code Context\n';
                        if (currentCSS) {
                            const cssInfo = extractCSSContext(currentCSS);
                            existingContext += `${cssInfo.summary}\n`;
                            if (cssInfo.classes.length > 0) {
                                existingContext += `Existing CSS classes to reuse: ${cssInfo.classes.join(', ')}\n`;
                            }
                            if (cssInfo.variables.length > 0) {
                                existingContext += `CSS variables available: ${cssInfo.variables.join(', ')}\n`;
                            }
                            existingContext += 'IMPORTANT: Plan tasks that reuse these existing styles for consistency.\n';
                        }
                        if (currentHTML) {
                            existingContext += 'Note: There is already existing HTML content that new features should integrate with.\n';
                        }
                    }
                    
                    contextMessage = `[PLAN MODE - Initial Planning]\n${input}${existingContext}\n\nPlease help me plan this website project. First, understand the requirements, then create a detailed plan with clear tasks. 

Format your response as:

## 1. Project Understanding
[Brief description of what the user wants]

## 2. Key Features
[List the main features needed]

## 3. Technical Approach
[Describe the technical strategy]
${currentCSS ? '- Reuse existing CSS classes where appropriate for consistency' : ''}

## 4. Task Breakdown
Please provide a numbered list of specific, actionable tasks:
1. Create the header section with navigation menu
2. Build the hero section with call-to-action
3. Implement the features section
[etc...]

Each task should be specific and actionable. Do not generate any code yet. Focus only on planning.${memoryContext}`;
                }
            } else if (currentMode === 'edit' && selectedElement) {
                // Extract CSS classes for context
                let cssClassContext = '';
                if (currentCSS) {
                    const classNames = [...currentCSS.matchAll(/\.([a-zA-Z0-9_-]+)/g)].map(m => m[1]);
                    const uniqueClasses = [...new Set(classNames)];
                    if (uniqueClasses.length > 0) {
                        cssClassContext = `\n\nExisting CSS classes (reuse these for consistency): ${uniqueClasses.slice(0, 20).join(', ')}${uniqueClasses.length > 20 ? '...' : ''}`;
                    }
                }
                contextMessage = `[EDIT MODE - Selected Element: ${selectedElement.selector}]\n${input}\n\nCurrent element HTML:\n${selectedElement.html}${cssClassContext}${memoryContext}`;
            } else if (currentMode === 'add') {
                // Extract CSS classes for context
                let cssClassContext = '';
                if (currentCSS) {
                    const classNames = [...currentCSS.matchAll(/\.([a-zA-Z0-9_-]+)/g)].map(m => m[1]);
                    const uniqueClasses = [...new Set(classNames)];
                    if (uniqueClasses.length > 0) {
                        cssClassContext = `\n\nIMPORTANT: Reuse these existing CSS classes where appropriate:\n${uniqueClasses.join(', ')}\n`;
                    }
                }
                contextMessage = `[ADD MODE - Create NEW content only]\n${input}${cssClassContext}\n\nIMPORTANT: Return ONLY the new HTML and CSS to be added. Do NOT include existing content.\n\nExisting HTML structure for context:\n${currentHTML ? currentHTML.substring(0, 500) + '...' : 'None'}\n\nExisting CSS classes you can reuse:\n${cssClassContext}${memoryContext}`;
            } else if (currentMode === 'reference' && referenceData) {
                contextMessage = `[REFERENCE MODE - Recreate similar design]\n${input}\n\nReference URL: ${referenceData.url}\n\n`;
                if (referenceData.html) {
                    // Include a snippet of the reference HTML structure
                    const snippet = referenceData.html.substring(0, 2000);
                    contextMessage += `Reference HTML structure (truncated):\n${snippet}...\n\n`;
                    if (referenceData.css) {
                        const cssSnippet = referenceData.css.substring(0, 1000);
                        contextMessage += `Reference CSS (truncated):\n${cssSnippet}...\n\n`;
                    }
                } else {
                    contextMessage += `User wants to recreate elements from: ${referenceData.url}\n`;
                }
                contextMessage += `\nIMPORTANT: Create a similar design inspired by the reference, but make it modern and unique. Don't copy exactly.${memoryContext}`;
            }
            
            // Add to conversation history
            conversationHistory.push({ role: 'user', content: contextMessage });
            
            try {
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Vibe Coder for Oxygen'
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [
                            {
                                role: 'system',
                                content: getSystemPromptWithBrandGuidelines() + `

CRITICAL MODE HANDLING:
- [ADD MODE]: When you see "[ADD MODE]", return ONLY the NEW content to be added. Do NOT include any existing HTML/CSS - just the new elements you're creating.
- [EDIT MODE]: When you see "[EDIT MODE]", MODIFY only the specified element while preserving everything else. Include the COMPLETE HTML/CSS with your edits applied.
- [REFERENCE MODE]: When you see "[REFERENCE MODE]", CREATE a similar design inspired by the reference website. Analyze the structure and style, but create your own modern interpretation. Don't copy exactly - improve upon it with modern design patterns.

IMPORTANT: You MUST follow this EXACT format for ALL responses:

[EXPLANATION]
Brief description of what you created or modified

[HTML]
\`\`\`html
(In ADD MODE: ONLY new HTML to be added, no existing content)
(In EDIT MODE: complete HTML with modifications)
\`\`\`

[CSS]
\`\`\`css
(In ADD MODE: ONLY new CSS for the new elements, no existing styles)
(In EDIT MODE: complete CSS with modifications)
\`\`\`

CRITICAL RULES:
1. In ADD MODE: Return ONLY new content - system will append it automatically
2. In EDIT MODE: Return complete HTML/CSS with targeted edits
3. ALWAYS include both [HTML] and [CSS] sections
4. ALWAYS use triple backticks with language identifier
5. NEVER delete existing content unless explicitly asked
6. Create beautiful, production-ready components with:
   - Modern design patterns
   - Gradients, shadows, and smooth transitions
   - Responsive design (mobile-first)
   - Proper spacing and typography
   - Hover effects and micro-interactions

Example ADD MODE:
User: [ADD MODE] Add a footer
Response: ONLY the new footer HTML and ONLY the new footer CSS

Example EDIT MODE:
User: [EDIT MODE - Selected: h1] Make the heading larger
Response: Include all HTML with h1 modified, all CSS with h1 styles updated

Remember: In ADD MODE return ONLY new content, in EDIT MODE return COMPLETE code!`
                            },
                            ...conversationHistory
                        ],
                        temperature: 0.7,
                        max_tokens: getModelContextLength(model)
                    })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error.message || 'API request failed');
                }
                
                const aiResponse = data.choices[0].message.content;
                
                // Add to conversation history
                conversationHistory.push({ role: 'assistant', content: aiResponse });
                
                // Handle Plan mode differently
                let displayMessage = aiResponse;
                
                if (currentMode === 'plan' && isPlanMode) {
                    // In plan mode, just show the response without parsing code
                    showMessage('assistant', aiResponse);
                    
                    // Check if AI has provided a task list (more flexible detection)
                    const hasTaskIndicators = 
                        aiResponse.toLowerCase().includes('task') ||
                        aiResponse.toLowerCase().includes('step') ||
                        aiResponse.toLowerCase().includes('implementation') ||
                        aiResponse.includes('1.') ||
                        aiResponse.includes('- ') ||
                        aiResponse.includes('* ');
                    
                    if (hasTaskIndicators) {
                        // Extract tasks from the response
                        extractPlanTasks(aiResponse);
                        
                        // Only show exit prompt if we actually found tasks
                        if (plannedTasks.length > 0) {
                            setTimeout(() => {
                                showPlanExitPrompt();
                            }, 500);
                        } else {
                            // If no tasks were extracted, show a hint to the user
                            setTimeout(() => {
                                showMessage('assistant', '💡 Tip: I\'m ready to help plan your project. Please describe what you want to build, and I\'ll create a detailed task list for implementation.');
                            }, 1000);
                        }
                    }
                } else {
                    // Normal mode - parse and extract code from response
                    parseAIResponse(aiResponse, previousHTML, previousCSS, currentJS);
                    
                    // Show AI message
                    displayMessage = aiResponse.split('[HTML]')[0].replace('[EXPLANATION]', '').trim();
                    showMessage('assistant', displayMessage);
                    
                    // Check if we're working on tasks
                    if (plannedTasks.length > 0 && currentTaskIndex < plannedTasks.length) {
                        // Mark current task as complete and move to next
                        plannedTasks[currentTaskIndex].completed = true;
                        currentTaskIndex++;
                        updateTaskTracker();
                        
                        // Start next task after a delay
                        if (currentTaskIndex < plannedTasks.length) {
                            setTimeout(() => {
                                startNextTask();
                            }, 2000);
                        } else {
                            showMessage('assistant', '🎉 All planned tasks have been completed! Your website is ready.');
                        }
                    }
                }
                
                // Add to memory
                addToMemory(input, displayMessage, { url: referenceData?.url });
                
                // Save current conversation state
                saveCurrentConversation();
                
            } catch (error) {
                showMessage('assistant', `Error: ${error.message}`);
            } finally {
                document.getElementById('sendButton').disabled = false;
                document.getElementById('loadingIndicator').classList.remove('active');
            }
        }

        function extractHTML(response) {
            console.log('Attempting to extract HTML from response');
            
            // Check if response is truncated (cutoff in middle of content)
            const isTruncated = response.length > 7500 || 
                              (response.includes('```') && !response.match(/```[\s\S]*?```/g));
            
            if (isTruncated) {
                console.warn('Response appears to be truncated, attempting partial extraction');
            }
            
            // Pattern 1: Standard markdown code block with html language
            let match = response.match(/```html\s*\n([\s\S]*?)```/i);
            if (match) {
                console.log('Found HTML using pattern 1: ```html');
                return match[1].trim();
            }
            
            // Pattern 2: Code block without newline
            match = response.match(/```html([\s\S]*?)```/i);
            if (match) {
                console.log('Found HTML using pattern 2: ```html (no newline)');
                return match[1].trim();
            }
            
            // Pattern 3: [HTML] section with any code block (handle incomplete blocks)
            match = response.match(/\[HTML\][\s\S]*?```(?:html)?\s*\n?([\s\S]*?)(?:```|$)/i);
            if (match) {
                console.log('Found HTML using pattern 3: [HTML] section');
                return match[1].trim();
            }
            
            // Pattern 4: Look for HTML section header then next code block
            const htmlMarkerIndex = response.search(/\[HTML\]/i);
            if (htmlMarkerIndex !== -1) {
                const afterMarker = response.substring(htmlMarkerIndex);
                match = afterMarker.match(/```\s*\n?([\s\S]*?)```/);
                if (match) {
                    console.log('Found HTML using pattern 4: [HTML] then code block');
                    return match[1].trim();
                }
            }
            
            // Pattern 5: Plain HTML section without code blocks (between [HTML] and next section)
            match = response.match(/\[HTML\]\s*\n([\s\S]*?)(?:\[|$)/i);
            if (match && match[1].trim()) {
                const content = match[1].trim();
                // Check if it looks like HTML
                if (content.includes('<') && content.includes('>')) {
                    console.log('Found HTML using pattern 5: Plain HTML after [HTML]');
                    return content;
                }
            }
            
            // Pattern 6: Generic code block after "HTML" keyword
            match = response.match(/\bHTML\b[\s\S]{0,50}```\s*\n?([\s\S]*?)```/i);
            if (match) {
                console.log('Found HTML using pattern 6: HTML keyword then code block');
                return match[1].trim();
            }
            
            // Pattern 7: Check if there's a code block that looks like HTML
            const allCodeBlocks = response.matchAll(/```(?:\w*\s*)?\n?([\s\S]*?)```/g);
            for (const block of allCodeBlocks) {
                const content = block[1].trim();
                // Check if it looks like HTML
                if (content.includes('<') && content.includes('>') &&
                    (content.includes('</') || content.match(/<[a-zA-Z]+[^>]*>/))) {
                    // Skip if it's clearly CSS
                    if (!content.includes('{') || content.includes('<')) {
                        console.log('Found HTML using pattern 7: Code block with HTML-like content');
                        return content;
                    }
                }
            }
            
            // Pattern 8: Last resort - find anything between [HTML] and [CSS] or end
            const htmlStart = response.search(/\[HTML\]/i);
            if (htmlStart !== -1) {
                const cssStart = response.search(/\[CSS\]/i);
                const jsStart = response.search(/\[(?:JS|JAVASCRIPT)\]/i);
                const explainStart = response.search(/\[EXPLANATION\]/i);
                
                let endIndex = response.length;
                if (cssStart > htmlStart) endIndex = Math.min(endIndex, cssStart);
                if (jsStart > htmlStart) endIndex = Math.min(endIndex, jsStart);
                if (explainStart > htmlStart) endIndex = Math.min(endIndex, explainStart);
                
                const htmlContent = response.substring(htmlStart + 6, endIndex).trim();
                // Remove any remaining backticks
                const cleaned = htmlContent.replace(/^```(?:html)?\s*|\s*```$/gi, '').trim();
                
                if (cleaned && cleaned.includes('<')) {
                    console.log('Found HTML using pattern 8: Content between [HTML] and next section');
                    return cleaned;
                }
            }
            
            console.log('No HTML found after trying all patterns');
            return null; // Return null to indicate no HTML was found
        }
        
        function extractCSS(response) {
            console.log('Attempting to extract CSS from response');
            
            // Pattern 1: Standard markdown code block with css language
            let match = response.match(/```css\s*\n([\s\S]*?)```/i);
            if (match) {
                console.log('Found CSS using pattern 1: ```css');
                return match[1].trim();
            }
            
            // Pattern 2: Code block without newline
            match = response.match(/```css([\s\S]*?)```/i);
            if (match) {
                console.log('Found CSS using pattern 2: ```css (no newline)');
                return match[1].trim();
            }
            
            // Pattern 3: [CSS] section with any code block
            match = response.match(/\[CSS\][\s\S]*?```(?:css)?\s*\n?([\s\S]*?)```/i);
            if (match) {
                console.log('Found CSS using pattern 3: [CSS] section');
                return match[1].trim();
            }
            
            // Pattern 4: Look for CSS section header then next code block
            const cssMarkerIndex = response.search(/\[CSS\]/i);
            if (cssMarkerIndex !== -1) {
                const afterMarker = response.substring(cssMarkerIndex);
                match = afterMarker.match(/```\s*\n?([\s\S]*?)```/);
                if (match) {
                    console.log('Found CSS using pattern 4: [CSS] then code block');
                    return match[1].trim();
                }
            }
            
            // Pattern 5: Plain CSS section without code blocks (between [CSS] and next section)
            match = response.match(/\[CSS\]\s*\n([\s\S]*?)(?:\[|$)/i);
            if (match && match[1].trim()) {
                // Check if it looks like CSS (has curly braces or common CSS properties)
                const content = match[1].trim();
                if (content.includes('{') || content.includes('}') || 
                    content.includes(':') || content.includes(';')) {
                    console.log('Found CSS using pattern 5: Plain CSS after [CSS]');
                    return content;
                }
            }
            
            // Pattern 6: Look for style tags
            match = response.match(/<style[^>]*>([\s\S]*?)<\/style>/i);
            if (match) {
                console.log('Found CSS using pattern 6: <style> tags');
                return match[1].trim();
            }
            
            // Pattern 7: Generic code block after "CSS" keyword
            match = response.match(/\bCSS\b[\s\S]{0,50}```\s*\n?([\s\S]*?)```/i);
            if (match) {
                console.log('Found CSS using pattern 7: CSS keyword then code block');
                return match[1].trim();
            }
            
            // Pattern 8: Check if there's a code block that looks like CSS
            const allCodeBlocks = response.matchAll(/```(?:\w*\s*)?\n?([\s\S]*?)```/g);
            for (const block of allCodeBlocks) {
                const content = block[1].trim();
                // Check if it looks like CSS (common CSS patterns)
                if ((content.includes('{') && content.includes('}') && 
                     (content.includes('color:') || content.includes('background:') || 
                      content.includes('margin:') || content.includes('padding:') ||
                      content.includes('display:') || content.includes('position:') ||
                      content.includes('width:') || content.includes('height:') ||
                      content.match(/\.[a-zA-Z][\w-]*\s*{/) || // class selector
                      content.match(/#[a-zA-Z][\w-]*\s*{/) || // id selector
                      content.match(/^[a-zA-Z]+\s*{/m)))) { // element selector
                    
                    // Skip if it's clearly HTML
                    if (!content.includes('<') && !content.includes('>')) {
                        console.log('Found CSS using pattern 8: Code block with CSS-like content');
                        return content;
                    }
                }
            }
            
            // Pattern 9: Last resort - find anything between [CSS] and [HTML] or end
            const cssStart = response.search(/\[CSS\]/i);
            if (cssStart !== -1) {
                const htmlStart = response.search(/\[HTML\]/i);
                const jsStart = response.search(/\[(?:JS|JAVASCRIPT)\]/i);
                const explainStart = response.search(/\[EXPLANATION\]/i);
                
                let endIndex = response.length;
                if (htmlStart > cssStart) endIndex = Math.min(endIndex, htmlStart);
                if (jsStart > cssStart) endIndex = Math.min(endIndex, jsStart);
                if (explainStart > cssStart) endIndex = Math.min(endIndex, explainStart);
                
                const cssContent = response.substring(cssStart + 5, endIndex).trim();
                // Remove any remaining backticks
                const cleaned = cssContent.replace(/^```(?:css)?\s*|\s*```$/gi, '').trim();
                
                if (cleaned && (cleaned.includes('{') || cleaned.includes(':'))) {
                    console.log('Found CSS using pattern 9: Content between [CSS] and next section');
                    return cleaned;
                }
            }
            
            // Enhanced error logging for CSS extraction failure
            console.warn('%c⚠️ CSS Extraction Failed', 'color: orange; font-weight: bold');
            console.warn('Tried all 9 patterns but no CSS found in response');
            console.warn('Response snippet:', response.substring(0, 500) + '...');
            return null; // Return null to indicate no CSS was found (different from empty CSS)
        }
        
        function extractJS(response) {
            console.log('Attempting to extract JavaScript from response');
            
            // Pattern 1: Standard markdown code block with js/javascript language
            let match = response.match(/```(?:js|javascript)\s*\n([\s\S]*?)```/i);
            if (match) {
                console.log('Found JS using pattern 1: ```js/javascript');
                return match[1].trim();
            }
            
            // Pattern 2: Code block without newline
            match = response.match(/```(?:js|javascript)([\s\S]*?)```/i);
            if (match) {
                console.log('Found JS using pattern 2: ```js/javascript (no newline)');
                return match[1].trim();
            }
            
            // Pattern 3: [JS] or [JAVASCRIPT] section with any code block
            match = response.match(/\[(?:JS|JAVASCRIPT)\][\s\S]*?```(?:js|javascript)?\s*\n?([\s\S]*?)```/i);
            if (match) {
                console.log('Found JS using pattern 3: [JS/JAVASCRIPT] section');
                return match[1].trim();
            }
            
            // Pattern 4: Look for JS section header then next code block
            const jsMarkerIndex = response.search(/\[(?:JS|JAVASCRIPT)\]/i);
            if (jsMarkerIndex !== -1) {
                const afterMarker = response.substring(jsMarkerIndex);
                match = afterMarker.match(/```\s*\n?([\s\S]*?)```/);
                if (match) {
                    console.log('Found JS using pattern 4: [JS/JAVASCRIPT] then code block');
                    return match[1].trim();
                }
            }
            
            // Pattern 5: Plain JS section without code blocks
            match = response.match(/\[(?:JS|JAVASCRIPT)\]\s*\n([\s\S]*?)(?:\[|$)/i);
            if (match && match[1].trim()) {
                const content = match[1].trim();
                // Check if it looks like JavaScript
                if (content.includes('function') || content.includes('const') || 
                    content.includes('let') || content.includes('var') ||
                    content.includes('=>') || content.includes('document.')) {
                    console.log('Found JS using pattern 5: Plain JS after [JS/JAVASCRIPT]');
                    return content;
                }
            }
            
            // Pattern 6: Look for script tags
            match = response.match(/<script[^>]*>([\s\S]*?)<\/script>/i);
            if (match) {
                console.log('Found JS using pattern 6: <script> tags');
                return match[1].trim();
            }
            
            // Pattern 7: Generic code block after "JavaScript" keyword
            match = response.match(/\b(?:JavaScript|JS)\b[\s\S]{0,50}```\s*\n?([\s\S]*?)```/i);
            if (match) {
                console.log('Found JS using pattern 7: JavaScript/JS keyword then code block');
                return match[1].trim();
            }
            
            // Pattern 8: Check if there's a code block that looks like JavaScript
            const allCodeBlocks = response.matchAll(/```(?:\w*\s*)?\n?([\s\S]*?)```/g);
            for (const block of allCodeBlocks) {
                const content = block[1].trim();
                // Check if it looks like JavaScript (common JS patterns)
                if ((content.includes('function') || content.includes('const') || 
                     content.includes('let') || content.includes('var') ||
                     content.includes('=>') || content.includes('addEventListener') ||
                     content.includes('document.') || content.includes('window.') ||
                     content.includes('console.') || content.includes('return ') ||
                     content.match(/\bif\s*\(/) || content.match(/\bfor\s*\(/))) {
                    
                    // Skip if it's clearly HTML or CSS
                    if (!content.includes('<') && !content.includes('{') && !content.includes('color:')) {
                        console.log('Found JS using pattern 8: Code block with JS-like content');
                        return content;
                    }
                }
            }
            
            // Pattern 9: Last resort - find anything between [JS] and next section
            const jsStart = response.search(/\[(?:JS|JAVASCRIPT)\]/i);
            if (jsStart !== -1) {
                const htmlStart = response.search(/\[HTML\]/i);
                const cssStart = response.search(/\[CSS\]/i);
                const explainStart = response.search(/\[EXPLANATION\]/i);
                
                let endIndex = response.length;
                if (htmlStart > jsStart) endIndex = Math.min(endIndex, htmlStart);
                if (cssStart > jsStart) endIndex = Math.min(endIndex, cssStart);
                if (explainStart > jsStart) endIndex = Math.min(endIndex, explainStart);
                
                const jsContent = response.substring(jsStart + 4, endIndex).trim();
                // Remove any remaining backticks
                const cleaned = jsContent.replace(/^```(?:js|javascript)?\s*|\s*```$/gi, '').trim();
                
                if (cleaned && (cleaned.includes('function') || cleaned.includes('=') || cleaned.includes(';'))) {
                    console.log('Found JS using pattern 9: Content between [JS] and next section');
                    return cleaned;
                }
            }
            
            // Enhanced error logging for JS extraction failure
            console.warn('%c⚠️ JavaScript Extraction Failed', 'color: orange; font-weight: bold');
            console.warn('Tried all 9 patterns but no JavaScript found in response');
            console.warn('Response snippet:', response.substring(0, 500) + '...');
            return null; // Return null to indicate no JS was found
        }
        
        function parseAIResponse(response, previousHTML = '', previousCSS = '', previousJS = '') {
            console.log('Parsing AI Response:', response); // Debug log
            console.log('Current Mode:', currentMode); // Debug log
            console.log('Previous HTML length:', previousHTML.length);
            console.log('Previous CSS length:', previousCSS.length);
            console.log('Previous JS length:', previousJS.length);
            
            // Backup current CSS and JS before any changes
            if (currentCSS) {
                lastKnownGoodCSS = currentCSS;
                console.log('Backed up current CSS (length: ' + lastKnownGoodCSS.length + ')');
            }
            if (currentJS) {
                lastKnownGoodJS = currentJS;
                console.log('Backed up current JS (length: ' + lastKnownGoodJS.length + ')');
            }
            
            // Extract HTML with comprehensive fallback patterns
            let newHTML = extractHTML(response);
            
            if (newHTML !== null) {
                console.log('HTML extracted successfully:', newHTML.substring(0, 100) + '...');
            } else {
                console.log('No HTML found in response - preserving existing HTML');
            }
            
            // Extract CSS with comprehensive fallback patterns
            let newCSS = extractCSS(response);
            
            if (newCSS !== null) {
                console.log('CSS extracted successfully:', newCSS.substring(0, 100) + '...');
            } else {
                console.log('No CSS found in response - will preserve existing CSS');
            }
            
            // Extract JavaScript with comprehensive fallback patterns
            let newJS = extractJS(response);
            
            if (newJS !== null) {
                console.log('JavaScript extracted successfully:', newJS.substring(0, 100) + '...');
            } else {
                console.log('No JavaScript found in response - will preserve existing JS');
            }
            
            // Handle ADD mode - merge with existing content
            if (currentMode === 'add') {
                console.log('ADD mode: Merging content');
                
                // HTML handling for ADD mode
                if (newHTML !== null) {
                    currentHTML = previousHTML ? mergeHTML(previousHTML, newHTML) : newHTML;
                    console.log('Merged HTML result length:', currentHTML.length);
                } else {
                    // No new HTML provided, keep existing
                    currentHTML = previousHTML || '';
                    console.log('No HTML in response, keeping existing HTML');
                }
                
                // CSS handling for ADD mode
                if (newCSS !== null) {
                    currentCSS = previousCSS ? mergeCSS(previousCSS, newCSS) : newCSS;
                    console.log('Merged CSS result length:', currentCSS.length);
                } else {
                    // No new CSS provided, keep existing
                    currentCSS = previousCSS || '';
                    console.log('No CSS in response, keeping existing CSS');
                }
                
                // JavaScript handling for ADD mode
                if (newJS !== null) {
                    currentJS = previousJS ? mergeJS(previousJS, newJS) : newJS;
                    console.log('Merged JS result length:', currentJS.length);
                } else {
                    // No new JS provided, keep existing
                    currentJS = previousJS || '';
                    console.log('No JS in response, keeping existing JS');
                }
            } else {
                // EDIT mode - only replace what was provided
                console.log('EDIT mode: Selective replacement');
                
                // HTML handling for EDIT mode
                if (newHTML !== null) {
                    currentHTML = newHTML;
                    console.log('Replaced HTML with new content');
                } else {
                    // No HTML provided, keep existing
                    currentHTML = previousHTML || '';
                    console.log('No HTML in response, keeping existing HTML');
                }
                
                // CSS handling for EDIT mode - CRITICAL FIX
                if (newCSS !== null) {
                    currentCSS = newCSS;
                    console.log('Replaced CSS with new content');
                } else {
                    // No CSS provided, keep existing CSS - THIS IS THE KEY FIX
                    currentCSS = previousCSS || lastKnownGoodCSS || '';
                    console.log('No CSS in response, preserving existing CSS (length: ' + currentCSS.length + ')');
                }
                
                // JavaScript handling for EDIT mode
                if (newJS !== null) {
                    currentJS = newJS;
                    console.log('Replaced JS with new content');
                } else {
                    // No JS provided, keep existing JS
                    currentJS = previousJS || lastKnownGoodJS || '';
                    console.log('No JS in response, preserving existing JS (length: ' + currentJS.length + ')');
                }
            }
            
            // Update editors
            document.getElementById('htmlEditor').value = currentHTML;
            document.getElementById('cssEditor').value = currentCSS;
            document.getElementById('jsEditor').value = currentJS;
            
            // Clear selection effects after processing
            clearSelectionEffects();
            
            // Update preview and generate JSON
            updatePreview();
            generateOxygenJSON();
            
            // Check if auto-generate images is enabled
            const autoGenCheckbox = document.getElementById('autoGenerateImages');
            if (autoGenCheckbox && autoGenCheckbox.checked) {
                // Wait a moment for preview to render, then auto-generate images
                setTimeout(() => {
                    autoGeneratePlaceholderImages(true); // Pass true to skip confirmation
                }, 1000);
            }
        }
        
        function mergeHTML(existingHTML, newHTML) {
            console.log('mergeHTML called');
            console.log('Existing HTML:', existingHTML);
            console.log('New HTML:', newHTML);
            
            // If no new HTML, return existing
            if (!newHTML || newHTML.trim() === '') {
                console.log('No new HTML to merge');
                return existingHTML;
            }
            
            // If no existing HTML, return new
            if (!existingHTML || existingHTML.trim() === '') {
                console.log('No existing HTML, using new HTML');
                return newHTML;
            }
            
            // In ADD mode, AI should now return ONLY new content, so always append
            // No need to check if existing content is included
            // Try to insert before closing body tag if present
            if (existingHTML.includes('</body>')) {
                console.log('Inserting before </body>');
                return existingHTML.replace('</body>', '\n' + newHTML + '\n</body>');
            } else if (existingHTML.includes('</div>')) {
                // Find the last closing div
                const lastDivIndex = existingHTML.lastIndexOf('</div>');
                console.log('Inserting before last </div>');
                return existingHTML.slice(0, lastDivIndex) + '\n' + newHTML + '\n' + existingHTML.slice(lastDivIndex);
            } else {
                // Otherwise just append
                console.log('Appending to end');
                return existingHTML + '\n' + newHTML;
            }
        }
        
        function mergeCSS(existingCSS, newCSS) {
            console.log('mergeCSS called');
            console.log('Existing CSS length:', existingCSS ? existingCSS.length : 0);
            console.log('New CSS length:', newCSS ? newCSS.length : 0);
            
            // If no new CSS, return existing
            if (!newCSS || newCSS.trim() === '') {
                console.log('No new CSS to merge');
                return existingCSS || '';
            }
            
            // If no existing CSS, return new
            if (!existingCSS || existingCSS.trim() === '') {
                console.log('No existing CSS, using new CSS');
                return newCSS;
            }
            
            // In ADD mode, AI should now return ONLY new styles, so always append
            // Simple append without complex checks
            console.log('Appending new CSS to existing');
            return existingCSS + '\n\n/* New styles */\n' + newCSS;
        }
        
        // Helper function to calculate string overlap
        function calculateOverlap(str1, str2) {
            if (!str1 || !str2) return 0;
            const shorter = str1.length < str2.length ? str1 : str2;
            const longer = str1.length >= str2.length ? str1 : str2;
            
            let matchCount = 0;
            const chunkSize = 20; // Check chunks of 20 characters
            for (let i = 0; i < shorter.length - chunkSize; i += chunkSize) {
                const chunk = shorter.substring(i, i + chunkSize);
                if (longer.includes(chunk)) {
                    matchCount++;
                }
            }
            
            const totalChunks = Math.floor(shorter.length / chunkSize);
            return totalChunks > 0 ? matchCount / totalChunks : 0;
        }
        
        // Helper function to extract CSS selectors
        function extractSelectors(css) {
            if (!css) return [];
            const selectorRegex = /([.#]?[a-zA-Z0-9_-]+(?:\s*[>+~]\s*)?)+(?:\s*,\s*[.#]?[a-zA-Z0-9_-]+)*\s*{/g;
            const matches = css.match(selectorRegex) || [];
            return matches.map(m => m.replace('{', '').trim());
        }
        
        function mergeJS(existingJS, newJS) {
            console.log('mergeJS called');
            console.log('Existing JS length:', existingJS ? existingJS.length : 0);
            console.log('New JS length:', newJS ? newJS.length : 0);
            
            // If no new JS, return existing
            if (!newJS || newJS.trim() === '') {
                console.log('No new JS to merge');
                return existingJS || '';
            }
            
            // If no existing JS, return new
            if (!existingJS || existingJS.trim() === '') {
                console.log('No existing JS, using new JS');
                return newJS;
            }
            
            // Check if AI returned complete JS (includes existing)
            if (newJS.includes(existingJS.trim())) {
                console.log('AI included existing JS, using complete version');
                return newJS;
            }
            
            // Append new JS with a separator comment
            console.log('Appending new JS to existing');
            return existingJS + '\n\n// Added JavaScript\n' + newJS;
        }

        function updatePreview() {
            const preview = document.getElementById('previewFrame');
            const doc = preview.contentDocument || preview.contentWindow.document;
            
            const fullHTML = `
                <!DOCTYPE html>
                <html>
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <style>
                        * { margin: 0; padding: 0; box-sizing: border-box; }
                        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
                        ${currentCSS}
                    </style>
                </head>
                <body>
                    ${currentHTML}
                </body>
                </html>
            `;
            
            doc.open();
            doc.write(fullHTML);
            doc.close();
            
            // Add JavaScript after the document is written to avoid escaping issues
            if (currentJS && currentJS.trim()) {
                const script = doc.createElement('script');
                script.textContent = currentJS;
                doc.body.appendChild(script);
            }
            
            // Add right-click context menu to preview elements
            setupContextMenu(doc);
        }
        
        function setupContextMenu(doc) {
            // Remove any existing listeners
            doc.removeEventListener('contextmenu', handleContextMenu);
            doc.removeEventListener('click', hideContextMenu);
            doc.removeEventListener('mouseover', handleElementHoverEdit);
            doc.removeEventListener('mouseout', handleElementHoverOutEdit);
            
            // Only add listeners if edit mode is active
            if (isEditMode) {
                doc.addEventListener('contextmenu', handleContextMenu);
                doc.addEventListener('click', hideContextMenu);
                doc.addEventListener('mouseover', handleElementHoverEdit);
                doc.addEventListener('mouseout', handleElementHoverOutEdit);
            }
        }
        
        function toggleEditMode() {
            isEditMode = !isEditMode;
            const editBtn = document.getElementById('manualEditModeBtn');
            const previewFrame = document.getElementById('previewFrame');
            const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
            
            if (isEditMode) {
                // Enable edit mode
                editBtn.classList.add('active');
                editBtn.style.background = 'linear-gradient(135deg, #667eea, #764ba2)';
                editBtn.style.color = 'white';
                editBtn.textContent = '🚫 Exit Manual Edit';
                
                // Add edit mode indicator to preview
                const indicator = iframeDoc.createElement('div');
                indicator.id = 'editModeIndicator';
                indicator.innerHTML = '✏️ MANUAL EDIT MODE ACTIVE';
                indicator.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    background: linear-gradient(135deg, #667eea, #764ba2);
                    color: white;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-size: 12px;
                    font-weight: bold;
                    z-index: 10000;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                `;
                iframeDoc.body.appendChild(indicator);
                
                // Add edit mode styles
                const style = iframeDoc.createElement('style');
                style.id = 'editModeStyles';
                style.textContent = `
                    .edit-hover {
                        outline: 2px dashed #667eea !important;
                        outline-offset: 2px;
                        cursor: pointer !important;
                        position: relative !important;
                    }
                    
                    .edit-hover::before {
                        content: attr(data-element-type);
                        position: absolute;
                        top: -25px;
                        left: 0;
                        background: #667eea;
                        color: white;
                        padding: 2px 8px;
                        border-radius: 6px; background: white;
                        font-size: 11px;
                        font-weight: bold;
                        z-index: 10001;
                        white-space: nowrap;
                    }
                    
                    .element-highlight {
                        outline: 3px solid #764ba2 !important;
                        outline-offset: 2px;
                    }
                `;
                iframeDoc.head.appendChild(style);
                
                showMessage('assistant', '✏️ Manual Edit Mode activated! Hover over elements to see what you can edit, then right-click to edit.');
            } else {
                // Disable edit mode
                editBtn.classList.remove('active');
                editBtn.style.background = '';
                editBtn.style.color = '';
                editBtn.textContent = '✏️ Manual Edit Mode';
                
                // Remove edit mode indicator
                const indicator = iframeDoc.getElementById('editModeIndicator');
                if (indicator) indicator.remove();
                
                // Remove edit mode styles
                const style = iframeDoc.getElementById('editModeStyles');
                if (style) style.remove();
                
                // Remove any hover effects
                iframeDoc.querySelectorAll('.edit-hover').forEach(el => {
                    el.classList.remove('edit-hover');
                    el.removeAttribute('data-element-type');
                });
                
                // Remove any highlights
                iframeDoc.querySelectorAll('.element-highlight').forEach(el => {
                    el.classList.remove('element-highlight');
                });
                
                hideContextMenu();
                showMessage('assistant', '✏️ Manual Edit Mode deactivated.');
            }
            
            // Re-setup context menu with new mode
            setupContextMenu(iframeDoc);
        }
        
        function handleElementHoverEdit(e) {
            if (!isEditMode) return;
            
            // Stop propagation to prevent parent elements from also getting highlighted
            e.stopPropagation();
            
            const target = e.target;
            if (!target || target.tagName === 'BODY' || target.tagName === 'HTML' || target.id === 'editModeIndicator') {
                return;
            }
            
            // Get the iframe document
            const iframeDoc = target.ownerDocument || document.getElementById('previewFrame').contentDocument;
            
            // Remove all existing hover effects first (except from the context menu target)
            iframeDoc.querySelectorAll('.edit-hover').forEach(el => {
                if (el !== target && el !== contextMenuTarget) {
                    el.classList.remove('edit-hover');
                    el.removeAttribute('data-element-type');
                }
            });
            
            // Check if element is too large (likely a container spanning the whole page)
            const rect = target.getBoundingClientRect();
            const viewportHeight = iframeDoc.defaultView.innerHeight;
            const viewportWidth = iframeDoc.defaultView.innerWidth;
            
            // Skip if element covers more than 80% of viewport (likely a main container)
            if (rect.width > viewportWidth * 0.8 && rect.height > viewportHeight * 0.8) {
                return;
            }
            
            // Add hover effect only to current target
            target.classList.add('edit-hover');
            
            // Add element type label
            const tagName = target.tagName.toLowerCase();
            let elementType = tagName;
            
            // Provide more descriptive names for common elements
            switch(tagName) {
                case 'h1':
                case 'h2':
                case 'h3':
                case 'h4':
                case 'h5':
                case 'h6':
                    elementType = 'Heading';
                    break;
                case 'p':
                    elementType = 'Paragraph';
                    break;
                case 'div':
                    elementType = 'Container';
                    break;
                case 'section':
                    elementType = 'Section';
                    break;
                case 'img':
                    elementType = 'Image';
                    break;
                case 'a':
                    elementType = 'Link';
                    break;
                case 'button':
                    elementType = 'Button';
                    break;
                case 'ul':
                case 'ol':
                    elementType = 'List';
                    break;
                case 'li':
                    elementType = 'List Item';
                    break;
                case 'span':
                    elementType = 'Text';
                    break;
                case 'input':
                    elementType = 'Input Field';
                    break;
                case 'form':
                    elementType = 'Form';
                    break;
            }
            
            target.setAttribute('data-element-type', elementType);
        }
        
        function handleElementHoverOutEdit(e) {
            if (!isEditMode) return;
            
            const target = e.target;
            const relatedTarget = e.relatedTarget;
            
            if (!target) return;
            
            // Don't remove hover if moving to a child element
            if (relatedTarget && target.contains(relatedTarget)) {
                return;
            }
            
            // Remove hover effect unless it's the context menu target
            if (target !== contextMenuTarget) {
                target.classList.remove('edit-hover');
                target.removeAttribute('data-element-type');
            }
            
            // Clean up any orphaned hover effects (safety measure)
            const iframeDoc = target.ownerDocument || document.getElementById('previewFrame').contentDocument;
            if (iframeDoc) {
                // Count hover elements
                const hoverElements = iframeDoc.querySelectorAll('.edit-hover');
                // If there are multiple hover elements and none are being hovered, clean them all
                if (hoverElements.length > 1) {
                    hoverElements.forEach(el => {
                        if (el !== contextMenuTarget && el !== relatedTarget) {
                            el.classList.remove('edit-hover');
                            el.removeAttribute('data-element-type');
                        }
                    });
                }
            }
        }
        
        function handleContextMenu(e) {
            // Only handle in edit mode
            if (!isEditMode) return;
            
            e.preventDefault();
            
            const target = e.target;
            if (!target || target.tagName === 'BODY' || target.tagName === 'HTML' || target.id === 'editModeIndicator') {
                return;
            }
            
            contextMenuTarget = target;
            
            // Set selectedElement for context menu selection
            const tagName = target.tagName.toLowerCase();
            const classes = target.className ? `.${target.className.split(' ').filter(c => c !== 'element-selected' && c !== 'element-highlight').join('.')}` : '';
            const id = target.id ? `#${target.id}` : '';
            
            selectedElement = {
                element: target,
                tag: tagName,
                selector: tagName + id + classes,
                html: target.outerHTML,
                text: target.textContent.substring(0, 50)
            };
            
            // Update the element display
            setMode('edit'); // Switch to edit mode
            updateSelectedElementDisplay();
            
            // Highlight the element
            const iframeDoc = document.getElementById('previewFrame').contentDocument;
            iframeDoc.querySelectorAll('.element-highlight').forEach(el => {
                el.classList.remove('element-highlight');
            });
            target.classList.add('element-highlight');
            
            // Show/hide link option based on element type
            const linkOption = document.getElementById('editLinkOption');
            linkOption.style.display = target.tagName === 'A' ? 'block' : 'none';
            
            // Position and show context menu
            const menu = document.getElementById('contextMenu');
            const iframe = document.getElementById('previewFrame');
            const rect = iframe.getBoundingClientRect();
            
            menu.style.left = (rect.left + e.clientX) + 'px';
            menu.style.top = (rect.top + e.clientY) + 'px';
            menu.style.display = 'block';
        }
        
        function hideContextMenu() {
            document.getElementById('contextMenu').style.display = 'none';
            
            // Remove highlight and hover effects
            const iframeDoc = document.getElementById('previewFrame').contentDocument;
            if (iframeDoc) {
                // Remove element highlight
                iframeDoc.querySelectorAll('.element-highlight').forEach(el => {
                    el.classList.remove('element-highlight');
                });
                
                // Remove hover effect from the context menu target
                if (contextMenuTarget) {
                    contextMenuTarget.classList.remove('edit-hover');
                    contextMenuTarget.removeAttribute('data-element-type');
                }
                
                // Remove any other lingering hover effects
                iframeDoc.querySelectorAll('.edit-hover').forEach(el => {
                    el.classList.remove('edit-hover');
                    el.removeAttribute('data-element-type');
                });
            }
            
            // Clear the context menu target
            contextMenuTarget = null;
        }
        
        function editElementText() {
            hideContextMenu();
            if (!contextMenuTarget) return;
            
            document.getElementById('editorTitle').textContent = 'Edit Text Content';
            document.getElementById('editorContent').innerHTML = `
                <div class="property-group">
                    <label class="property-label">Text Content:</label>
                    <textarea class="property-input" id="textContent" rows="4">${contextMenuTarget.textContent}</textarea>
                </div>
            `;
            document.getElementById('propertyEditor').style.display = 'block';
        }
        
        function editElementStyles() {
            hideContextMenu();
            if (!contextMenuTarget) return;
            
            const computedStyles = window.getComputedStyle(contextMenuTarget);
            
            document.getElementById('editorTitle').textContent = 'Edit Styles';
            document.getElementById('editorContent').innerHTML = `
                <div class="property-group">
                    <label class="property-label">Color:</label>
                    <input type="color" class="property-input" id="styleColor" value="${rgbToHex(computedStyles.color)}" style="height: 40px;">
                </div>
                <div class="property-group">
                    <label class="property-label">Background Color:</label>
                    <input type="color" class="property-input" id="styleBgColor" value="${rgbToHex(computedStyles.backgroundColor)}" style="height: 40px;">
                </div>
                <div class="property-group">
                    <label class="property-label">Font Size:</label>
                    <input type="text" class="property-input" id="styleFontSize" value="${computedStyles.fontSize}" placeholder="e.g., 16px, 1.2em">
                </div>
                <div class="property-group">
                    <label class="property-label">Font Weight:</label>
                    <select class="property-input" id="styleFontWeight">
                        <option value="normal">Normal</option>
                        <option value="bold">Bold</option>
                        <option value="lighter">Lighter</option>
                        <option value="100">100</option>
                        <option value="200">200</option>
                        <option value="300">300</option>
                        <option value="400">400</option>
                        <option value="500">500</option>
                        <option value="600">600</option>
                        <option value="700">700</option>
                        <option value="800">800</option>
                        <option value="900">900</option>
                    </select>
                </div>
            `;
            document.getElementById('propertyEditor').style.display = 'block';
        }
        
        function editElementPadding() {
            hideContextMenu();
            if (!contextMenuTarget) return;
            
            const computedStyles = window.getComputedStyle(contextMenuTarget);
            
            document.getElementById('editorTitle').textContent = 'Edit Padding & Margin';
            document.getElementById('editorContent').innerHTML = `
                <div class="property-group">
                    <label class="property-label">Padding (Top Right Bottom Left):</label>
                    <input type="text" class="property-input" id="stylePadding" value="${computedStyles.padding}" placeholder="e.g., 10px or 10px 20px">
                </div>
                <div class="property-group">
                    <label class="property-label">Margin (Top Right Bottom Left):</label>
                    <input type="text" class="property-input" id="styleMargin" value="${computedStyles.margin}" placeholder="e.g., 10px or 10px 20px">
                </div>
                <div class="property-group">
                    <label class="property-label">Border Radius:</label>
                    <input type="text" class="property-input" id="styleBorderRadius" value="${computedStyles.borderRadius}" placeholder="e.g., 8px or 50%">
                </div>
            `;
            document.getElementById('propertyEditor').style.display = 'block';
        }
        
        function editElementLink() {
            hideContextMenu();
            if (!contextMenuTarget || contextMenuTarget.tagName !== 'A') return;
            
            document.getElementById('editorTitle').textContent = 'Edit Link';
            document.getElementById('editorContent').innerHTML = `
                <div class="property-group">
                    <label class="property-label">URL:</label>
                    <input type="url" class="property-input" id="linkHref" value="${contextMenuTarget.href}" placeholder="https://example.com">
                </div>
                <div class="property-group">
                    <label class="property-label">Target:</label>
                    <select class="property-input" id="linkTarget">
                        <option value="_self" ${contextMenuTarget.target === '_self' ? 'selected' : ''}>Same Window</option>
                        <option value="_blank" ${contextMenuTarget.target === '_blank' ? 'selected' : ''}>New Window</option>
                    </select>
                </div>
            `;
            document.getElementById('propertyEditor').style.display = 'block';
        }
        
        function editElementBackground() {
            hideContextMenu();
            if (!contextMenuTarget) return;
            
            const computedStyles = window.getComputedStyle(contextMenuTarget);
            
            document.getElementById('editorTitle').textContent = 'Edit Background';
            document.getElementById('editorContent').innerHTML = `
                <div class="property-group">
                    <label class="property-label">Background Color:</label>
                    <input type="color" class="property-input" id="bgColor" value="${rgbToHex(computedStyles.backgroundColor)}" style="height: 40px;">
                </div>
                <div class="property-group">
                    <label class="property-label">Background Image URL:</label>
                    <input type="text" class="property-input" id="bgImage" placeholder="https://example.com/image.jpg">
                </div>
                <div class="property-group">
                    <label class="property-label">Background Size:</label>
                    <select class="property-input" id="bgSize">
                        <option value="auto">Auto</option>
                        <option value="cover">Cover</option>
                        <option value="contain">Contain</option>
                        <option value="100% 100%">Stretch</option>
                    </select>
                </div>
            `;
            document.getElementById('propertyEditor').style.display = 'block';
        }
        
        function duplicateElement() {
            hideContextMenu();
            if (!contextMenuTarget) return;
            
            const clone = contextMenuTarget.cloneNode(true);
            contextMenuTarget.parentNode.insertBefore(clone, contextMenuTarget.nextSibling);
            
            // Update the HTML editor
            updateHTMLFromPreview();
            showMessage('assistant', '📋 Element duplicated successfully!');
        }
        
        function deleteElement() {
            hideContextMenu();
            if (!contextMenuTarget) return;
            
            if (confirm('Are you sure you want to delete this element?')) {
                contextMenuTarget.remove();
                updateHTMLFromPreview();
                showMessage('assistant', '🗑️ Element deleted successfully!');
            }
        }
        
        function applyPropertyEdit() {
            if (!contextMenuTarget) return;
            
            const editorContent = document.getElementById('editorContent');
            const title = document.getElementById('editorTitle').textContent;
            
            if (title.includes('Text')) {
                contextMenuTarget.textContent = document.getElementById('textContent').value;
            } else if (title.includes('Styles')) {
                contextMenuTarget.style.color = document.getElementById('styleColor').value;
                contextMenuTarget.style.backgroundColor = document.getElementById('styleBgColor').value;
                contextMenuTarget.style.fontSize = document.getElementById('styleFontSize').value;
                contextMenuTarget.style.fontWeight = document.getElementById('styleFontWeight').value;
            } else if (title.includes('Padding')) {
                contextMenuTarget.style.padding = document.getElementById('stylePadding').value;
                contextMenuTarget.style.margin = document.getElementById('styleMargin').value;
                contextMenuTarget.style.borderRadius = document.getElementById('styleBorderRadius').value;
            } else if (title.includes('Link')) {
                contextMenuTarget.href = document.getElementById('linkHref').value;
                contextMenuTarget.target = document.getElementById('linkTarget').value;
            } else if (title.includes('Background')) {
                contextMenuTarget.style.backgroundColor = document.getElementById('bgColor').value;
                const bgImage = document.getElementById('bgImage').value;
                if (bgImage) {
                    contextMenuTarget.style.backgroundImage = `url(${bgImage})`;
                }
                contextMenuTarget.style.backgroundSize = document.getElementById('bgSize').value;
            }
            
            // Update the HTML editor
            updateHTMLFromPreview();
            
            // Close the editor
            cancelPropertyEdit();
            
            showMessage('assistant', '✅ Element updated successfully!');
        }
        
        function cancelPropertyEdit() {
            document.getElementById('propertyEditor').style.display = 'none';
            
            // Remove any hover effects when canceling property edit
            const iframeDoc = document.getElementById('previewFrame').contentDocument;
            if (iframeDoc && contextMenuTarget) {
                contextMenuTarget.classList.remove('edit-hover');
                contextMenuTarget.removeAttribute('data-element-type');
            }
            
            contextMenuTarget = null;
        }
        
        function updateHTMLFromPreview() {
            const iframeDoc = document.getElementById('previewFrame').contentDocument;
            const bodyHTML = iframeDoc.body.innerHTML;
            
            // Remove any highlight classes before saving
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = bodyHTML;
            tempDiv.querySelectorAll('.element-highlight').forEach(el => {
                el.classList.remove('element-highlight');
            });
            
            currentHTML = tempDiv.innerHTML;
            document.getElementById('htmlEditor').value = currentHTML;
            generateOxygenJSON();
            saveCurrentConversation();
        }
        
        function rgbToHex(rgb) {
            if (!rgb || rgb === 'rgba(0, 0, 0, 0)' || rgb === 'transparent') {
                return '#ffffff';
            }
            
            const result = rgb.match(/\d+/g);
            if (!result) return '#000000';
            
            const r = parseInt(result[0]);
            const g = parseInt(result[1]);
            const b = parseInt(result[2]);
            
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function generateOxygenJSON() {
            // Create Oxygen JSON structure with code block
            currentJSON = {
                "id": 0,
                "name": "root",
                "children": [{
                    "id": 1,
                    "name": "ct_code_block",
                    "options": {
                        "ct_id": 1,
                        "ct_parent": 0,
                        "selector": `code_block-1-${postId}`,
                        "original": {
                            "code-php": currentHTML,
                            "code-css": currentCSS,
                            "code-js": currentJS || ""
                        }
                    }
                }]
            };
            
            document.getElementById('jsonOutput').textContent = JSON.stringify(currentJSON, null, 2);
        }

        let currentDevice = 'desktop';
        let isFullscreen = false;
        let isChatVisible = false;
        
        function toggleFullscreenChat() {
            const floatingWrapper = document.getElementById('floatingChatWrapper');
            if (!floatingWrapper) {
                console.log('No floating wrapper found');
                return;
            }
            
            isChatVisible = !isChatVisible;
            floatingWrapper.style.display = isChatVisible ? 'block' : 'none';
            
            // Update toggle button icon opacity
            const toggleBtn = document.getElementById('chatToggleBtn');
            if (toggleBtn) {
                toggleBtn.style.opacity = isChatVisible ? '1' : '0.7';
            }
        }
        
        function toggleFullscreen() {
            const previewFrame = document.getElementById('previewFrame');
            const mainContainer = document.querySelector('.main-container');
            const header = document.querySelector('.header');
            
            if (!isFullscreen) {
                // Enter fullscreen mode
                isFullscreen = true;
                isChatVisible = false; // Start with chat hidden
                
                // Create fullscreen container
                const fullscreenContainer = document.createElement('div');
                fullscreenContainer.id = 'fullscreenContainer';
                fullscreenContainer.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: white;
                    z-index: 99999;
                    display: flex;
                    flex-direction: column;
                `;
                
                // Create exit button bar
                const exitBar = document.createElement('div');
                exitBar.style.cssText = `
                    background: linear-gradient(135deg, #667eea, #764ba2);
                    padding: 10px 20px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                `;
                
                // Add title and buttons
                exitBar.innerHTML = `
                    <div style="color: white; font-weight: bold; font-size: 14px;">
                        🖥️ Fullscreen Preview Mode
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button id="chatToggleBtn" onclick="toggleFullscreenChat()" style="
                            background: rgba(255, 255, 255, 0.2);
                            color: white;
                            border: none;
                            padding: 8px 16px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 16px;
                            transition: all 0.3s ease;
                            opacity: 0.7;
                        " onmouseover="this.style.background='rgba(255,255,255,0.3)'" 
                           onmouseout="this.style.background='rgba(255,255,255,0.2)'"
                           title="Toggle Chat">
                            💬
                        </button>
                        <button onclick="toggleFullscreen()" style="
                            background: white;
                            color: #667eea;
                            border: none;
                            padding: 8px 16px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-weight: bold;
                            font-size: 14px;
                            display: flex;
                            align-items: center;
                            gap: 8px;
                            transition: all 0.3s;
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3" />
                            </svg>
                            Exit Fullscreen
                        </button>
                    </div>
                `;
                
                // Create iframe container
                const iframeContainer = document.createElement('div');
                iframeContainer.style.cssText = `
                    flex: 1;
                    position: relative;
                    overflow: hidden;
                `;
                
                // Clone the preview frame
                const fullscreenFrame = document.createElement('iframe');
                fullscreenFrame.id = 'fullscreenFrame';
                fullscreenFrame.style.cssText = `
                    width: 100%;
                    height: 100%;
                    border: none;
                    background: white;
                `;
                
                // Assemble fullscreen view first (iframe needs to be in DOM to access contentDocument)
                iframeContainer.appendChild(fullscreenFrame);
                fullscreenContainer.appendChild(exitBar);
                fullscreenContainer.appendChild(iframeContainer);
                
                // Attach the existing chat window to fullscreen mode BEFORE appending to body
                attachChatToFullscreen(fullscreenContainer);
                
                document.body.appendChild(fullscreenContainer);
                
                // Now copy content to fullscreen frame after it's in the DOM
                setTimeout(() => {
                    const originalDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
                    const fullDoc = fullscreenFrame.contentDocument || fullscreenFrame.contentWindow.document;
                    
                    if (fullDoc && originalDoc) {
                        fullDoc.open();
                        fullDoc.write(originalDoc.documentElement.outerHTML);
                        fullDoc.close();
                    }
                }, 100);
                
                // Hide main UI
                mainContainer.style.display = 'none';
                header.style.display = 'none';
                
                // Add escape key listener
                document.addEventListener('keydown', handleFullscreenEscape);
                
                // Update button icon
                const fullscreenBtn = document.getElementById('fullscreenBtn');
                fullscreenBtn.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3" />
                    </svg>
                `;
                
            } else {
                // Exit fullscreen mode
                exitFullscreen();
            }
        }
        
        function exitFullscreen() {
            isFullscreen = false;
            isChatVisible = false;
            
            // Restore chat to original position BEFORE removing fullscreen container
            restoreChatToOriginal();
            
            // Remove fullscreen container
            const fullscreenContainer = document.getElementById('fullscreenContainer');
            if (fullscreenContainer) {
                fullscreenContainer.remove();
            }
            
            // Show main UI
            const mainContainer = document.querySelector('.main-container');
            const header = document.querySelector('.header');
            mainContainer.style.display = '';
            header.style.display = '';
            
            // Remove escape key listener
            document.removeEventListener('keydown', handleFullscreenEscape);
            
            // Update button icon back to expand
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            fullscreenBtn.innerHTML = `
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" />
                </svg>
            `;
        }
        
        function handleFullscreenEscape(e) {
            if (e.key === 'Escape' && isFullscreen) {
                exitFullscreen();
            }
        }
        
        function setDevice(device) {
            currentDevice = device;
            
            // Update toggle buttons
            document.querySelectorAll('.device-toggle').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.closest('.device-toggle').classList.add('active');
            
            // Update iframe class
            const iframe = document.getElementById('previewFrame');
            iframe.className = 'preview-frame ' + device;
            
            // Add device frame styling for mobile/tablet
            const previewContent = iframe.parentElement;
            if (device === 'mobile' || device === 'tablet') {
                previewContent.style.background = '#e0e0e0';
                iframe.style.boxShadow = '0 10px 50px rgba(0,0,0,0.2)';
            } else {
                previewContent.style.background = '#f5f5f5';
                iframe.style.boxShadow = 'none';
            }
        }
        
        function switchTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.preview-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            
            // Hide all content
            document.getElementById('previewFrame').style.display = 'none';
            document.getElementById('htmlEditor').style.display = 'none';
            document.getElementById('cssEditor').style.display = 'none';
            document.getElementById('jsEditor').style.display = 'none';
            document.getElementById('jsonOutput').style.display = 'none';
            
            // Show selected content
            switch(tab) {
                case 'preview':
                    document.getElementById('previewFrame').style.display = 'block';
                    break;
                case 'html':
                    document.getElementById('htmlEditor').style.display = 'block';
                    break;
                case 'css':
                    document.getElementById('cssEditor').style.display = 'block';
                    break;
                case 'js':
                    document.getElementById('jsEditor').style.display = 'block';
                    break;
                case 'json':
                    document.getElementById('jsonOutput').style.display = 'block';
                    break;
            }
        }

        function refreshPreview() {
            currentHTML = document.getElementById('htmlEditor').value;
            currentCSS = document.getElementById('cssEditor').value;
            currentJS = document.getElementById('jsEditor').value;
            updatePreview();
            generateOxygenJSON();
        }

        function clearAll() {
            if (confirm('Clear chat conversation history? (Your code will be preserved)')) {
                // Only clear conversation history and chat display
                conversationHistory = [];
                localStorage.removeItem('vibe_coder_conversations');
                localStorage.removeItem('vibe_coder_current_conversation');
                
                // Reset chat display with suggestions
                const isCollapsed = localStorage.getItem('vibe_suggestions_collapsed') === 'true';
                document.getElementById('chatMessages').innerHTML = `
                    <div class="prompt-suggestions ${isCollapsed ? 'collapsed' : ''}" id="promptSuggestions">
                        <div class="suggestions-header">
                            <span class="suggestions-label">💡 Quick starts</span>
                            <button class="suggestions-toggle" onclick="toggleSuggestions()" title="Toggle suggestions">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="6 9 12 15 18 9"></polyline>
                                </svg>
                            </button>
                        </div>
                        <div class="suggestions-grid" id="suggestionsGrid">
                            <span class="suggestion-chip" onclick="useSuggestion(this)" title="Start with a complete page structure">🏗️ Build landing page with sections</span>
                            <span class="suggestion-chip" onclick="useSuggestion(this)" title="Upload a screenshot to recreate">📸 Recreate from my screenshot</span>
                            <span class="suggestion-chip" onclick="useSuggestion(this)" title="Fix issues in existing code">🔧 Debug and improve my code</span>
                            <span class="suggestion-chip" onclick="useSuggestion(this)" title="Add new functionality">✨ Add dark mode to my site</span>
                            <span class="suggestion-chip" onclick="useSuggestion(this)" title="Make responsive for all devices">📱 Make my design mobile-friendly</span>
                            <span class="suggestion-chip" onclick="useSuggestion(this)" title="Add smooth animations">🎨 Add animations and effects</span>
                            <span class="suggestion-chip" onclick="useSuggestion(this)" title="Convert to Oxygen format">🔄 Convert HTML to Oxygen</span>
                            <span class="suggestion-chip" onclick="useSuggestion(this)" title="Improve performance">⚡ Optimize for speed and SEO</span>
                        </div>
                    </div>
                `;
                
                // Show success message
                showMessage('assistant', '✅ Chat history cleared. Your code has been preserved.');
                
                // Note: We keep currentHTML and currentCSS intact
                // The preview and code editors maintain their content
            }
        }

        function exportToOxygen() {
            const jsonText = JSON.stringify(currentJSON, null, 2);
            navigator.clipboard.writeText(jsonText).then(() => {
                alert('Oxygen JSON copied to clipboard! You can now paste it into Oxygen Builder.');
            }).catch(() => {
                alert('Failed to copy to clipboard. Please copy manually from the JSON tab.');
            });
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        function toggleSuggestions() {
            const container = document.getElementById('promptSuggestions');
            const grid = document.getElementById('suggestionsGrid');
            const toggleBtn = container.querySelector('.suggestions-toggle svg');
            
            if (container) {
                container.classList.toggle('collapsed');
                const isCollapsed = container.classList.contains('collapsed');
                
                // Update icon rotation
                if (toggleBtn) {
                    toggleBtn.style.transform = isCollapsed ? 'rotate(-90deg)' : 'rotate(0deg)';
                }
                
                // Save state to localStorage
                localStorage.setItem('vibe_suggestions_collapsed', isCollapsed);
            }
        }

        function useSuggestion(chip) {
            document.getElementById('userInput').value = chip.textContent;
            document.getElementById('userInput').focus();
        }
        
        function setMode(mode) {
            currentMode = mode;
            document.getElementById('addModeBtn').classList.toggle('active', mode === 'add');
            document.getElementById('editModeBtn').classList.toggle('active', mode === 'edit');
            document.getElementById('referenceModeBtn').classList.toggle('active', mode === 'reference');
            document.getElementById('planModeBtn').classList.toggle('active', mode === 'plan');
            
            // Update floating chat mode buttons if they exist
            const floatingChat = document.getElementById('floatingChat');
            if (floatingChat) {
                const modeButtons = floatingChat.querySelectorAll('.mode-button');
                modeButtons.forEach(btn => {
                    const btnMode = btn.textContent.includes('Add') ? 'add' : 
                                  btn.textContent.includes('Edit') ? 'edit' : 
                                  btn.textContent.includes('Reference') ? 'reference' : '';
                    if (btnMode) {
                        const isActive = btnMode === mode;
                        btn.style.background = isActive ? 'linear-gradient(135deg, #667eea, #764ba2)' : '#f0f0f0';
                        btn.style.color = isActive ? 'white' : '#333';
                    }
                });
            }
            
            // Show/hide UI elements based on mode
            // Hide element picker button - we'll auto-enable it in edit mode
            document.getElementById('elementPickerBtn').style.display = 'none';
            document.getElementById('referenceInput').style.display = mode === 'reference' ? 'flex' : 'none';
            
            // Clear selection effects when changing modes (except when entering edit mode)
            if (mode !== 'edit') {
                clearSelectionEffects();
                // Disable element picker if it was active
                if (elementPickerActive) {
                    elementPickerActive = false;
                    disableElementPicker();
                }
            }
            
            // Update placeholder text
            const textarea = document.getElementById('userInput');
            if (mode === 'add') {
                textarea.placeholder = "Describe what you want to add... (e.g., 'Add a footer with contact information')";
                // Reset selected element when switching to add mode
                selectedElement = null;
            } else if (mode === 'edit') {
                // Automatically enable element picker when entering edit mode
                if (!elementPickerActive && !selectedElement) {
                    elementPickerActive = true;
                    enableElementPicker();
                }
                textarea.placeholder = selectedElement ? 
                    `Describe how to edit the selected ${selectedElement.tag}...` :
                    "Click on an element in the preview to select it...";
            } else if (mode === 'reference') {
                textarea.placeholder = "Enter a URL above, then describe what you want to recreate (e.g., 'Create a similar hero section')";
                // Reset selected element
                selectedElement = null;
            } else if (mode === 'plan') {
                textarea.placeholder = "Describe your website project... I'll help you plan it step by step before we start building.";
                // Reset selected element
                selectedElement = null;
            }
            
            // Clear reference data when leaving reference mode
            if (mode !== 'reference') {
                referenceData = null;
            }
            
            // Reset plan mode when switching away
            if (mode !== 'plan') {
                isPlanMode = false;
                // Don't clear tasks if we're actively working on them
                if (currentTaskIndex === 0 || currentTaskIndex >= plannedTasks.length) {
                    plannedTasks = [];
                    currentTaskIndex = 0;
                }
            }
        }
        
        function showToast(message, duration = 3000) {
            // Remove any existing toast
            const existingToast = document.getElementById('elementPickerToast');
            if (existingToast) {
                existingToast.remove();
            }
            
            // Create toast element
            const toast = document.createElement('div');
            toast.id = 'elementPickerToast';
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #09090b;
                color: white;
                padding: 10px 16px;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                border: 1px solid #27272a;
                z-index: 100001;
                font-size: 14px;
                font-weight: 500;
                display: flex;
                align-items: center;
                gap: 8px;
                animation: slideDown 0.3s ease-out;
            `;
            
            toast.innerHTML = `
                <span style="font-size: 18px;">🎯</span>
                <span>${message}</span>
            `;
            
            // Add animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideDown {
                    from {
                        opacity: 0;
                        transform: translateX(-50%) translateY(-20px);
                    }
                    to {
                        opacity: 1;
                        transform: translateX(-50%) translateY(0);
                    }
                }
                @keyframes slideUp {
                    from {
                        opacity: 1;
                        transform: translateX(-50%) translateY(0);
                    }
                    to {
                        opacity: 0;
                        transform: translateX(-50%) translateY(-20px);
                    }
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(toast);
            
            // Auto-remove after duration
            setTimeout(() => {
                toast.style.animation = 'slideUp 0.3s ease-out';
                setTimeout(() => {
                    toast.remove();
                }, 300);
            }, duration);
        }
        
        function updateSelectedElementDisplay() {
            if (!selectedElement) {
                return;
            }
            
            // Also show in chat messages area when in edit mode
            if (currentMode === 'edit') {
                // Check if there's already a selected element message
                let selectionMsg = document.querySelector('.element-selection-message');
                if (!selectionMsg) {
                    selectionMsg = document.createElement('div');
                    selectionMsg.className = 'element-selection-message';
                    selectionMsg.style.cssText = `
                        background: linear-gradient(135deg, #667eea20, #764ba220);
                        border: 2px solid #667eea;
                        border-radius: 8px;
                        padding: 12px;
                        margin: 10px;
                        display: flex;
                        align-items: center;
                        gap: 10px;
                    `;
                    
                    const chatMessages = document.getElementById('chatMessages');
                    chatMessages.appendChild(selectionMsg);
                }
                
                selectionMsg.innerHTML = `
                    <span style="font-size: 18px;">🎯</span>
                    <div style="flex: 1;">
                        <div style="font-size: 12px; color: #667eea; font-weight: bold;">Selected Element</div>
                        <div style="font-size: 14px; color: #333; margin-top: 4px;">
                            <code style="background: #f0f0f0; padding: 2px 6px; border-radius: 6px; background: white;">${selectedElement.selector}</code>
                        </div>
                        ${selectedElement.text ? `<div style="font-size: 12px; color: #71717a; margin-top: 4px; font-style: italic;">"${selectedElement.text.substring(0, 50)}${selectedElement.text.length > 50 ? '...' : ''}"</div>` : ''}
                    </div>
                `;
            }
        }
        
        function clearSelectionEffects() {
            const previewFrame = document.getElementById('previewFrame');
            if (!previewFrame) return;
            
            const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
            if (!iframeDoc) return;
            
            // Remove selection class
            iframeDoc.querySelectorAll('.element-selected').forEach(el => {
                el.classList.remove('element-selected');
            });
            
            // Remove fade overlay
            const overlay = iframeDoc.querySelector('.editing-fade-overlay');
            if (overlay) {
                overlay.remove();
            }
            
            // Remove selection message from chat
            const selectionMsg = document.querySelector('.element-selection-message');
            if (selectionMsg) {
                selectionMsg.remove();
            }
        }
        
        function toggleElementPicker() {
            elementPickerActive = !elementPickerActive;
            const btn = document.getElementById('elementPickerBtn');
            btn.classList.toggle('active', elementPickerActive);
            
            if (elementPickerActive) {
                setMode('edit'); // Switch to edit mode when picking elements
                enableElementPicker();
            } else {
                disableElementPicker();
            }
        }
        
        function enableElementPicker() {
            const previewFrame = document.getElementById('previewFrame');
            const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
            
            // Show toast with ESC shortcut info
            showToast('Click an element to select it • Press ESC to cancel', 4000);
            
            // Add ESC key listener
            const escapeHandler = (e) => {
                if (e.key === 'Escape' && elementPickerActive) {
                    e.preventDefault();
                    elementPickerActive = false;
                    const btn = document.getElementById('elementPickerBtn');
                    btn.classList.remove('active');
                    disableElementPicker();
                    showToast('Selection cancelled', 2000);
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
            
            // Store the handler so we can remove it later
            window.elementPickerEscapeHandler = escapeHandler;
            
            // Create overlay
            let overlay = iframeDoc.getElementById('elementPickerOverlay');
            if (!overlay) {
                overlay = iframeDoc.createElement('div');
                overlay.id = 'elementPickerOverlay';
                overlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 9999;
                    pointer-events: none;
                `;
                iframeDoc.body.appendChild(overlay);
            }
            
            // Add hover effect to all elements
            const style = iframeDoc.createElement('style');
            style.id = 'elementPickerStyles';
            style.textContent = `
                body * {
                    cursor: crosshair !important;
                    position: relative;
                }
                body *:hover {
                    outline: 2px dashed #09090b !important;
                    background-color: rgba(9, 9, 11, 0.05) !important;
                }
                .element-selected {
                    position: relative !important;
                    z-index: 10001 !important;
                    border: 3px dashed white !important;
                    box-shadow: 
                        inset 0 0 0 1px rgba(0, 0, 0, 0.2),
                        0 0 0 1px rgba(0, 0, 0, 0.2),
                        0 0 20px rgba(255, 255, 255, 0.8) !important;
                    animation: pulseSelection 1.5s ease-in-out infinite !important;
                }
                @keyframes pulseSelection {
                    0%, 100% {
                        border-color: white;
                        box-shadow: 
                            inset 0 0 0 1px rgba(0, 0, 0, 0.2),
                            0 0 0 1px rgba(0, 0, 0, 0.2),
                            0 0 20px rgba(255, 255, 255, 0.8);
                    }
                    50% {
                        border-color: rgba(255, 255, 255, 0.8);
                        box-shadow: 
                            inset 0 0 0 1px rgba(0, 0, 0, 0.3),
                            0 0 0 1px rgba(0, 0, 0, 0.3),
                            0 0 30px rgba(255, 255, 255, 1);
                    }
                }
                .editing-fade-overlay {
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(255, 255, 255, 0.8);
                    z-index: 10000;
                    pointer-events: none;
                }
            `;
            iframeDoc.head.appendChild(style);
            
            // Add click handlers to all elements
            iframeDoc.body.addEventListener('click', handleElementClick, true);
            iframeDoc.body.addEventListener('mouseover', handleElementHover, true);
        }
        
        function disableElementPicker() {
            const previewFrame = document.getElementById('previewFrame');
            const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
            
            // Remove ESC key listener if it exists
            if (window.elementPickerEscapeHandler) {
                document.removeEventListener('keydown', window.elementPickerEscapeHandler);
                delete window.elementPickerEscapeHandler;
            }
            
            // Remove overlay
            const overlay = iframeDoc.getElementById('elementPickerOverlay');
            if (overlay) overlay.remove();
            
            // Remove styles
            const style = iframeDoc.getElementById('elementPickerStyles');
            if (style) style.remove();
            
            // Remove event listeners
            iframeDoc.body.removeEventListener('click', handleElementClick, true);
            iframeDoc.body.removeEventListener('mouseover', handleElementHover, true);
        }
        
        function handleElementClick(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const element = e.target;
            const tagName = element.tagName.toLowerCase();
            const classes = element.className ? `.${element.className.split(' ').filter(c => c !== 'element-selected' && c !== 'editing-label').join('.')}` : '';
            const id = element.id ? `#${element.id}` : '';
            
            // Store selected element info
            selectedElement = {
                element: element,
                tag: tagName,
                selector: tagName + id + classes,
                html: element.outerHTML,
                text: element.textContent.substring(0, 50)
            };
            
            // Update UI
            updateSelectedElementDisplay();
            
            // Remove toast if it exists
            const toast = document.getElementById('elementPickerToast');
            if (toast) {
                toast.remove();
            }
            
            // Keep element picker active but update placeholder
            const textarea = document.getElementById('userInput');
            if (textarea) {
                textarea.placeholder = `Describe how to edit the selected ${selectedElement.tag}...`;
                textarea.focus();
            }
            
            // Remove previous selection and effects
            const previewFrame = document.getElementById('previewFrame');
            const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
            
            // Remove previous selection
            iframeDoc.querySelectorAll('.element-selected').forEach(el => {
                el.classList.remove('element-selected');
            });
            
            // Remove previous fade overlay
            const existingOverlay = iframeDoc.querySelector('.editing-fade-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
            
            // Remove previous editing label
            const existingLabel = iframeDoc.querySelector('.editing-label');
            if (existingLabel) {
                existingLabel.remove();
            }
            
            // Add fade overlay
            const fadeOverlay = iframeDoc.createElement('div');
            fadeOverlay.className = 'editing-fade-overlay';
            iframeDoc.body.appendChild(fadeOverlay);
            
            // Add selection class
            element.classList.add('element-selected');
            
            // Disable picker
            toggleElementPicker();
            
            // Update placeholder
            document.getElementById('userInput').placeholder = `Describe how to edit the selected ${tagName}...`;
            document.getElementById('userInput').focus();
        }
        
        function handleElementHover(e) {
            // Could add hover tooltip here if needed
        }
        
        async function fetchReference() {
            const urlInput = document.getElementById('referenceUrl');
            const url = urlInput.value.trim();
            
            if (!url) {
                alert('Please enter a valid URL');
                return;
            }
            
            // Validate URL format
            try {
                new URL(url);
            } catch (e) {
                alert('Please enter a valid URL (e.g., https://example.com)');
                return;
            }
            
            const fetchBtn = document.querySelector('.fetch-button');
            fetchBtn.disabled = true;
            fetchBtn.textContent = '⏳ Fetching...';
            
            showMessage('assistant', `🔍 Fetching and analyzing ${url}...`);
            
            try {
                // Use CORS proxy to fetch the website
                const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
                
                const response = await fetch(proxyUrl);
                const data = await response.json();
                
                if (data.status.http_code !== 200) {
                    throw new Error('Failed to fetch the website');
                }
                
                // Parse the HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(data.contents, 'text/html');
                
                // Extract the main structure
                const bodyHTML = doc.body ? doc.body.innerHTML : '';
                
                // Extract styles
                const styles = Array.from(doc.querySelectorAll('style')).map(s => s.textContent).join('\n');
                const linkedStyles = Array.from(doc.querySelectorAll('link[rel="stylesheet"]')).map(l => `/* External CSS: ${l.href} */`).join('\n');
                
                // Store reference data
                referenceData = {
                    url: url,
                    html: bodyHTML,
                    css: styles + '\n' + linkedStyles,
                    title: doc.title || 'Untitled'
                };
                
                showMessage('assistant', `✅ Successfully fetched "${referenceData.title}". The website structure has been loaded as reference. Now describe what elements you want to recreate.`);
                
                // Focus on the input
                document.getElementById('userInput').focus();
                
            } catch (error) {
                console.error('Fetch error:', error);
                showMessage('assistant', `❌ Error fetching website: ${error.message}. As an alternative, you can describe the design you want to recreate manually.`);
                
                // Fallback: Let user describe manually
                referenceData = {
                    url: url,
                    html: null,
                    css: null,
                    manual: true
                };
            } finally {
                fetchBtn.disabled = false;
                fetchBtn.textContent = '🌐 Fetch & Analyze';
            }
        }
        
        let attachedImageData = null;
        
        function attachImage() {
            document.getElementById('imageInput').click();
        }
        
        function handleImageSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                alert('Please select an image file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                attachedImageData = e.target.result;
                
                // Show indicator that image is attached
                const attachBtn = document.querySelector('.attach-image-button');
                attachBtn.style.background = '#667eea';
                attachBtn.style.color = 'white';
                attachBtn.innerHTML = '✅';
                
                // Add a note in the textarea
                const textarea = document.getElementById('userInput');
                if (!textarea.value.includes('[Image attached]')) {
                    textarea.value += textarea.value ? '\n[Image attached]' : '[Image attached]';
                }
                
                showMessage('assistant', '📎 Image attached! Add your message and send.');
            };
            reader.readAsDataURL(file);
        }
        
        async function screenshotWithPrompt() {
            // First take the screenshot
            const imageData = await captureScreenshot();
            if (!imageData) return;
            
            // Show a prompt dialog for custom instructions
            const userPrompt = prompt('What would you like me to do with this screenshot?', 
                'Analyze this design and suggest improvements for better UI/UX');
            
            if (!userPrompt) return;
            
            // Send the screenshot with custom prompt
            await sendMessageWithImage(imageData, userPrompt);
        }
        
        async function captureScreenshot() {
            const previewFrame = document.getElementById('previewFrame');
            
            try {
                showMessage('assistant', '📸 Capturing preview screenshot...');
                
                // Use html2canvas library to capture the iframe content
                if (typeof html2canvas === 'undefined') {
                    await loadHtml2Canvas();
                }
                
                const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
                const clonedBody = iframeDoc.body.cloneNode(true);
                
                const tempContainer = document.createElement('div');
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px';
                tempContainer.style.width = previewFrame.offsetWidth + 'px';
                tempContainer.innerHTML = clonedBody.innerHTML;
                
                const styleElement = document.createElement('style');
                const styles = iframeDoc.head.querySelector('style');
                if (styles) {
                    styleElement.textContent = styles.textContent;
                    tempContainer.appendChild(styleElement);
                }
                
                document.body.appendChild(tempContainer);
                
                const canvas = await html2canvas(tempContainer, {
                    width: previewFrame.offsetWidth,
                    height: previewFrame.offsetHeight,
                    backgroundColor: '#ffffff',
                    logging: false
                });
                
                document.body.removeChild(tempContainer);
                
                return canvas.toDataURL('image/png');
            } catch (error) {
                console.error('Screenshot error:', error);
                showMessage('assistant', '❌ Failed to capture screenshot. Please try again.');
                return null;
            }
        }
        
        async function screenshotAndFix() {
            const previewFrame = document.getElementById('previewFrame');
            
            try {
                // Show loading state
                document.getElementById('sendButton').disabled = true;
                document.getElementById('loadingIndicator').classList.add('active');
                showMessage('assistant', '📸 Capturing preview screenshot...');
                
                // Use html2canvas library to capture the iframe content
                // First, we need to inject html2canvas if not already loaded
                if (typeof html2canvas === 'undefined') {
                    await loadHtml2Canvas();
                }
                
                // Get the iframe document
                const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
                
                // Clone the iframe content to capture it
                const clonedBody = iframeDoc.body.cloneNode(true);
                
                // Create a temporary container
                const tempContainer = document.createElement('div');
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px';
                tempContainer.style.width = previewFrame.offsetWidth + 'px';
                tempContainer.innerHTML = clonedBody.innerHTML;
                
                // Add the styles from iframe
                const styleElement = document.createElement('style');
                const styles = iframeDoc.head.querySelector('style');
                if (styles) {
                    styleElement.textContent = styles.textContent;
                    tempContainer.appendChild(styleElement);
                }
                
                document.body.appendChild(tempContainer);
                
                // Capture using html2canvas
                const canvas = await html2canvas(tempContainer, {
                    width: previewFrame.offsetWidth,
                    height: previewFrame.offsetHeight,
                    scale: 1,
                    useCORS: true,
                    logging: false
                });
                
                // Remove temporary container
                document.body.removeChild(tempContainer);
                
                // Convert canvas to base64
                const imageData = canvas.toDataURL('image/png');
                
                // Send to AI with the screenshot
                await sendMessageWithImage(imageData);
                
            } catch (error) {
                console.error('Screenshot error:', error);
                showMessage('assistant', `Error capturing screenshot: ${error.message}. As a fallback, I'll analyze your current code instead.`);
                
                // Fallback: send current code for analysis
                const fallbackMessage = `Please review and improve this code:\n\nHTML:\n${currentHTML}\n\nCSS:\n${currentCSS}\n\nMake it more visually appealing and fix any issues.`;
                document.getElementById('userInput').value = fallbackMessage;
                await sendMessage();
            } finally {
                document.getElementById('sendButton').disabled = false;
                document.getElementById('loadingIndicator').classList.remove('active');
            }
        }
        
        async function loadHtml2Canvas() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }
        
        let generatedImageData = null; // Store the generated image data
        let selectedImageFiles = []; // Store selected image files for input
        
        function handleImageSelection(input) {
            selectedImageFiles = [];
            const previewContainer = document.getElementById('selectedImagesPreview');
            previewContainer.innerHTML = '';
            
            if (input.files && input.files.length > 0) {
                Array.from(input.files).forEach((file, index) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        selectedImageFiles.push(e.target.result);
                        
                        // Create preview thumbnail
                        const imgContainer = document.createElement('div');
                        imgContainer.style.cssText = 'position: relative; width: 80px; height: 80px;';
                        
                        const img = document.createElement('img');
                        img.src = e.target.result;
                        img.style.cssText = 'width: 100%; height: 100%; object-fit: cover; border-radius: 6px; background: white; border: 1px solid #e4e4e7;';
                        
                        const removeBtn = document.createElement('button');
                        removeBtn.innerHTML = '×';
                        removeBtn.style.cssText = 'position: absolute; top: -5px; right: -5px; background: red; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; cursor: pointer; font-size: 14px;';
                        removeBtn.onclick = function() {
                            selectedImageFiles.splice(index, 1);
                            imgContainer.remove();
                        };
                        
                        imgContainer.appendChild(img);
                        imgContainer.appendChild(removeBtn);
                        previewContainer.appendChild(imgContainer);
                    };
                    reader.readAsDataURL(file);
                });
            }
        }
        
        function showImageGenerationDialog(showUploadOption = false) {
            // Image generation model is always set (only one option)
            
            const dialog = document.getElementById('imageGenDialog');
            dialog.style.display = 'flex';
            
            // Modify dialog for upload option if from context menu
            if (showUploadOption) {
                const dialogContent = dialog.querySelector('div');
                
                // Check if tabs already exist
                if (!dialog.querySelector('.image-tabs')) {
                    // Add tabs at the top
                    const tabsHTML = `
                        <div class="image-tabs" style="display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid #eee; padding-bottom: 10px;">
                            <button id="uploadTabBtn" onclick="switchImageTab('upload')" style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px 6px 0 0; cursor: pointer; font-weight: bold;">
                                📤 Upload Image
                            </button>
                            <button id="generateTabBtn" onclick="switchImageTab('generate')" style="padding: 8px 16px; background: #f0f0f0; color: #333; border: none; border-radius: 6px 6px 0 0; cursor: pointer;">
                                🎨 Generate with AI
                            </button>
                        </div>
                        <div id="uploadTabContent" style="display: block;">
                            <h3 style="margin: 0 0 20px 0; color: #333;">📤 Upload Your Image</h3>
                            <div style="margin-bottom: 20px;">
                                <input type="file" id="directImageUpload" accept="image/*" onchange="handleDirectImageUpload(this)" style="display: none;">
                                <button onclick="document.getElementById('directImageUpload').click()" style="padding: 12px 24px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; width: 100%;">
                                    📁 Choose Image File
                                </button>
                                <div id="uploadedImagePreview" style="margin-top: 20px; text-align: center;"></div>
                            </div>
                        </div>
                        <div id="generateTabContent" style="display: none;">
                    `;
                    
                    // Insert tabs before the existing content
                    const h2 = dialogContent.querySelector('h2');
                    h2.insertAdjacentHTML('afterend', tabsHTML);
                    
                    // Wrap existing generation content
                    const existingContent = Array.from(dialogContent.children).slice(3); // Skip h2 and tabs
                    const generateWrapper = document.createElement('div');
                    generateWrapper.innerHTML = '</div>';
                    existingContent.forEach(el => {
                        if (!el.classList.contains('image-tabs') && el.id !== 'uploadTabContent' && el.id !== 'generateTabContent') {
                            generateWrapper.appendChild(el);
                        }
                    });
                }
                
                // Show upload tab by default when from context menu
                switchImageTab('upload');
            }
            
            // Reset the dialog state
            document.getElementById('imagePrompt').value = '';
            document.getElementById('imageGenLoading').style.display = 'none';
            document.getElementById('imageGenResult').style.display = 'none';
            document.getElementById('generateImageButton').style.display = 'inline-block';
            document.getElementById('insertImageButton').style.display = 'none';
            document.getElementById('imageInputFiles').value = '';
            document.getElementById('selectedImagesPreview').innerHTML = '';
            selectedImageFiles = [];
        }
        
        function switchImageTab(tab) {
            const uploadTab = document.getElementById('uploadTabContent');
            const generateTab = document.getElementById('generateTabContent');
            const uploadBtn = document.getElementById('uploadTabBtn');
            const generateBtn = document.getElementById('generateTabBtn');
            
            if (tab === 'upload') {
                if (uploadTab) uploadTab.style.display = 'block';
                if (generateTab) generateTab.style.display = 'none';
                if (uploadBtn) {
                    uploadBtn.style.background = '#667eea';
                    uploadBtn.style.color = 'white';
                    uploadBtn.style.fontWeight = 'bold';
                }
                if (generateBtn) {
                    generateBtn.style.background = '#f0f0f0';
                    generateBtn.style.color = '#333';
                    generateBtn.style.fontWeight = 'normal';
                }
                // Hide generate button, show insert button if image is uploaded
                document.getElementById('generateImageButton').style.display = 'none';
                if (generatedImageData) {
                    document.getElementById('insertImageButton').style.display = 'inline-block';
                }
            } else {
                if (uploadTab) uploadTab.style.display = 'none';
                if (generateTab) generateTab.style.display = 'block';
                if (generateBtn) {
                    generateBtn.style.background = '#667eea';
                    generateBtn.style.color = 'white';
                    generateBtn.style.fontWeight = 'bold';
                }
                if (uploadBtn) {
                    uploadBtn.style.background = '#f0f0f0';
                    uploadBtn.style.color = '#333';
                    uploadBtn.style.fontWeight = 'normal';
                }
                // Show appropriate button
                document.getElementById('generateImageButton').style.display = generatedImageData ? 'none' : 'inline-block';
                document.getElementById('insertImageButton').style.display = generatedImageData ? 'inline-block' : 'none';
            }
        }
        
        function handleDirectImageUpload(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                generatedImageData = e.target.result;
                
                // Show preview
                const preview = document.getElementById('uploadedImagePreview');
                preview.innerHTML = `
                    <img src="${generatedImageData}" style="max-width: 100%; max-height: 300px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);" />
                    <p style="margin-top: 10px; color: #71717a; font-size: 14px;">✅ Image ready to insert</p>
                `;
                
                // Show insert button
                document.getElementById('insertImageButton').style.display = 'inline-block';
                document.getElementById('generateImageButton').style.display = 'none';
            };
            
            reader.readAsDataURL(file);
        }
        
        function closeImageGenDialog() {
            document.getElementById('imageGenDialog').style.display = 'none';
            generatedImageData = null;
            selectedImageFiles = [];
            
            // Clean up tabs if they exist
            const tabs = document.querySelector('.image-tabs');
            if (tabs) {
                tabs.remove();
            }
            const uploadContent = document.getElementById('uploadTabContent');
            if (uploadContent) {
                uploadContent.remove();
            }
            const generateContent = document.getElementById('generateTabContent');
            if (generateContent) {
                generateContent.remove();
            }
            
            // Reset context menu target if we were adding image from context menu
            if (contextMenuTarget) {
                contextMenuTarget = null;
            }
        }
        
        function addImageToElement() {
            // Store the target element from context menu
            const previewFrame = document.getElementById('previewFrame');
            if (!previewFrame || !contextMenuTarget) return;
            
            // Show the image generation dialog with upload option
            showImageGenerationDialog(true);
            
            // Modify the insert button behavior for context menu mode
            const insertBtn = document.getElementById('insertImageButton');
            const originalOnclick = insertBtn.onclick;
            
            // Override the insert function for this context
            insertBtn.onclick = function() {
                if (!generatedImageData) {
                    alert('No image to insert');
                    return;
                }
                
                const insertType = document.getElementById('imageInsertType').value;
                const prompt = document.getElementById('imagePrompt').value;
                const iframeDoc = previewFrame.contentDocument || previewFrame.contentWindow.document;
                
                if (!iframeDoc) return;
                
                // Create the image element
                let imageElement;
                if (insertType === 'img') {
                    imageElement = iframeDoc.createElement('img');
                    imageElement.src = generatedImageData;
                    imageElement.alt = prompt;
                    imageElement.style.cssText = 'max-width: 100%; height: auto; display: block; margin: 10px 0;';
                } else if (insertType === 'background') {
                    // Apply background to the target element
                    if (contextMenuTarget) {
                        contextMenuTarget.style.backgroundImage = `url('${generatedImageData}')`;
                        contextMenuTarget.style.backgroundSize = 'cover';
                        contextMenuTarget.style.backgroundPosition = 'center';
                        contextMenuTarget.style.backgroundRepeat = 'no-repeat';
                        // Ensure element has minimum height if empty
                        if (!contextMenuTarget.offsetHeight || contextMenuTarget.offsetHeight < 200) {
                            contextMenuTarget.style.minHeight = '300px';
                        }
                    }
                    
                    // Update the HTML/CSS storage
                    currentHTML = iframeDoc.body.innerHTML;
                    
                    // Close dialog and reset
                    closeImageGenDialog();
                    insertBtn.onclick = originalOnclick;
                    return;
                } else {
                    // Create a figure with caption
                    const figure = iframeDoc.createElement('figure');
                    figure.style.cssText = 'margin: 20px 0; text-align: center;';
                    
                    imageElement = iframeDoc.createElement('img');
                    imageElement.src = generatedImageData;
                    imageElement.alt = prompt;
                    imageElement.style.cssText = 'max-width: 100%; height: auto; display: block; margin: 0 auto;';
                    
                    const caption = iframeDoc.createElement('figcaption');
                    caption.textContent = prompt;
                    caption.style.cssText = 'margin-top: 10px; color: #71717a; font-style: italic;';
                    
                    figure.appendChild(imageElement);
                    figure.appendChild(caption);
                    imageElement = figure;
                }
                
                // Insert the image relative to the context menu target
                if (contextMenuTarget) {
                    // Check if target is a container element
                    const isContainer = ['DIV', 'SECTION', 'ARTICLE', 'MAIN', 'ASIDE', 'NAV', 'HEADER', 'FOOTER'].includes(contextMenuTarget.tagName);
                    
                    if (isContainer && contextMenuTarget.children.length > 0) {
                        // If it's a container with children, add at the end
                        contextMenuTarget.appendChild(imageElement);
                    } else if (isContainer) {
                        // If it's an empty container, add inside
                        contextMenuTarget.appendChild(imageElement);
                    } else {
                        // For inline elements or non-containers, insert after
                        contextMenuTarget.parentNode.insertBefore(imageElement, contextMenuTarget.nextSibling);
                    }
                } else {
                    // Fallback: add to end of body
                    iframeDoc.body.appendChild(imageElement);
                }
                
                // Update the HTML storage
                currentHTML = iframeDoc.body.innerHTML;
                
                // Close dialog and reset
                closeImageGenDialog();
                insertBtn.onclick = originalOnclick;
                
                // Hide context menu
                const contextMenu = document.getElementById('elementContextMenu');
                if (contextMenu) {
                    contextMenu.style.display = 'none';
                }
            };
        }
        
        async function generateImage() {
            const apiKey = document.getElementById('apiKey').value;
            const imageGenModel = document.getElementById('imageGenModelSelect').value;
            const prompt = document.getElementById('imagePrompt').value.trim();
            const size = document.getElementById('imageSize').value;
            
            if (!apiKey) {
                alert('Please enter your OpenRouter API key first');
                return;
            }
            
            if (!prompt) {
                alert('Please describe the image you want to generate');
                return;
            }
            
            // Show loading state
            document.getElementById('generateImageButton').style.display = 'none';
            document.getElementById('imageGenLoading').style.display = 'block';
            document.getElementById('imageGenResult').style.display = 'none';
            
            try {
                // Prepare the request based on the model
                let requestBody;
                
                // Special handling for DALL-E 3
                if (imageGenModel.includes('dall-e')) {
                    requestBody = {
                        model: imageGenModel,
                        prompt: prompt,
                        n: 1,
                        size: size
                    };
                } else {
                    // Standard chat completion with image modality
                    // Check if we have input images
                    let messageContent;
                    if (selectedImageFiles.length > 0) {
                        // Build content array with text and images
                        messageContent = [
                            {
                                type: 'text',
                                text: prompt
                            }
                        ];
                        
                        // Add each selected image
                        selectedImageFiles.forEach(imageData => {
                            messageContent.push({
                                type: 'image_url',
                                image_url: {
                                    url: imageData
                                }
                            });
                        });
                    } else {
                        // Just text prompt
                        messageContent = prompt;
                    }
                    
                    requestBody = {
                        model: imageGenModel,
                        messages: [
                            {
                                role: 'user',
                                content: messageContent
                            }
                        ],
                        modalities: ['image'],  // Only request image output, no text
                        max_tokens: 4000
                    };
                }
                
                console.log('Image generation request:', requestBody);
                
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Vibe Coder Image Generation'
                    },
                    body: JSON.stringify(requestBody)
                });
                
                const data = await response.json();
                console.log('Image generation response:', data);
                
                if (data.error) {
                    console.error('Image generation error response:', data.error);
                    throw new Error(data.error.message || 'Image generation failed');
                }
                
                // Extract the image data
                let imageUrl;
                
                console.log('Parsing response for image data...');
                
                if (data.choices && data.choices[0]) {
                    const choice = data.choices[0];
                    console.log('Choice data:', choice);
                    
                    // Check for images array first (new format)
                    if (choice.message && choice.message.images && Array.isArray(choice.message.images)) {
                        console.log('Found images array with', choice.message.images.length, 'images');
                        for (const img of choice.message.images) {
                            if (img.image_url && img.image_url.url) {
                                console.log('Found image in images array');
                                imageUrl = img.image_url.url;
                                break;
                            } else if (img.url) {
                                console.log('Found direct URL in images array');
                                imageUrl = img.url;
                                break;
                            }
                        }
                    }
                    
                    // Check for image in the message content (fallback)
                    if (!imageUrl && choice.message && choice.message.content) {
                        console.log('Message content type:', typeof choice.message.content);
                        console.log('Message content:', choice.message.content);
                        
                        // Check if content is an array (multimodal response)
                        if (Array.isArray(choice.message.content)) {
                            console.log('Content is array with', choice.message.content.length, 'parts');
                            
                            // Log all parts to understand structure
                            choice.message.content.forEach((part, index) => {
                                console.log(`Part ${index}:`, part);
                            });
                            
                            // Look for image in various formats
                            for (const part of choice.message.content) {
                                // Check for different image formats
                                if (part.type === 'image' && part.image) {
                                    console.log('Found image part with "image" property:', part);
                                    imageUrl = part.image;
                                    break;
                                } else if (part.type === 'image_url' && part.image_url) {
                                    console.log('Found image_url part:', part);
                                    imageUrl = part.image_url.url;
                                    break;
                                } else if (part.type === 'image' && part.data) {
                                    console.log('Found image part with "data" property:', part);
                                    // Check if data is base64 or needs formatting
                                    if (part.data.startsWith('data:image')) {
                                        imageUrl = part.data;
                                    } else {
                                        // Assume it's raw base64 and add data URI prefix
                                        imageUrl = `data:image/png;base64,${part.data}`;
                                    }
                                    break;
                                } else if (part.type === 'text' && part.text) {
                                    // Sometimes the image URL might be in text
                                    const urlMatch = part.text.match(/(https?:\/\/[^\s]+\.(png|jpg|jpeg|webp|gif)[^\s]*)/i);
                                    if (urlMatch) {
                                        console.log('Found image URL in text part:', urlMatch[0]);
                                        imageUrl = urlMatch[0];
                                    }
                                    // Also check for base64 in text
                                    const base64Match = part.text.match(/data:image\/(png|jpeg|jpg|webp);base64,([^"'\s]+)/);
                                    if (base64Match) {
                                        console.log('Found base64 image in text part');
                                        imageUrl = base64Match[0];
                                    }
                                }
                            }
                            
                            // If still no image, check if the last part might be an image
                            if (!imageUrl && choice.message.content.length > 1) {
                                const lastPart = choice.message.content[choice.message.content.length - 1];
                                console.log('Checking last part specifically:', lastPart);
                                
                                // Sometimes the image is just a string in the last element
                                if (typeof lastPart === 'string' && lastPart.startsWith('data:image')) {
                                    imageUrl = lastPart;
                                } else if (typeof lastPart === 'string' && lastPart.match(/^[A-Za-z0-9+/]+=*$/)) {
                                    // Looks like base64
                                    console.log('Last part appears to be base64 string');
                                    imageUrl = `data:image/png;base64,${lastPart}`;
                                }
                            }
                        } else if (typeof choice.message.content === 'string') {
                            // Look for base64 image data in string content
                            const base64Match = choice.message.content.match(/data:image\/(png|jpeg|jpg|webp);base64,([^"]+)/);
                            if (base64Match) {
                                console.log('Found base64 image in string content');
                                imageUrl = base64Match[0];
                            } else if (choice.message.content.includes('http')) {
                                // Look for URL
                                const urlMatch = choice.message.content.match(/(https?:\/\/[^\s]+)/);
                                if (urlMatch) {
                                    console.log('Found URL in string content:', urlMatch[0]);
                                    imageUrl = urlMatch[0];
                                }
                            }
                        }
                    }
                    
                    // Check for finish_reason with modality details
                    if (!imageUrl && choice.finish_details && choice.finish_details.type === 'max_tokens_image') {
                        console.log('Image generation hit max tokens, may need to increase max_tokens');
                    }
                } else if (data.data && data.data[0]) {
                    // DALL-E format
                    console.log('Using DALL-E format response');
                    imageUrl = data.data[0].url || data.data[0].b64_json;
                    if (data.data[0].b64_json) {
                        imageUrl = `data:image/png;base64,${data.data[0].b64_json}`;
                    }
                }
                
                console.log('Final extracted imageUrl:', imageUrl ? 'Found' : 'Not found');
                
                if (!imageUrl) {
                    console.error('Failed to extract image from response structure:', data);
                    throw new Error('No image was generated. The model might not support image generation or the response format is unexpected.');
                }
                
                // Store the generated image data
                generatedImageData = imageUrl;
                
                // Show the generated image
                document.getElementById('generatedImagePreview').src = imageUrl;
                document.getElementById('imageGenResult').style.display = 'block';
                document.getElementById('imageGenLoading').style.display = 'none';
                document.getElementById('insertImageButton').style.display = 'inline-block';
                
                showMessage('assistant', '🎨 Image generated successfully! You can now insert it into your design.');
                
            } catch (error) {
                console.error('Image generation error:', error);
                alert(`Failed to generate image: ${error.message}`);
                document.getElementById('imageGenLoading').style.display = 'none';
                document.getElementById('generateImageButton').style.display = 'inline-block';
            }
        }
        
        async function autoGeneratePlaceholderImages(skipConfirm = false) {
            const imageGenModel = document.getElementById('imageGenModelSelect').value; // Always set
            const apiKey = document.getElementById('apiKey').value;
            
            if (!apiKey) {
                if (!skipConfirm) {
                    alert('Please enter your OpenRouter API key first');
                }
                return;
            }
            
            // Find all placeholder images in the current HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = currentHTML;
            const placeholderImages = tempDiv.querySelectorAll('img[src*="placeholder.com"], img[data-image-prompt]');
            
            if (placeholderImages.length === 0) {
                if (!skipConfirm) {
                    alert('No placeholder images found in the current HTML');
                }
                return;
            }
            
            // Skip confirmation if auto-generating
            if (!skipConfirm) {
                const confirmGenerate = confirm(`Found ${placeholderImages.length} placeholder image(s). Generate real images for all of them?`);
                if (!confirmGenerate) return;
            }
            
            showMessage('assistant', `🎨 Starting to generate ${placeholderImages.length} images...`);
            
            const imagePromptTemplate = document.getElementById('imagePromptTemplate')?.value || 
                'Professional photography, high quality, 8k resolution, {description}, modern aesthetic';
            
            let successCount = 0;
            let failCount = 0;
            
            for (let i = 0; i < placeholderImages.length; i++) {
                const img = placeholderImages[i];
                const placeholderSrc = img.src;
                
                // Extract description from various sources
                let description = '';
                
                // Try data-image-prompt first
                if (img.getAttribute('data-image-prompt')) {
                    description = img.getAttribute('data-image-prompt');
                } 
                // Try extracting from placeholder URL text parameter
                else if (placeholderSrc.includes('text=')) {
                    const textMatch = placeholderSrc.match(/text=([^&]+)/);
                    if (textMatch) {
                        description = decodeURIComponent(textMatch[1].replace(/\+/g, ' '));
                    }
                }
                // Fallback to alt text
                else if (img.alt) {
                    description = img.alt;
                }
                
                if (!description) {
                    console.log(`Skipping image ${i + 1}: No description found`);
                    failCount++;
                    continue;
                }
                
                // Build the prompt using the template
                const imagePrompt = imagePromptTemplate.replace('{description}', description);
                
                showMessage('assistant', `📸 Generating image ${i + 1}/${placeholderImages.length}: ${description.substring(0, 50)}...`);
                
                try {
                    // Generate the image
                    const requestBody = imageGenModel.includes('dall-e') ? {
                        model: imageGenModel,
                        prompt: imagePrompt,
                        n: 1,
                        size: '1024x1024'
                    } : {
                        model: imageGenModel,
                        messages: [{
                            role: 'user',
                            content: imagePrompt
                        }],
                        modalities: ['image'],  // Only request image output, no text
                        max_tokens: 4000
                    };
                    
                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Vibe Coder Auto Image Generation'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    const data = await response.json();
                    
                    if (data.error) {
                        throw new Error(data.error.message || 'Image generation failed');
                    }
                    
                    // Extract the image URL
                    let imageUrl;
                    if (data.choices && data.choices[0]) {
                        const choice = data.choices[0];
                        
                        // Check for images array first (new format when using modalities: ['image'])
                        if (choice.message && choice.message.images && Array.isArray(choice.message.images)) {
                            for (const img of choice.message.images) {
                                if (img.image_url && img.image_url.url) {
                                    imageUrl = img.image_url.url;
                                    break;
                                } else if (img.url) {
                                    imageUrl = img.url;
                                    break;
                                }
                            }
                        }
                        
                        // Fallback to checking content
                        if (!imageUrl && choice.message && choice.message.content) {
                            const base64Match = choice.message.content.match(/data:image\/(png|jpeg|jpg|webp);base64,([^"]+)/);
                            if (base64Match) {
                                imageUrl = base64Match[0];
                            } else if (choice.message.content.includes('http')) {
                                const urlMatch = choice.message.content.match(/(https?:\/\/[^\s]+)/);
                                if (urlMatch) {
                                    imageUrl = urlMatch[0];
                                }
                            }
                        }
                    } else if (data.data && data.data[0]) {
                        imageUrl = data.data[0].url || `data:image/png;base64,${data.data[0].b64_json}`;
                    }
                    
                    if (imageUrl) {
                        // Update the image in HTML
                        const imgInHTML = currentHTML.includes(placeholderSrc) ? placeholderSrc : img.outerHTML;
                        currentHTML = currentHTML.replace(imgInHTML, img.outerHTML.replace(placeholderSrc, imageUrl));
                        successCount++;
                    } else {
                        failCount++;
                    }
                    
                } catch (error) {
                    console.error(`Failed to generate image ${i + 1}:`, error);
                    failCount++;
                }
                
                // Small delay between requests to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            // Update the editors and preview
            document.getElementById('htmlEditor').value = currentHTML;
            updatePreview();
            generateOxygenJSON();
            
            showMessage('assistant', `✅ Image generation complete! Successfully generated ${successCount} image(s)${failCount > 0 ? `, ${failCount} failed` : ''}.`);
        }
        
        function insertGeneratedImage() {
            if (!generatedImageData) {
                alert('No image to insert');
                return;
            }
            
            const insertType = document.getElementById('imageInsertType').value;
            const prompt = document.getElementById('imagePrompt').value;
            
            let newHTML = '';
            let newCSS = '';
            
            switch (insertType) {
                case 'img':
                    // Simple image element
                    newHTML = `<img src="${generatedImageData}" alt="${prompt}" style="max-width: 100%; height: auto; display: block; margin: 20px auto;">`;
                    break;
                    
                case 'background':
                    // Add as background to existing element or create new section
                    const sectionId = 'generated-section-' + Date.now();
                    newHTML = `<section id="${sectionId}" class="generated-bg-section">
    <div class="content">
        <h2>Your Content Here</h2>
        <p>This section has your generated image as background</p>
    </div>
</section>`;
                    newCSS = `#${sectionId} {
    background-image: url('${generatedImageData}');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    min-height: 500px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}

#${sectionId} .content {
    background: rgba(255, 255, 255, 0.95);
    padding: 40px;
    border-radius: 12px;
    text-align: center;
    max-width: 600px;
}`;
                    break;
                    
                case 'hero':
                    // Create a complete hero section
                    newHTML = `<section class="ai-hero-section" style="background-image: url('${generatedImageData}'); background-size: cover; background-position: center; min-height: 600px; position: relative; display: flex; align-items: center; justify-content: center;">
    <div class="hero-overlay" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.4);"></div>
    <div class="hero-content" style="position: relative; z-index: 1; text-align: center; color: white; padding: 40px;">
        <h1 style="font-size: 48px; margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">Welcome to Our Site</h1>
        <p style="font-size: 20px; margin-bottom: 30px; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">Your journey starts here with stunning AI-generated visuals</p>
        <button style="background: white; color: #333; padding: 15px 40px; border: none; border-radius: 50px; font-size: 18px; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">Get Started</button>
    </div>
</section>`;
                    break;
            }
            
            // Add the generated content to the current HTML/CSS
            if (currentMode === 'add' || !currentHTML) {
                currentHTML = (currentHTML || '') + '\n' + newHTML;
                currentCSS = (currentCSS || '') + (newCSS ? '\n' + newCSS : '');
            } else {
                currentHTML = newHTML + '\n' + (currentHTML || '');
                currentCSS = newCSS + '\n' + (currentCSS || '');
            }
            
            // Update editors and preview
            document.getElementById('htmlEditor').value = currentHTML;
            document.getElementById('cssEditor').value = currentCSS;
            updatePreview();
            generateOxygenJSON();
            
            // Close the dialog
            closeImageGenDialog();
            
            // Show success message
            showMessage('assistant', `✅ Generated image inserted as ${insertType === 'img' ? 'an image element' : insertType === 'background' ? 'a background image' : 'a hero section'}!`);
        }
        
        async function sendMessageWithImage(imageData, customPrompt = null) {
            const apiKey = document.getElementById('apiKey').value;
            // Use vision model for screenshot analysis, fall back to regular model if not set
            const visionModel = document.getElementById('visionModelSelect')?.value || 
                               document.getElementById('modelSelect').value;
            
            if (!apiKey) {
                alert('Please enter your OpenRouter API key first');
                return;
            }
            
            // Store current content BEFORE AI modifies it (for ADD mode merging)
            const previousHTML = currentHTML;
            const previousCSS = currentCSS;
            
            // Use custom prompt or default message
            const userMessage = customPrompt || 'Here is a screenshot of the current design. Please analyze it and provide improvements to make it more visually appealing, fix any layout issues, and ensure it follows modern web design best practices. Provide the updated HTML and CSS code.';
            
            // Don't show duplicate message if already shown
            if (!customPrompt) {
                showMessage('user', '📸 ' + userMessage + ' [Screenshot attached]');
            }
            
            // Add to conversation history with image
            const messageWithImage = {
                role: 'user',
                content: [
                    {
                        type: 'text',
                        text: userMessage
                    },
                    {
                        type: 'image_url',
                        image_url: {
                            url: imageData
                        }
                    }
                ]
            };
            
            conversationHistory.push(messageWithImage);
            
            try {
                const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Vibe Coder for Oxygen'
                    },
                    body: JSON.stringify({
                        model: visionModel,
                        messages: [
                            {
                                role: 'system',
                                content: getSystemPromptWithBrandGuidelines() + `

IMPORTANT: You MUST follow this EXACT format for ALL responses:

[EXPLANATION]
Brief description of what you created or fixed

[HTML]
\`\`\`html
(your HTML code here)
\`\`\`

[CSS]
\`\`\`css
(your CSS code here)
\`\`\`

When analyzing screenshots, identify issues and provide improved code.`
                            },
                            ...conversationHistory
                        ],
                        temperature: 0.7,
                        max_tokens: getModelContextLength(visionModel)
                    })
                });
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error.message || 'API request failed');
                }
                
                const aiResponse = data.choices[0].message.content;
                
                // Add AI response to history (simplified for storage)
                conversationHistory.push({ role: 'assistant', content: aiResponse });
                
                // Parse and extract code from response (pass previous content for ADD mode)
                parseAIResponse(aiResponse, previousHTML, previousCSS, currentJS);
                
                // Show AI message
                showMessage('assistant', '🎨 ' + aiResponse.split('[HTML]')[0].replace('[EXPLANATION]', '').trim());
                
            } catch (error) {
                showMessage('assistant', `Error: ${error.message}`);
            } finally {
                document.getElementById('sendButton').disabled = false;
                document.getElementById('loadingIndicator').classList.remove('active');
            }
        }

        // Auto-update preview when editing HTML/CSS
        document.getElementById('htmlEditor')?.addEventListener('input', () => {
            currentHTML = document.getElementById('htmlEditor').value;
            updatePreview();
            generateOxygenJSON();
        });

        document.getElementById('cssEditor')?.addEventListener('input', () => {
            currentCSS = document.getElementById('cssEditor').value;
            // Update backup when user manually edits CSS
            if (currentCSS.trim()) {
                lastKnownGoodCSS = currentCSS;
            }
            updatePreview();
            generateOxygenJSON();
        });
    </script>
</body>
</html>